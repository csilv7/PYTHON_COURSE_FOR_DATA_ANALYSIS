[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Python",
    "section": "",
    "text": "1 Boas-vindas ao Universo da Análise de Dados com Python!\nSeja muito bem-vindo(a) ao Curso de Python para Análise de Dados! Se você está aqui, provavelmente compartilha da curiosidade e do desejo de transformar dados brutos em informações valiosas e decisões estratégicas. Este curso foi meticulosamente planejado para ser sua porta de entrada nesse universo fascinante, guiando você desde os primeiros passos na programação com Python até a aplicação de técnicas essenciais de análise de dados.\nPython se consolidou como uma das linguagens de programação mais influentes e requisitadas no campo da Ciência e Análise de Dados. Sua popularidade não é por acaso: a sintaxe intuitiva, a vasta coleção de bibliotecas especializadas e uma comunidade global ativa tornam o aprendizado mais acessível e o desenvolvimento mais eficiente. Aqui, você descobrirá como aproveitar todo esse potencial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#sobre-o-autor",
    "href": "index.html#sobre-o-autor",
    "title": "Curso de Python",
    "section": "1.1 Sobre o Autor",
    "text": "1.1 Sobre o Autor\n\n\n\n\n\n\nConheça o Instrutor\n\n\n\nMeu nome é Breno C R Silva, sou Bacharelando em Estatística pela Universidade Federal do Pará com foco em Estatística Descritiva, Probabilidade, Estatística Inferêncial, Modelos de Regressão e Classificação e, em especial, Análise de Séries Temporais e Análise de Sobrevivência.\nTrabalho com Python e Análise de Dados há 3 anos, aplicando essas ferramentas em Previsão do ICMS, Modelagem Semiparamétrica em Dados Sujeitos a Censura Intervalar, Previsão de Concessão de Crédito entre outros projetos.\nCriei este curso para compartilhar meu conhecimento e ajudar mais pessoas a descobrirem o poder dos dados. Espero que aproveitem a jornada!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#por-que-aprender-python-para-análise-de-dados",
    "href": "index.html#por-que-aprender-python-para-análise-de-dados",
    "title": "Curso de Python",
    "section": "1.2 Por Que Aprender Python para Análise de Dados?",
    "text": "1.2 Por Que Aprender Python para Análise de Dados?\nVivemos na era dos dados. Empresas, instituições de pesquisa e organizações de todos os tipos coletam volumes massivos de informações diariamente. A capacidade de analisar esses dados para extrair insights, identificar padrões, prever tendências e comunicar descobertas tornou-se uma habilidade crucial e altamente valorizada no mercado de trabalho.\nPython, com seu ecossistema robusto (especialmente bibliotecas como Pandas, NumPy, Matplotlib e Seaborn), oferece as ferramentas perfeitas para realizar todo o ciclo de vida da análise de dados:\n\nColeta e Limpeza: Obter dados de diversas fontes e prepará-los para análise, tratando inconsistências e valores ausentes.\nManipulação e Transformação: Estruturar, filtrar, agregar e remodelar os dados para atender às necessidades da análise.\nAnálise Exploratória (EDA): Investigar os dados para entender suas características principais, descobrir relações e formular hipóteses.\nVisualização: Criar gráficos e representações visuais claras e impactantes para comunicar os resultados.\nComunicação: Gerar relatórios e apresentações que traduzam as descobertas técnicas em informações acionáveis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#objetivos-de-aprendizagem-do-curso",
    "href": "index.html#objetivos-de-aprendizagem-do-curso",
    "title": "Curso de Python",
    "section": "1.3 Objetivos de Aprendizagem do Curso",
    "text": "1.3 Objetivos de Aprendizagem do Curso\nAo concluir este curso, você estará apto(a) a:\n\nDominar os Fundamentos de Python: Escrever código Python claro e eficiente, utilizando variáveis, tipos de dados, operadores, estruturas de controle (condicionais e loops) e funções.\nManipular Dados com Pandas: Utilizar DataFrames e Series para carregar, limpar, transformar, filtrar, agregar e combinar conjuntos de dados de forma eficaz.\nRealizar Cálculos Numéricos com NumPy: Empregar arrays NumPy para operações matemáticas e estatísticas vetorizadas de alta performance.\nCriar Visualizações com Matplotlib e Seaborn: Gerar diversos tipos de gráficos (linhas, barras, dispersão, histogramas, boxplots, etc.) para explorar dados e comunicar resultados visualmente.\nAplicar o Processo de Análise de Dados: Integrar as ferramentas aprendidas para realizar análises exploratórias básicas em conjuntos de dados reais ou simulados.\nDesenvolver Raciocínio Analítico: Interpretar os resultados das análises e das visualizações para extrair conclusões relevantes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#a-quem-se-destina-este-curso",
    "href": "index.html#a-quem-se-destina-este-curso",
    "title": "Curso de Python",
    "section": "1.4 A Quem Se Destina Este Curso?",
    "text": "1.4 A Quem Se Destina Este Curso?\nEste material foi pensado com carinho para um público diversificado, incluindo:\n\nEstudantes Universitários: De cursos como Estatística, Ciência da Computação, Engenharias, Economia, Administração e áreas afins que desejam uma introdução prática à análise de dados com Python.\nProfissionais em Transição de Carreira: Pessoas que buscam adquirir habilidades em análise de dados para novas oportunidades no mercado.\nCuriosos e Entusiastas: Qualquer pessoa com interesse em aprender a programar e a trabalhar com dados. Acreditamos que a vontade de aprender é o principal pré-requisito!\nIniciantes em Programação: Se você nunca programou antes, não se preocupe! Começaremos do básico.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-detalhada-do-curso",
    "href": "index.html#estrutura-detalhada-do-curso",
    "title": "Curso de Python",
    "section": "1.5 Estrutura Detalhada do Curso",
    "text": "1.5 Estrutura Detalhada do Curso\nNossa jornada será dividida em módulos progressivos, construindo seu conhecimento passo a passo:\n\nMódulo 1: Fundamentos Essenciais de Python:\n\nIntrodução à linguagem e configuração do ambiente (Anaconda, Jupyter Notebook).\nSintaxe básica, variáveis, tipos de dados (números, strings, booleanos).\nOperadores (aritméticos, comparação, lógicos).\nEstruturas de dados nativas: Listas, Tuplas, Dicionários e Conjuntos (Sets).\nEstruturas de controle: Condicionais (if, elif, else) e Laços de repetição (for, while).\nDefinição e uso de Funções para modularizar o código.\n\nMódulo 2: Computação Numérica com NumPy:\n\nIntrodução aos arrays NumPy (ndarrays) e suas vantagens.\nCriação, indexação e fatiamento de arrays uni e multidimensionais.\nOperações matemáticas vetorizadas e broadcasting.\nFunções estatísticas e manipulação de arrays.\n\nMódulo 3: Manipulação e Análise de Dados com Pandas:\n\nAs estruturas chave: Series e DataFrames.\nLeitura e escrita de dados (CSV, Excel, etc.).\nSeleção e filtragem de dados (loc, iloc, boolean indexing).\nLimpeza de dados: Tratamento de valores ausentes e duplicados.\nTransformação de dados: Aplicação de funções, criação de novas colunas.\nAgrupamento e agregação com groupby().\nCombinação de DataFrames (merge, concat, join).\n\nMódulo 4: Visualização de Dados com Matplotlib e Seaborn:\n\nPrincípios da visualização de dados.\nCriação de gráficos básicos e customização com Matplotlib.\nGeração de gráficos estatísticos avançados e esteticamente agradáveis com Seaborn.\nIntegração com Pandas para visualização direta de DataFrames.\n\nMódulo 5: Projeto de Análise Exploratória de Dados (EDA):\n\nAplicação integrada dos conhecimentos adquiridos em um projeto prático.\nPasso a passo: Definição do problema, coleta/carregamento dos dados, limpeza, análise exploratória, visualização e comunicação dos resultados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#nossa-metodologia-de-ensino",
    "href": "index.html#nossa-metodologia-de-ensino",
    "title": "Curso de Python",
    "section": "1.6 Nossa Metodologia de Ensino",
    "text": "1.6 Nossa Metodologia de Ensino\nBuscamos um equilíbrio entre teoria e prática, utilizando uma abordagem ativa:\n\nConteúdo Conceitual Claro: Explicações diretas e objetivas dos conceitos fundamentais, utilizando analogias e exemplos simples.\nCódigo Comentado e Exemplos Práticos: Demonstrações passo a passo de como aplicar cada conceito e ferramenta em Python, com código funcional e comentado.\nFoco na Resolução de Problemas: Apresentação de cenários e problemas típicos da análise de dados para contextualizar o aprendizado.\nExercícios Progressivos: Desafios práticos ao final das seções para você testar e consolidar seu entendimento.\nProjetos Integradores: Aplicação do conhecimento em projetos que simulam situações reais de análise.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#pré-requisitos-e-ferramentas",
    "href": "index.html#pré-requisitos-e-ferramentas",
    "title": "Curso de Python",
    "section": "1.7 Pré-requisitos e Ferramentas",
    "text": "1.7 Pré-requisitos e Ferramentas\n\n1.7.1 Pré-requisitos\n\nFamiliaridade básica com o uso de computadores: Saber navegar em pastas, usar um navegador de internet e instalar programas simples.\nCuriosidade e Vontade de Aprender: A motivação é seu maior trunfo!\nNenhuma experiência prévia em programação é exigida. O curso foi desenhado para iniciantes.\n\n\n\n1.7.2 Ferramentas Recomendadas\nPara acompanhar o curso, você precisará de um ambiente Python configurado. Recomendamos fortemente a instalação da Distribuição Anaconda, que já inclui Python, o Jupyter Notebook e as principais bibliotecas que usaremos.\n\nAnaconda: Baixe em anaconda.com/download. Siga as instruções de instalação para seu sistema operacional.\nJupyter Notebook/JupyterLab: Ambiente interativo ideal para aprender e experimentar com código e visualizações. Vem com o Anaconda.\nAlternativas Online (sem instalação):\n\nGoogle Colaboratory: Ambiente Jupyter Notebook gratuito na nuvem, oferecido pelo Google.\nJupyterLite (via Jupyter.org): Executa um ambiente JupyterLab diretamente no seu navegador.\nProgramiz Online Compiler: Útil para testar pequenos trechos de código Python rapidamente.\n\nEditor de Código (Opcional Avançado): Se preferir, pode usar editores como VSCode com a extensão Python, mas o Jupyter é mais indicado para o formato do curso.\n\n\n\n\n\n\n\nDica de Instalação\n\n\n\nRecomendamos fortemente o uso do Anaconda, pois ele simplifica a gestão das bibliotecas (pacotes) que usaremos ao longo do curso. Se encontrar dificuldades na instalação, procure tutoriais específicos para seu sistema operacional ou utilize as alternativas online.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#recursos-adicionais-e-comunidade",
    "href": "index.html#recursos-adicionais-e-comunidade",
    "title": "Curso de Python",
    "section": "1.8 Recursos Adicionais e Comunidade",
    "text": "1.8 Recursos Adicionais e Comunidade\nO aprendizado não termina aqui! Explore estes recursos para aprofundar seus conhecimentos:\n\nDocumentação Oficial:\n\nPython\nNumPy\nPandas\nMatplotlib\nSeaborn\n\nComunidades Online: Stack Overflow, Reddit (r/learnpython, r/datascience), fóruns específicos.\nPlataformas de Aprendizado: Kaggle Learn, DataCamp, Coursera, edX.\nSites de Apoio (mencionados anteriormente):\n\nPython Academy\nPython Examples\nHashtag Treinamentos (YouTube)\n\n\n\nEstamos muito animados para começar esta jornada de aprendizado com você! Prepare-se para mergulhar no mundo da programação Python e descobrir como os dados podem contar histórias incríveis. Vamos lá!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Boas-vindas ao Universo da Análise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "Módulo I/01_Fundamentals_of_Python.html",
    "href": "Módulo I/01_Fundamentals_of_Python.html",
    "title": "Primeiros Passos",
    "section": "",
    "text": "Introdução ao Python\nNeste primeiro capítulo, daremos os passos iniciais no mundo da programação com Python. Vamos entender o que é essa linguagem, por que ela se tornou tão popular (especialmente para análise de dados) e como preparar nosso ambiente para começar a codificar.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "Módulo I/01_Fundamentals_of_Python.html#introdução-ao-python",
    "href": "Módulo I/01_Fundamentals_of_Python.html#introdução-ao-python",
    "title": "Primeiros Passos",
    "section": "",
    "text": "O Que Torna Python Especial?\nPython é frequentemente descrita como uma linguagem de programação poderosa, versátil e, acima de tudo, legível. Mas o que isso significa na prática?\n\nLinguagem Interpretada: Diferente de linguagens compiladas (como C++ ou Java), onde o código fonte é traduzido para código de máquina antes da execução, o código Python é executado linha por linha por um programa chamado interpretador. Isso facilita o desenvolvimento e o teste, pois você pode executar pequenos trechos de código rapidamente.\nAlto Nível: Python abstrai muitos detalhes complexos do hardware do computador (como gerenciamento de memória). Isso permite que você se concentre na lógica do problema que está tentando resolver, em vez de se preocupar com detalhes de baixo nível.\nTipagem Dinâmica: Você não precisa declarar explicitamente o tipo de uma variável (inteiro, texto, etc.) antes de usá-la. O Python infere o tipo automaticamente durante a execução. Isso torna o código mais conciso, mas exige atenção para evitar erros relacionados a tipos inesperados.\nPropósito Geral: Python não se limita a uma única área. É usada em desenvolvimento web, automação de tarefas, inteligência artificial, computação científica e, claro, análise e ciência de dados.\nSintaxe Clara e Legível: A sintaxe do Python foi projetada para ser próxima da linguagem humana, utilizando indentação (espaços no início da linha) para definir blocos de código, o que força a escrita de um código visualmente organizado.\n\nEssas características, combinadas com um vasto ecossistema de bibliotecas (conjuntos de código pré-escrito para tarefas específicas), fazem do Python uma ferramenta excepcional para análise de dados, adotada por gigantes como Google, NASA, Facebook (Meta), Amazon e Spotify.\n\n\nConfigurando o Ambiente: Anaconda e Jupyter Notebook\nPara começar nossa jornada, precisamos instalar o Python e as ferramentas necessárias. A maneira mais recomendada para iniciantes em análise de dados é usar a Distribuição Anaconda.\nO que é Anaconda? É um pacote que inclui:\n\nO interpretador Python.\nUm gerenciador de pacotes (bibliotecas) chamado conda.\nDiversas bibliotecas científicas e de análise de dados pré-instaladas (como NumPy, Pandas, Matplotlib).\nFerramentas úteis, como o Jupyter Notebook e o JupyterLab.\n\nO que é Jupyter Notebook? É uma aplicação web interativa que permite criar e compartilhar documentos (chamados notebooks) que contêm código executável (como Python), texto formatado (Markdown), equações, visualizações e muito mais. É um ambiente ideal para aprendizado, experimentação e apresentação de análises de dados.\nPassos para Instalação:\n\nDownload: Acesse o site oficial do Anaconda: https://www.anaconda.com/download\nEscolha seu Sistema Operacional: Baixe o instalador apropriado para Windows, macOS ou Linux.\nInstalação: Execute o instalador e siga as instruções. Geralmente, as opções padrão são adequadas para iniciantes.\nVídeo de Apoio: Se precisar de ajuda visual, este tutorial de instalação no YouTube pode ser útil.\n\n\n\n\n\n\n\nDúvidas na Instalação?\n\n\n\nSe encontrar problemas, não hesite em procurar tutoriais mais específicos para sua versão do sistema operacional ou entrar em contato:\n\nEmail do Instrutor: breno.silva@icen.ufpa.br\n\n\n\nApós a instalação, você poderá iniciar o Jupyter Notebook (geralmente através do Anaconda Navigator ou pelo terminal/prompt de comando digitando jupyter notebook).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "Módulo I/01_Fundamentals_of_Python.html#sintaxe-básica-a-gramática-do-python",
    "href": "Módulo I/01_Fundamentals_of_Python.html#sintaxe-básica-a-gramática-do-python",
    "title": "Primeiros Passos",
    "section": "Sintaxe Básica: A Gramática do Python",
    "text": "Sintaxe Básica: A Gramática do Python\nToda linguagem tem suas regras. Em Python, a sintaxe define como escrevemos comandos válidos que o interpretador possa entender. Vamos começar com o básico.\n\nExibindo Informações: A Função print()\nA primeira função que a maioria dos programadores aprende é a print(). Sua finalidade é exibir informações (texto, números, resultados de cálculos) na tela (console ou saída do notebook).\nO famoso “Hello, World!”:\nprint(\"Hello, World!\")\nComo funciona?\n\nprint é o nome da função.\nOs parênteses () são usados para chamar a função e passar informações para ela.\nO que está dentro dos parênteses é chamado de argumento. Neste caso, o argumento é o texto (string) \"Hello, World!\".\nStrings em Python são definidas usando aspas simples ('...') ou duplas (\"...\").\n\n\nErros Comuns com print()\nÉ normal cometer erros ao aprender. Vejamos alguns deslizes comuns com print():\n\nNome Incorreto (Case-Sensitive): Python diferencia maiúsculas de minúsculas.\n# Exemplo de Código Incorreto\nPrint(\"Olá\")\nErro Gerado: NameError: name 'Print' is not defined (O Python não reconhece ‘Print’ com ‘P’ maiúsculo).\nFaltando Aspas: Textos (strings) precisam estar entre aspas.\n# Exemplo de Código Incorreto\nprint(Olá)\nErro Gerado: SyntaxError: invalid syntax (O Python não entende ‘Olá’ como um comando ou variável válida sem aspas).\nAspas Incompletas: Abrir aspas e não fechar (ou vice-versa).\n# Exemplo de Código Incorreto\nprint(\"Olá)\nErro Gerado: SyntaxError: unterminated string literal (A string não foi finalizada corretamente).\nMisturar Tipos de Aspas: Começar com simples e terminar com duplas (ou vice-versa).\n# Exemplo de Código Incorreto\nprint('Olá\")\nErro Gerado: SyntaxError: unterminated string literal.\n\n\n\n\n\n\n\nAtenção à Sintaxe!\n\n\n\nErros de sintaxe são como erros de gramática. O interpretador Python precisa que as regras sejam seguidas para entender suas instruções. Prestar atenção aos detalhes (maiúsculas/minúsculas, parênteses, aspas) é fundamental.\n\n\nUsando Aspas Dentro de Strings:\nSe precisar incluir aspas no seu texto, alterne os tipos de aspas:\nprint('Ele disse: \"Python é incrível!\"')\nprint(\"O livro se chama 'O Guia do Mochileiro das Galáxias'.\")\nQuebras de Linha:\nPara inserir uma quebra de linha dentro de uma string, use o caractere especial \\n (barra invertida seguida de ‘n’):\nprint(\"Linha 1\\nLinha 2\\nLinha 3\")\n\n\n\nOperadores Matemáticos: Calculando com Python\nPython pode ser usado como uma calculadora poderosa. Ele suporta os operadores matemáticos básicos e alguns mais avançados. Observe a Tabela 1.\n\n\n\n\nTabela 1: Operadores Matemáticos.\n\n\n\n\n\n\nOperador\nDescrição\nExemplo\nResultado\n\n\n\n\n+\nAdição\n5 + 3\n8\n\n\n-\nSubtração\n5 - 3\n2\n\n\n*\nMultiplicação\n5 * 3\n15\n\n\n/\nDivisão (float)\n10 / 3\n3.3333\n\n\n//\nDivisão (int)\n10 // 3\n3\n\n\n%\nMódulo (Resto)\n10 % 3\n1\n\n\n**\nExponenciação\n2 ** 3\n8\n\n\n\n\n\n\n\n\nExemplos:\n\n\nCódigo\n# Adição e Subtração\nprint(10 + 5)  \n\n\n15\n\n\nCódigo\nprint(10 - 5.5)\n\n\n4.5\n\n\nCódigo\n# Multiplicação e Divisão\nprint(4 * 7)\n\n\n28\n\n\nCódigo\nprint(15 / 4)   # Divisão resulta em float\n\n\n3.75\n\n\nCódigo\n# Divisão Inteira (descarta a parte decimal)\nprint(15 // 4)  \n\n\n3\n\n\nCódigo\n# Módulo (resto da divisão inteira)\nprint(15 % 4)   # 15 dividido por 4 é 3, com resto 3\n\n\n3\n\n\nCódigo\n# Exponenciação (potência)\nprint(3 ** 4)   # 3 elevado à 4ª potência\n\n\n81\n\n\n\nAssim como na matemática, tentar dividir por zero em Python gera um erro:\n10 / 0\nErro Gerado: ZeroDivisionError: division by zero\n\nCalculando Raiz Quadrada:\nPodemos usar exponenciação com expoente fracionário:\n\n\nCódigo\nprint(81 ** 0.5) # Raiz quadrada de 81\n\n\n9.0\n\n\nNo entanto, a forma mais comum e recomendada é usar a função sqrt() da biblioteca (módulo) math:\n\n\nCódigo\nimport math # Importa a biblioteca math\n\nprint(math.sqrt(81))\n\n\n9.0\n\n\n\n\n\n\n\n\nImportando Módulos\n\n\n\nO comando import math torna todas as funções e constantes definidas no módulo math disponíveis para uso no seu código. Veremos mais sobre módulos e bibliotecas posteriormente.\n\n\n\n\nExpressões Numéricas e Precedência\nPodemos combinar múltiplos operadores em uma única expressão:\n\n\nCódigo\n3 + 4 * 2 - 5 / 2 ** 2\n\n\n9.75\n\n\nQual a ordem de execução? Python segue a ordem de precedência padrão da matemática, conhecida como PEMDAS:\n\nParênteses () - Operações dentro de parênteses são executadas primeiro.\nExponenciação **\nMultiplicação *, Divisão /, Divisão Inteira //, Módulo % (executados da esquerda para a direita se tiverem a mesma precedência).\nAdição +, Subtração - (executados da esquerda para a direita se tiverem a mesma precedência).\n\nNo exemplo 3 + 4 * 2 - 5 / 2 ** 2:\n\n2 ** 2 é 4\n4 * 2 é 8\n5 / 4 é 1.25\n3 + 8 é 11\n11 - 1.25 é 9.75\n\nUse parênteses para controlar a ordem quando necessário:\n\n\nCódigo\n(3 + 4) * (2 - 5) / (2 ** 2)\n\n\n-5.25\n\n\nCódigo\n# (7) * (-3) / (4) = -21 / 4 = -5.25\n\n\n\nUma Nota Sobre Números Decimais (Ponto Flutuante)\nVocê pode notar resultados ligeiramente inesperados ao trabalhar com números decimais (chamados floats em Python):\n\n\nCódigo\nprint(0.1 + 0.2)\n\n\n0.30000000000000004\n\n\nPor que 0.30000000000000004 e não 0.3? A maioria dos computadores utiliza a representação binária (base 2) para armazenar números. O problema é que muitas frações decimais (base 10), como 0.1, não podem ser representadas exatamente em binário. Isso ocorre porque a representação binária tem um número finito de dígitos, assim como ocorre na representação decimal. Por exemplo, ao representar 1/3 em decimal, obtém-se uma repetição infinita: 0.3333 \\ldots Da mesma forma, a conversão de 0.1 para binário gera uma fração periódica infinita.\nOs computadores modernos seguem o padrão IEEE 754 para representar números de ponto flutuante. Esse padrão define como os números são armazenados na memória, incluindo a precisão. Em Python, os números de ponto flutuante geralmente utilizam precisão dupla do IEEE 754, que oferece 53 bits de precisão. Quando um número como 0.1 é digitado, o computador encontra a fração binária mais próxima possível dentro desse limite de precisão. O resultado é um valor muito próximo de 0.1, mas não exatamente igual.\n\n\n\n\n\n\nLidando com Imprecisões de Float\n\n\n\nPara a maioria das aplicações em análise de dados, essa pequena imprecisão não é um problema. Ao exibir resultados, você pode arredondar os números usando a função round():\n\n\nCódigo\nprint(round(0.1 + 0.2, 2)) # Arredonda para 2 casas decimais\n\n\n0.3\n\n\nPara cálculos financeiros ou científicos que exigem alta precisão, Python oferece módulos como Decimal.\n\n\n\n\n\nComparações e Operadores Lógicos\nFrequentemente, precisamos comparar valores em nossos programas. Python oferece operadores de comparação que retornam um valor booleano: True (Verdadeiro) ou False (Falso).\n\n\n\n\nTabela 2: Operadores de Comparação.\n\n\n\n\n\n\nOperador\nDescrição\nExemplo\nResultado\n\n\n\n\n&lt;\nMenor que\n5 &lt; 10\nTrue\n\n\n&gt;\nMaior que\n5 &gt; 10\nFalse\n\n\n&lt;=\nMenor ou igual a\n10 &lt;= 10\nTrue\n\n\n&gt;=\nMaior ou igual a\n10 &gt;= 10\nTrue\n\n\n==\nIgual a\n5 == 5\nTrue\n\n\n!=\nDiferente de\n5 != 10\nTrue\n\n\n\n\n\n\n\n\nExemplos:\n\n\nCódigo\n# Idade Mínima igual a 18\n# Idade do Usuário igual a 25\n\nprint(\"Usuário é maior de idade?\", 25 &gt;= 18)\n\n\nUsuário é maior de idade? True\n\n\nCódigo\nprint(\"As idades são iguais?\", 25 &gt;= 18)\n\n\nAs idades são iguais? True\n\n\nCódigo\nprint(\"As idades são diferentes?\", 25 &gt;= 18)\n\n\nAs idades são diferentes? True\n\n\nOperadores Lógicos:\nPodemos combinar múltiplas comparações usando operadores lógicos:\n\n\n\n\nTabela 3: Operadores Lógicos.\n\n\n\n\n\n\n\n\n\n\n\n\nOperador\nResultado é True se\nExemplo\nResultado\n\n\n\n\nand\nAmbas as condições forem True\n(5 &lt; 10) and (10 &gt; 3)\nTrue\n\n\nor\nPelo menos uma das condições for True\n(5 &gt; 10) or (10 == 10)\nTrue\n\n\nnot\nA condição seguinte for False (inverte o valor lógico)\nnot (5 == 10)\nTrue\n\n\n\n\n\n\n\n\nExemplos:\n\n\nCódigo\n# Tem Ingresso igual a True\n# É maior de idade igual a False\n\n# Pode entrar na festa? (Precisa ter ingresso E ser maior de idade)\nprint(\"Pode entrar na festa?\", True and False)\n\n\nPode entrar na festa? False\n\n\nCódigo\n# Pode receber desconto? (Precisa ter ingresso OU ser maior de idade - exemplo hipotético)\nprint(\"Pode receber desconto?\", True or False)\n\n\nPode receber desconto? True\n\n\nCódigo\n# Não tem ingresso?\nprint(\"Não tem ingresso?\", not True)\n\n\nNão tem ingresso? False\n\n\n\n\nCódigo\nprint((1 and 4) &lt; 3)\n\n\nFalse\n\n\nCódigo\nprint((1 or 4) &lt; 3)\n\n\nTrue\n\n\nCódigo\nprint((1 and 2 and 2.99) &lt; 3)\n\n\nTrue\n\n\nCódigo\nprint((1 or 2 or 2.99) &gt; 3)\n\n\nFalse\n\n\n\n\nCódigo\nprint((5 &gt;= 4.99) and (10 &lt;= 10.01))\n\n\nTrue\n\n\nCódigo\nprint((5 &gt;= 4.99) and (10 == 10.01))\n\n\nFalse\n\n\n\n\nCódigo\nprint((5 &gt;= 4.99) or (10 &lt;= 10.01))\n\n\nTrue\n\n\nCódigo\nprint((5 &gt;= 4.99) or (10 == 10.01))\n\n\nTrue\n\n\n\n\nCódigo\nprint(1 == 1)\n\n\nTrue\n\n\nCódigo\nprint(not 1 == 1)\n\n\nFalse\n\n\nCódigo\nprint(not not 1 == 1)\n\n\nTrue\n\n\nCódigo\nprint(not not not 1 == 1)\n\n\nFalse\n\n\nPrecedência dos Operadores Lógicos:\nAssim como os operadores matemáticos, os lógicos também têm uma ordem de avaliação:\n\nnot é avaliado primeiro.\nand é avaliado em seguida.\nor é avaliado por último.\n\nExemplo:\n\n\nCódigo\nprint(not False and True or False)\n\n\nTrue\n\n\nCódigo\n# 1. not False -&gt; True\n# 2. True and True -&gt; True\n# 3. True or False -&gt; True\n\n\nUse parênteses () para garantir a ordem desejada quando a expressão for complexa.\n\n\nVariáveis: Armazenando Informações\nUma variável funciona como um rótulo ou um nome que damos a um local na memória do computador onde um valor (um objeto) está armazenado. Isso nos permite referenciar e reutilizar valores facilmente.\nO processo de criar uma variável e associar um valor a ela é chamado de atribuição, e usamos o sinal de igual (=) para isso.\n\n\nCódigo\n# Atribuição\nquantidade_alunos = 19\npreco_produto = 34.99\nmensagem_boas_vindas = \"Olá, estudante!\"\ncurso_ativo = True\n\n# Usando as variáveis\nprint(quantidade_alunos)\n\n\n19\n\n\nCódigo\nprint(mensagem_boas_vindas)\n\n\nOlá, estudante!\n\n\n\nRegras e Convenções para Nomes de Variáveis\nEscolher nomes significativos torna o código muito mais fácil de entender.\n\nRegras (Obrigatórias):\n\nNomes devem começar com uma letra (a-z, A-Z) ou underscore (_).\nO restante do nome pode conter letras, números (0-9) e underscores.\nNomes são case-sensitive (idade é diferente de Idade).\nNão podem ser iguais a palavras-chave reservadas do Python (como if, else, for, while, def, class, import, True, False, None, etc.).\n\nConvenções (Boas Práticas - PEP 8):\n\nUse nomes em minúsculas.\nSepare palavras com underscores (estilo snake_case). Ex: taxa_juros, nome_cliente.\nEscolha nomes descritivos que indiquem o propósito da variável.\n\nExemplos Válidos: idade, nome_completo, total_vendas, _variavel_privada (convenção)\nExemplos Inválidos:\n# Errado: começa com número\n1_lugar = \"Ouro\"\n\n# Errado: contém caractere especial (@)\nemail@cliente = \"teste@exemplo.com\"\n\n# Errado: usa palavra-chave (def)\ndef = \"definição\"\nTentar usar um nome inválido ou uma palavra-chave resultará em SyntaxError. Tentar usar uma variável que não foi definida (atribuída) ainda resultará em NameError.\n\n\n\nAtribuição com Expressões e Atualização\nPodemos atribuir o resultado de uma expressão a uma variável:\n\n\nCódigo\npreco_unitario = 50\nquantidade = 5\ndesconto = 0.10\n\nvalor_bruto = preco_unitario * quantidade\nvalor_desconto = valor_bruto * desconto\nvalor_final = valor_bruto - valor_desconto\n\nprint(\"Valor final:\", valor_final)\n\n\nValor final: 225.0\n\n\nPara atualizar o valor de uma variável existente, podemos usar a própria variável na expressão à direita do =:\n\n\nCódigo\ncontador = 0\nprint(\"Contador inicial:\", contador)\n\n\nContador inicial: 0\n\n\nCódigo\ncontador = contador + 1 # Incrementa o valor\nprint(\"Contador após incremento:\", contador)\n\n\nContador após incremento: 1\n\n\nPython oferece operadores de atribuição compostos como atalhos:\n\n+= (Adição): x += 1 é o mesmo que x = x + 1\n-= (Subtração): x -= 5 é o mesmo que x = x - 5\n*= (Multiplicação): x *= 2 é o mesmo que x = x * 2\n/= (Divisão): x /= 4 é o mesmo que x = x / 4\n//= , %= , **= (análogos para divisão inteira, módulo e exponenciação)\n\n\n\nCódigo\nnum = 10\nnum += 3  # num agora é 13\nprint(num)\n\n\n13\n\n\nCódigo\nnum *= 2  # num agora é 26\nprint(num)\n\n\n26\n\n\n\n\nAtribuição Múltipla\nPython permite atribuir valores a múltiplas variáveis na mesma linha:\n\n\nCódigo\nx, y, z = 10, 20, \"teste\"\nprint(x)\n\n\n10\n\n\nCódigo\nprint(y)\n\n\n20\n\n\nCódigo\nprint(z)\n\n\nteste\n\n\nNão parece algo tão interessante, não é? Vamos a um exemplo. Imagine um problema que envolve duas variáveis a e b. O Python permite a atribuição múltipla, o que pode ser útil para trocar valores entre variáveis de forma eficiente.\n\n\nCódigo\na, b = 1, 200\nprint(a, b)  # Saída: 1 200\n\n\n1 200\n\n\nAgora, pense como poderiamos trocar os valores dessas variáveis. Pensou? Em algum momento deve ter passado pela sua cabeça a seguinte lógica:\n\n\nCódigo\na = b # Perde-se o valor original de a (1)\nprint(a)\n\n\n200\n\n\nCódigo\nb = a # Como perdeu-se a, `b vai continuar com seu valor original (200)\nprint(b)\n\n\n200\n\n\nEm outras linguagens, para trocar valores entre duas variáveis, seria necessário usar uma variável auxiliar:\n\n\nCódigo\na, b = 1, 200\nprint(a, b)  # Saída: 1 200\n\n\n1 200\n\n\nCódigo\naux = a\na = b\nb = aux\nprint(a, b)  # Agora a = 200 e b = 1\n\n\n200 1\n\n\nNo entanto, em Python, a troca pode ser feita de forma mais elegante usando atribuição múltipla:\n\n\nCódigo\na, b = 1, 200\nprint(a, b)  # Saída: 1 200\n\n\n1 200\n\n\nCódigo\na, b = b, a\nprint(a, b)  # Agora a = 200 e b = 1\n\n\n200 1\n\n\nNote que essa abordagem pode ser expandida para múltiplas variáveis.\n\n\n\nTipos de Objetos Fundamentais\nJá vimos alguns tipos de dados (valores) que podemos armazenar em variáveis. Cada valor em Python é um objeto, e cada objeto pertence a um tipo (ou classe). O tipo define quais operações podem ser realizadas com aquele objeto.\nPodemos verificar o tipo de um objeto usando a função type():\n\n\nCódigo\nnumero_inteiro = 100\nnumero_decimal = 3.14159\ntexto = \"Análise de Dados\"\nlogico = False\n\nprint(type(numero_inteiro))\n\n\n&lt;class 'int'&gt;\n\n\nCódigo\nprint(type(numero_decimal))\n\n\n&lt;class 'float'&gt;\n\n\nCódigo\nprint(type(texto))\n\n\n&lt;class 'str'&gt;\n\n\nCódigo\nprint(type(logico))\n\n\n&lt;class 'bool'&gt;\n\n\nPrincipais Tipos Primitivos:\n\nint (Inteiro): Números inteiros, positivos ou negativos, sem parte decimal (ex: -10, 0, 42).\nfloat (Ponto Flutuante): Números reais, que possuem uma parte decimal (ex: -3.14, 0.0, 99.99).\nstr (String): Sequências de caracteres (texto), delimitadas por aspas simples ou duplas (ex: 'Python', \"Olá, mundo!\").\nbool (Booleano): Representa valores lógicos de Verdadeiro (True) ou Falso (False).\nNoneType (None): Um tipo especial que tem apenas um valor: None. Usado para representar a ausência de valor.\n\nAlém desses, Python possui tipos de dados mais complexos para agrupar informações, que veremos em detalhes mais adiante:\n\nlist (Lista): Coleção ordenada e mutável de itens.\ntuple (Tupla): Coleção ordenada e imutável de itens.\ndict (Dicionário): Coleção não ordenada de pares chave-valor.\nset (Conjunto): Coleção não ordenada de itens únicos.\n\n\n\nMétodos e Atributos\nEm Python, os conceitos de métodos e atributos são fundamentais na programação orientada a objetos (POO). Eles definem as características e comportamentos dos objetos.\n\nMétodos\n\nDefinição:\n\nMétodos são funções definidas dentro de um objeto. Eles definem os comportamentos ou ações que um objeto pode realizar.\nPense neles como as “ações” que um objeto pode executar.\n\nExemplo:\n\nEm um objeto carro, métodos poderiam ser ligar(), acelerar() e frear().\n\nAcesso:\n\nChamamos métodos usando a sintaxe objeto.método().\n\n\n\n\nAtributos\n\nDefinição:\n\nAtributos são variáveis que armazenam dados dentro de um objeto. Eles representam as características ou propriedades de um objeto.\nPense neles como as “informações” (sobre o objeto por isso características) que um objeto carrega consigo.\n\nExemplo:\n\nEm um objeto carro, atributos poderiam ser cor, marca, modelo e ano.\n\nAcesso:\n\nAcessamos atributos usando a sintaxe objeto.atributo.\n\n\n\n\nRelação entre Métodos e Atributos\nMétodos frequentemente manipulam os atributos de um objeto. Por exemplo, um método acelerar() pode modificar o atributo velocidade de um objeto carro.\nEm resumo:\n\nAtributos são as características que um objeto possui.\nMétodos são as ações que um objeto pode realizar.\n\nEssa distinção permite criar objetos que representam entidades do mundo real com suas próprias características e comportamentos.\n\n\n\nObtendo Ajuda e Explorando\nPython oferece ferramentas para ajudar você a aprender e explorar:\n\nhelp(): Fornece documentação sobre funções, módulos ou tipos.\n# help(print) # Descomente para ver a ajuda da função print\n# help(str)   # Descomente para ver a ajuda sobre o tipo string\n# help(math)  # Descomente para ver a ajuda sobre o módulo math (precisa importar antes)\ndir(): Lista os nomes (atributos e métodos) definidos por um objeto ou módulo.\n# print(dir(str)) # Lista métodos e atributos de strings\n# print(dir(math)) # Lista funções e constantes do módulo math\ntype(): Como já vimos, retorna o tipo de um objeto.\n\nNo ambiente Jupyter Notebook, você também pode usar:\n\n? após um nome de função/objeto para ver sua documentação (ex: print? ou frase.upper?).\n?? após um nome de função/objeto para tentar ver o código fonte (se disponível).\nCompletar com Tab: Digite o início de um nome de variável ou método e pressione Tab para ver sugestões.\n\n\nEste capítulo cobriu os fundamentos essenciais para começar a programar em Python. Nos próximos capítulos, construiremos sobre essa base para explorar estruturas de dados mais complexas e as ferramentas específicas para análise de dados.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "Módulo I/02_Data_Structure.html",
    "href": "Módulo I/02_Data_Structure.html",
    "title": "Objetos no Python",
    "section": "",
    "text": "Introdução\nAo longo do curso, já mencionamos alguns tipos de objetos enquanto explorávamos conceitos básicos de Python. Você provavelmente já viu variáveis sendo criadas e usadas, e até notou que diferentes valores podem ter diferentes tipos. Agora, chegou o momento de entender melhor os objetos básicos do Python e como eles funcionam.\nNeste capítulo, vamos explorar os principais tipos de objetos que o Python nos oferece, como números, strings, listas e dicionários. Além disso, veremos como identificar o tipo de um objeto, buscar ajuda sobre funções e entender melhor as variáveis disponíveis no código.\nCom essa nova organização do curso, o conteúdo foi dividido em capítulos menores para facilitar o aprendizado. Isso evita que tudo seja ensinado de uma vez, tornando a experiência mais dinâmica e leve. Então, vamos começar nossa jornada pelos objetos do Python! 🚀",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/02_Data_Structure.html#strings",
    "href": "Módulo I/02_Data_Structure.html#strings",
    "title": "Objetos no Python",
    "section": "Strings",
    "text": "Strings\nTambém chamada de sequência de caracteres, textos ou dados alfanuméricos, uma string é um tipo de dado que armazena uma sequência de caracteres. Em Python, pode ser definida com aspas simples ('), duplas (\") ou triplas (''' ou \"\"\").\n\n\nCódigo\n\"Texto com acentos e cedilhas: hoje é dia de caça!\"\n\n\n'Texto com acentos e cedilhas: hoje é dia de caça!'\n\n\n\n\nCódigo\n# As strings aceitam aspas simples também\nnome = 'Silvio Santos'\nnome\n\n\n'Silvio Santos'\n\n\n\nOperações com Strings\nPodemos realizar diversas operações matemáticas e manipulações em strings.\n\n\nCódigo\n# Multiplicação repete a string\nnome * 3\n\n\n'Silvio SantosSilvio SantosSilvio Santos'\n\n\n[Input]:  nome * 3.14\n[Output]: TypeError: can't multiply sequence by non-int of type 'float'\n\n\nCódigo\n# Concatenação de strings\ncanto1 = 'vem aí, '\ncanto2 = 'lá '\nnome + ' ' + canto1 + canto2 * 6 + '!!'\n\n\n'Silvio Santos vem aí, lá lá lá lá lá lá !!'\n\n\n\n\nStrings Multilinhas\nPara definir strings que ocupam múltiplas linhas, utilize três aspas (''' ou \"\"\"):\n\n\nCódigo\nstr_grande = '''Aqui consigo inserir um textão com várias linhas.\nPosso iniciar em uma...\n... continuar em outra...\n... e seguir quantas precisar.'''\n\nstr_grande\n\n\n'Aqui consigo inserir um textão com várias linhas.\\nPosso iniciar em uma...\\n... continuar em outra...\\n... e seguir quantas precisar.'\n\n\n\n\nCódigo\nprint(str_grande)\n\n\nAqui consigo inserir um textão com várias linhas.\nPosso iniciar em uma...\n... continuar em outra...\n... e seguir quantas precisar.\n\n\nCaso seja necessário incluir aspas dentro da string, podemos alternar entre aspas simples e duplas:\n\n\nCódigo\nagua = \"Me dá um copo d'água\"\nagua\n\n\n\"Me dá um copo d'água\"\n\n\nTambém podemos usar todas as aspas ao mesmo tempo:\n\n\nCódigo\ntodas_as_aspas = \"\"\"Essa é uma string que tem:\n- aspas 'simples'\n- aspas \"duplas\"\n- aspas '''triplas'''\nLegal, né?\"\"\"\n                    \nprint(todas_as_aspas)\n\n\nEssa é uma string que tem:\n- aspas 'simples'\n- aspas \"duplas\"\n- aspas '''triplas'''\nLegal, né?\n\n\n\n\nTamanho de uma String\nA função embutida len() nos permite obter o número de caracteres de uma string, incluindo espaços e pontuação:\n\n\nCódigo\nlen('Abracadabra')\n\n\n11\n\n\n\n\nCódigo\nfrase = 'Faz um pull request lá'\nlen(frase)\n\n\n22\n\n\n\n\nCódigo\npalavra = \"Python\"\nlen(palavra)\n\n\n6\n\n\n\n\nManipulação de Strings\n\nIndexação\nCada caractere em uma string possui um índice, começando em 0 para o primeiro elemento e indo até len(string) - 1 para o último elemento ou -1.\n\nÍndices negativos percorrem de trás para frente\n\nPara um melhor entendimento inicial, considere a variável criada na subseção anterir:palavra. Partindo da definição acima, podemos afirmar que os índices da variável palavra segue o formato:\n\n\n\nP\ny\nt\nh\no\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n-6\n-5\n-4\n-3\n-2\n-1\n\n\n\nVejamos alguns exemplos:\n\n\nCódigo\n# Primeiro caractere\nprint(palavra[0])\n\n\nP\n\n\nCódigo\nprint(palavra[-6])\n\n\nP\n\n\n\n\nCódigo\n# Primeiro caractere\nprint(palavra[5])\n\n\nn\n\n\nCódigo\nprint(palavra[-1])\n\n\nn\n\n\n\n\nFatiamento\nFatiamento (slincing) é a capacidade de extrair partes de uma string utilizando inicio:fim - 1:passo.\n\n\nCódigo\n# Guardando um objeto do tipo str na variável frase\nfrase = \"A programação em \" + palavra + \" é diferenciada!\"\nfrase\n\n\n'A programação em Python é diferenciada!'\n\n\n\n\nCódigo\n# Comprimento da variável frase\nnStr = len(frase)\nnStr\n\n\n39\n\n\n\n\nCódigo\n# Obtendo a frase completa usando fatiamento\nprint(frase[:nStr - 1])\n\n\nA programação em Python é diferenciada\n\n\nCódigo\nprint(frase[-nStr:])\n\n\nA programação em Python é diferenciada!\n\n\n\n\nCódigo\n# Obtendo a frase de dois em dois caractere\nprint(frase[:nStr - 1:2])\n\n\nApormçoe yhnédfrnid\n\n\nCódigo\nprint(frase[-nStr::2])\n\n\nApormçoe yhnédfrnid!\n\n\n\n\nCódigo\n# Obtendo apenas 'A programação'\nprint(frase[:14])\n\n\nA programação \n\n\nCódigo\nprint(frase[:-25])\n\n\nA programação \n\n\n\n\nCódigo\n# Obtendo o que há depois de 'A programação'\nprint(frase[14:])\n\n\nem Python é diferenciada!\n\n\nCódigo\nprint(frase[-25:])\n\n\nem Python é diferenciada!\n\n\n\n\nCódigo\n# Obtendo toda a frase de trás para frente\nprint(frase[::-1])\n\n\n!adaicnerefid é nohtyP me oãçamargorp A\n\n\n\nNota: Omitir o primeiro índice (start) ou o segundo índice (stop) significa, respectivamente, começar desde o começo ou terminar no fim.\n\nResumindo: para fazer uma fatia de nossa string, precisamos saber de onde começa, até onde vai e o tamanho do passo.\nfatiável[começo : fim : passo]\n\nAtenção para o uso de indexação e fatiamento\nAs fatias incluem o índice do primeiro elemento e não incluem o elemento do índice final. Por isso que frase[0:-1] perde o último elemento.\nCaso o fim da fatia seja antes do começo, obtemos um resultado vazio:\n\n\nCódigo\nfrase[59:105]\n\n\n''\n\n\nO que acontece com uma fatia que está fora da string?\n\n\nCódigo\nfrase[123:345]\n\n\n''\n\n\nE se o fim da fatia for superior ao comprimento da string? Sem problemas, o Python pecorrer a string até o onde der:\n\n\nCódigo\nfrase[8:123456789]\n\n\n'mação em Python é diferenciada!'\n\n\nMas um índice fora do intervalo em acesso direto gera erro:\n[Input]  : frase[123456789]\n[Output] : IndexError: string index out of range\nQuando usamos passos negativos, a fatia começa no fim e termina no começo e é percorrida ao contrário. Ou seja, invertemos a ordem. Mas tome cuidado:\n\n\nCódigo\n\"Python\"[2:6]\n\n\n'thon'\n\n\n\n\nCódigo\n\"Python\"[2:6:-1]\n\n\n''\n\n\n\n\nCódigo\n\"Python\"[6:2]\n\n\n''\n\n\n\n\nCódigo\n\"Python\"[6:2:-1]\n\n\n'noh'\n\n\n\n\"Python\"[6:2]: O índice de início (6) é maior que o índice de fim (2), e o passo é positivo (default). Nesse caso, o resultado é uma string vazia, pois o slicing avança para a direita, mas o fim está à esquerda.\n\"Python\"[2:6:-1]: O índice de início (2) é menor que o índice de fim (6), mas o passo é negativo (-1). O slicing tenta avançar para a esquerda, mas o fim está à direita. Novamente, o resultado é uma string vazia.\n\"Python\"[6:2:-1]: O índice de início (6) é maior que o índice de fim (2), e o passo é negativo (-1). O slicing avança para a esquerda, começando do índice 6 (‘n’) até o índice 2 (‘t’), excluindo-o. Isso resulta na string “noh”.\n\n\n\n\n\nFormatação de Strings\nPodemos formatar strings utilizando f-strings, .format() ou %:\n\n\nCódigo\nnome = \"Breno\"\nidade = 21\n\nprint(f\"Olá, meu nome é {nome} e tenho {idade} anos.\")           # f-strings\n\n\nOlá, meu nome é Breno e tenho 21 anos.\n\n\nCódigo\nprint(\"Olá, meu nome é {} e tenho {} anos.\".format(nome, idade)) # format()\n\n\nOlá, meu nome é Breno e tenho 21 anos.\n\n\nCódigo\nprint(\"Olá, meu nome é %s e tenho %d anos.\" % (nome, idade))     # Estilo antigo\n\n\nOlá, meu nome é Breno e tenho 21 anos.\n\n\nO autor recomenda usar a primeira opção.\n\n\nMétodos Úteis para Strings\nAo definirmos o objeto string em Python, são definidas também algumas ações que este objeto pode executar.\n\n\nCódigo\n# Defini-se um string qualquer\nfrase = \" Python é legal! \"\n\n# Visualizar variável\nfrase\n\n\n' Python é legal! '\n\n\n\nMétodo str.lower(): Deixa qualquer caractere em minúsculo.\n\n\n\nCódigo\nfrase.lower()\n\n\n' python é legal! '\n\n\n\nMétodo str.upper(): Deixa qualquer caractere em maiúsculo.\n\n\n\nCódigo\nfrase.upper()\n\n\n' PYTHON É LEGAL! '\n\n\n\nMétodo str.strip(): Remove os espaços extras.\n\n\n\nCódigo\nfrase.strip()\n\n\n'Python é legal!'\n\n\n\nMétodo str.title(): Primeiro caractere de cada palavra em letra maiúscula.\n\n\n\nCódigo\nfrase.strip().title()\n\n\n'Python É Legal!'\n\n\n\nMétodo str.replace(): Troca um determinado caractere (1º argumento) por um outro determinado caractere (2º argumento).\n\n\n\nCódigo\nfrase.replace(\"Python\", \"Programar\")\n\n\n' Programar é legal! '\n\n\n\nMétodo str.index(): Retorna o índice de determinado caractere contido na string.\n\n\n\nCódigo\nfrase.index(\"é\")\n\n\n8\n\n\n\nMétodo str.count(): Quantifica o número de aparições de determinado caractere na string.\n\n\n\nCódigo\nfrase.count(\"a\")\n\n\n1\n\n\n\nMétodo str.split(): Cria uma lista a partir de fatias da string com base em um caractere.\n\n\n\nCódigo\n# Método split sem argumento (default)\nprint(frase.split())\n\n\n['Python', 'é', 'legal!']\n\n\nCódigo\n# Método split com argumento\nprint(frase.split(\"é\"))\n\n\n[' Python ', ' legal! ']",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/02_Data_Structure.html#listas",
    "href": "Módulo I/02_Data_Structure.html#listas",
    "title": "Objetos no Python",
    "section": "Listas",
    "text": "Listas\nListas são uma das estruturas de dados mais usadas em Python. Elas permitem armazenar múltiplos valores em uma única variável e suportam diversos tipos de operações.\n\nDeclaração de Listas\nUma lista em Python é definida utilizando colchetes [], e seus elementos são separados por vírgulas:\n\n\nCódigo\n# Lista de números\nnumeros = [1, 2, 3, 4, 5]\n\n# Lista de strings\nfrutas = [\"maça\", \"banana\", \"abacaxi\"]\n\n# Lista mista\ndados = [25, \"João\", True, 3.14]\n\n\nUma lista também pode ser vazia, algo que futaremente veremos que pode ser muito útil, por exemplo:\n\n\nCódigo\nvazia = []\nvazia\n\n\n[]\n\n\n\n\nIndexação e Fatiamento\nA ideia de índices e fatias de listas funciona de forma muito parecida com a que foi vista em strings.\n\n\nCódigo\nnumeros[0] # Primeiro elemento\n\n\n1\n\n\n\n\nCódigo\nnumeros[-1] # Último elemento\n\n\n5\n\n\nAssim como na indexação de strings, ao tentar acessar um índice inválido de uma lista é retornado um erro.\nAo ínves de simplesmente acessar um elemneto através de seu índice, podemos obter uma fatia, que pode ser muito mais interessante.\n\n\nCódigo\nnumeros[::2] # Do começo ao fim, de 2 em 2 elementos\n\n\n[1, 3, 5]\n\n\n\n\nCódigo\nnumeros[::-2] # Do fim ao começo, de 2 em 2 elementos\n\n\n[5, 3, 1]\n\n\n\n\nCódigo\nnumeros[:3]   # Três primeiros elementos\n\n\n[1, 2, 3]\n\n\n\n\nCódigo\nnumeros[3:]   # Elementos a partir do índice 3\n\n\n[4, 5]\n\n\n\n\nCódigo\nnumeros[::-1] # Lista invertida\n\n\n[5, 4, 3, 2, 1]\n\n\n\n\nTrabalhando com Listas\nImagine que se queira saber se um determinado elemento (objeto) está contido em determinada lista. Poderiamos ficar procurando elemento a elemento, vamos tentar essa abordagem. Verifique se o elemento 0.3146778807984779 está contido na lista abaixo:\n\n\nCódigo\nimport random as rd\n\nrd.seed(42)\n\nva = [rd.random() for _ in range(100)]\nva\n\n\n[0.6394267984578837, 0.025010755222666936, 0.27502931836911926, 0.22321073814882275, 0.7364712141640124, 0.6766994874229113, 0.8921795677048454, 0.08693883262941615, 0.4219218196852704, 0.029797219438070344, 0.21863797480360336, 0.5053552881033624, 0.026535969683863625, 0.1988376506866485, 0.6498844377795232, 0.5449414806032167, 0.2204406220406967, 0.5892656838759087, 0.8094304566778266, 0.006498759678061017, 0.8058192518328079, 0.6981393949882269, 0.3402505165179919, 0.15547949981178155, 0.9572130722067812, 0.33659454511262676, 0.09274584338014791, 0.09671637683346401, 0.8474943663474598, 0.6037260313668911, 0.8071282732743802, 0.7297317866938179, 0.5362280914547007, 0.9731157639793706, 0.3785343772083535, 0.552040631273227, 0.8294046642529949, 0.6185197523642461, 0.8617069003107772, 0.577352145256762, 0.7045718362149235, 0.045824383655662215, 0.22789827565154686, 0.28938796360210717, 0.0797919769236275, 0.23279088636103018, 0.10100142940972912, 0.2779736031100921, 0.6356844442644002, 0.36483217897008424, 0.37018096711688264, 0.2095070307714877, 0.26697782204911336, 0.936654587712494, 0.6480353852465935, 0.6091310056669882, 0.171138648198097, 0.7291267979503492, 0.1634024937619284, 0.3794554417576478, 0.9895233506365952, 0.6399997598540929, 0.5569497437746462, 0.6846142509898746, 0.8428519201898096, 0.7759999115462448, 0.22904807196410437, 0.03210024390403776, 0.3154530480590819, 0.26774087597570273, 0.21098284358632646, 0.9429097143350544, 0.8763676264726689, 0.3146778807984779, 0.65543866529488, 0.39563190106066426, 0.9145475897405435, 0.4588518525873988, 0.26488016649805246, 0.24662750769398345, 0.5613681341631508, 0.26274160852293527, 0.5845859902235405, 0.897822883602477, 0.39940050514039727, 0.21932075915728333, 0.9975376064951103, 0.5095262936764645, 0.09090941217379389, 0.04711637542473457, 0.10964913035065915, 0.62744604170309, 0.7920793643629641, 0.42215996679968404, 0.06352770615195713, 0.38161928650653676, 0.9961213802400968, 0.529114345099137, 0.9710783776136181, 0.8607797022344981]\n\n\nNote que não é viável essa abordagem. Para está finalidade devemos usar o operador lógico in. Veja o exemplo:\n\n\nCódigo\n0.3146778807984779 in va # 'elemento' está contido em 'lista'\n\n\nTrue\n\n\nLembra do operador not? Podemos combiná-lo com o in para verificar se um elemento ‘não está’ contido em uma determina lista. Sendo o contrário (negação) da afirmação acima.\n\n\nCódigo\n0.3146778807984779 not in va # 'elemento' não está contido em 'lista'\n\n\nFalse\n\n\nVeja um exemplo de como o in funciona em uma outra situação.\n\n\nCódigo\nlista_mista = ['duas palavras', 42, True, ['batman', 'robin'], -0.84, 'hipófise']\n42 in lista_mista\n\n\nTrue\n\n\n\n\nCódigo\n'batman' in lista_mista\n\n\nFalse\n\n\n\n\nCódigo\n'batman' in lista_mista[3] # Note que o elemento com índice 3 também é uma lista\n\n\nTrue\n\n\nConsegue me dizer quantos elementos têm na lista va? Fique tranquilo! Não precisa contar, pode ser usado a função len do Python para responder essa pergunta.\n\n\nCódigo\nlen(va)\n\n\n100\n\n\n\n\nCódigo\nlen(lista_mista[3])\n\n\n2\n\n\n\n\nAdicionar e Remover elementos de uma Lista\nPodemos adicionar elementos de diversas formas:\n\n\nCódigo\n# Adiciona um único elemento ao final da lista\nnumeros.append(6)\nnumeros\n\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nCódigo\n# Adiciona vários elementos ao final da lista\nnumeros.extend([7, 8, 9])\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nCódigo\n# Adiciona um elemento em uma posição específica\nnumeros.insert(2, 15)  # Insere o número 15 na posição 2 (3º elemento)\nnumeros\n\n\n[1, 2, 15, 3, 4, 5, 6, 7, 8, 9]\n\n\nPodemos remover/excluir elementos de uma lista das seguintes formas:\n\n\nCódigo\n# Remove a primeira ocorrência de um valor específico\nnumeros.remove(15)  # Remove o número 15\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nCódigo\n# Exclui o último elemento da lista\ndel numeros[-1]\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8]\n\n\nE se, por exemplo, eu precisar começar a lista do zero? Pode-se remover todos os elementos de uma lista, usando o método clear():\n\n\nCódigo\nva.clear()\nprint(\"Lista de números aleatórios:\")\n\n\nLista de números aleatórios:\n\n\nCódigo\nprint(va)\n\n\n[]\n\n\nCódigo\nva = [rd.random() for _ in range(100)]\nprint(\"Lista de números aleatórios:\")\n\n\nLista de números aleatórios:\n\n\nCódigo\nprint(va)\n\n\n[0.011481021942819636, 0.7207218193601946, 0.6817103690265748, 0.5369703304087952, 0.2668251899525428, 0.6409617985798081, 0.11155217359587644, 0.434765250669105, 0.45372370632920644, 0.9538159275210801, 0.8758529403781941, 0.26338905075109076, 0.5005861130502983, 0.17865188053013137, 0.9126278393448205, 0.8705185698367669, 0.2984447914486329, 0.6389494948660052, 0.6089702114381723, 0.1528392685496348, 0.7625108000751513, 0.5393790301196257, 0.7786264786305582, 0.5303536721951775, 0.0005718961279435053, 0.3241560570046731, 0.019476742385832302, 0.9290986162646171, 0.8787218778231842, 0.8316655293611794, 0.30751412540266143, 0.05792516649418755, 0.8780095992040405, 0.9469494452979941, 0.08565345206787878, 0.4859904633166138, 0.06921251846838361, 0.7606021652572316, 0.7658344293069878, 0.1283914644997628, 0.4752823780987313, 0.5498035934949439, 0.2650566289400591, 0.8724330410852574, 0.4231379402008869, 0.21179820544208205, 0.5392960887794583, 0.7299310690899762, 0.2011510633896959, 0.31171629130089495, 0.9951493566608947, 0.6498780576394535, 0.43810008391450406, 0.5175758410355906, 0.12100419586826572, 0.22469733703155736, 0.33808556214745533, 0.5883087184572333, 0.230114732596577, 0.22021738445155947, 0.07099308600903254, 0.6311029572700989, 0.22894178381115438, 0.905420013006128, 0.8596354002537465, 0.07085734988865344, 0.23800463436899522, 0.6689777782962806, 0.2142368073704386, 0.132311848725025, 0.935514240580671, 0.5710430933252845, 0.47267102631179414, 0.7846194242907534, 0.8074969977666434, 0.1904099143618777, 0.09693081422882333, 0.4310511824063775, 0.4235786230199208, 0.467024668036675, 0.7290758494598506, 0.6733645472933015, 0.9841652113659661, 0.09841787115195888, 0.4026212821022688, 0.33930260539496315, 0.8616725363527911, 0.24865633392028563, 0.1902089084408115, 0.4486135478331319, 0.4218816398344042, 0.27854514466694047, 0.2498064478821005, 0.9232655992760128, 0.44313074505345695, 0.8613491047618306, 0.5503253124498481, 0.05058832952488124, 0.9992824684127266, 0.8360275850799519]\n\n\n\n\nModificando elementos\nComo as listas são mutáveis, podemos alterar seus valores diretamente:\n\n\nCódigo\nprint(f\"Antes da modificação: \\n {frutas}\")\n\n\nAntes da modificação: \n ['maça', 'banana', 'abacaxi']\n\n\nCódigo\n# Alterando 'banana' por 'melancia'\nfrutas[1] = \"melancia\"\n\n# Visualizando\nprint(f\"Depois da modificação: \\n {frutas}\")\n\n\nDepois da modificação: \n ['maça', 'melancia', 'abacaxi']\n\n\nOutra forma de se fazer a modificação é:\n\n\nCódigo\n# Obtendo a posição (índice) da fruta (string) 'melancia'\nid = frutas.index(\"melancia\")\n\n# Alterando 'melancia' por 'banana'\nfrutas[id] = \"banana\"\n\n# Visualizando\nprint(frutas)\n\n\n['maça', 'banana', 'abacaxi']\n\n\n\n\nOrdenação de Listas\nPor vários motivos, pode ser útil ter em mãos uma lista ordenada. Como fazer isso? Veja os exemplos:\n\n\nCódigo\ndesordenada = ['b', 'z', 'k', 'a', 'h']\nprint(f\"Lista desordenada: \\n {desordenada}\")\n\n\nLista desordenada: \n ['b', 'z', 'k', 'a', 'h']\n\n\nCódigo\n# Ordenando\ndesordenada.sort()\nprint(f\"Lista ordenada: \\n {desordenada}\")\n\n\nLista ordenada: \n ['a', 'b', 'h', 'k', 'z']\n\n\nVoltemos a lista va:\n\n\nCódigo\n# Modificando va um pouco\nva_modified = [round(va[i] * 100) for i in range(len(va))]\nprint(va_modified)\n\n\n[1, 72, 68, 54, 27, 64, 11, 43, 45, 95, 88, 26, 50, 18, 91, 87, 30, 64, 61, 15, 76, 54, 78, 53, 0, 32, 2, 93, 88, 83, 31, 6, 88, 95, 9, 49, 7, 76, 77, 13, 48, 55, 27, 87, 42, 21, 54, 73, 20, 31, 100, 65, 44, 52, 12, 22, 34, 59, 23, 22, 7, 63, 23, 91, 86, 7, 24, 67, 21, 13, 94, 57, 47, 78, 81, 19, 10, 43, 42, 47, 73, 67, 98, 10, 40, 34, 86, 25, 19, 45, 42, 28, 25, 92, 44, 86, 55, 5, 100, 84]\n\n\nCódigo\n# Ordenado de forma crescente\nva_modified.sort()\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\nCódigo\n# Ordenado de forma decrescente\nva_modified.sort(reverse=True)\nprint(va_modified)\n\n\n[100, 100, 98, 95, 95, 94, 93, 92, 91, 91, 88, 88, 88, 87, 87, 86, 86, 86, 84, 83, 81, 78, 78, 77, 76, 76, 73, 73, 72, 68, 67, 67, 65, 64, 64, 63, 61, 59, 57, 55, 55, 54, 54, 54, 53, 52, 50, 49, 48, 47, 47, 45, 45, 44, 44, 43, 43, 42, 42, 42, 40, 34, 34, 32, 31, 31, 30, 28, 27, 27, 26, 25, 25, 24, 23, 23, 22, 22, 21, 21, 20, 19, 19, 18, 15, 13, 13, 12, 11, 10, 10, 9, 7, 7, 7, 6, 5, 2, 1, 0]\n\n\nAlém do método sort, tem a função nativa do Python. Função sorted():\n\n\nCódigo\n# Ordenado de forma crescente novamente\nva_modified = sorted(va_modified)\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\n\n\nCópia de Listas\nCópia ou cópias de listas se torna algo de grande valor quando se quer fazer alguma manipulação, porém não se quer alterar as informações originais. Para isso, deve-se usar o método copy():\n\n\nCódigo\n# Criando listas\nl1 = [[1, 2, 3], [\"x\", \"y\", \"z\"], [True, False]]\nl2 = l1.copy() # l2 é a cópia de l1\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\n# Adicioando um elemento novo somente a l2\nl2.append([1/4, 1/2, 3/4, 1])\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\nAgora, observe o que acontece se não fizer uso do copy():\n\n\nCódigo\n# Criando listas\nl1 = [[1, 2, 3], [\"x\", \"y\", \"z\"], [True, False]]\nl2 = l1 # l2 'igual' a l1\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\n# Adicioando um elemento novo somente a l2\nl2.append([1/4, 1/2, 3/4, 1])\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\n\n\nOperando Listas\nFazendo uso ao conhecimento adquirido de strings. Temos os operadores + e *, que funcionam de forma muito similar e obdecem as mesmas regras.\nO operador + concatena (semelhante ao método extend()) listas:\n\n\nCódigo\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nc\n\n\n[1, 2, 3, 4, 5, 6]\n\n\nO operador * repete a lista dado um número de vezes:\n\n\nCódigo\na * 2\n\n\n[1, 2, 3, 1, 2, 3]\n\n\n\n\nCódigo\nd = c + a + b + 2 * c\nd\n\n\n[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]\n\n\nO Python fornece várias outras operações úteis para listas, calculadas com funções do módulo básico do Python. Entretanto, tais funções só se aplicam a listas numéricas:\n\n\nCódigo\nprint(f\"Soma da lista 'd': {sum(d)}\")\n\n\nSoma da lista 'd': 84\n\n\nCódigo\nprint(f\"Maior valor da lista 'd': {max(d)}\")\n\n\nMaior valor da lista 'd': 6\n\n\nCódigo\nprint(f\"Menor valor da lista 'd': {min(d)}\")\n\n\nMenor valor da lista 'd': 1\n\n\nAgora, imagine que seja necessário saber quantas vezes um determinado elemento se repete dentro de uma lista. Tal ação pode ser feita pelo método count():\n\n\nCódigo\n# Lembra dessa lista\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\nCódigo\n# Quanta vezes o número 100 aparece?\nprint(va_modified.count(100))\n\n\n2\n\n\n\n\nUso da Função range() em Listas\nEm Python, além de funções como print(), len(), sum(), max() e min(), temos a função range(), que também faz parte do módulo básico. Essa função é extremamente útil para criar sequências numéricas, especialmente listas. Imagine que você precise criar uma lista com os números de 1 a 200. Como fazer isso de forma eficiente?\nUma abordagem seria escrever todos os números manualmente:\nlista_grande = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ..., 200]\nNo entanto, essa não é a forma mais prática. É aí que entra a função range(). Com ela, podemos gerar essa lista de forma muito mais simples:\n\n\nCódigo\nlist(range(1, 201))  # Note que o limite superior é 201\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]\n\n\nO range() também oferece flexibilidade para gerar sequências com intervalos específicos. Por exemplo, para obter os números de 0 a 29, pulando de 5 em 5:\n\n\nCódigo\nlist(range(0, 30, 5))\n\n\n[0, 5, 10, 15, 20, 25]\n\n\nAlém disso, o range() também oferece algumas coisas interessantes. Por exemplo, imprimir os números espaçados de 5 em 5, entre 0 e 30:\n\n\nCódigo\nlist(range(0, 30, 5))\n\n\n[0, 5, 10, 15, 20, 25]\n\n\nA sintaxe geral do range() é: range(start, stop, step), onde:\n\nstart: O valor inicial da sequência (inclusivo).\nstop: O valor final da sequência (exclusivo).\nstep: O intervalo entre os valores.\n\nPor que precisamos converter range() para list?\n\n\nCódigo\nprint(range(200))\n\n\nrange(0, 200)\n\n\nCódigo\nprint(type(range(200)))\n\n\n&lt;class 'range'&gt;\n\n\nIsso acontece porque range() retorna um objeto do tipo range, que representa uma sequência numérica, mas não é uma lista em si. Para visualizar os números, precisamos convertê-lo explicitamente para uma lista:\n\n\nCódigo\nrange_lista = list(range(200))\nprint(range_lista)\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/02_Data_Structure.html#dicionários",
    "href": "Módulo I/02_Data_Structure.html#dicionários",
    "title": "Objetos no Python",
    "section": "Dicionários",
    "text": "Dicionários\nDicionários em Python são estruturas de dados poderosas que armazenam informações no formato chave-valor. Diferentemente das listas, que são indexadas por números, os dicionários usam chaves imutáveis (strings, números, tuplas, etc.) para acessar seus valores.\nUm dicionário é uma coleção de pares chave-valor, onde cada chave é única e está associada a um valor: {chave: valor}.\n\nChaves Únicas: Uma característica fundamental dos dicionários é que cada chave deve ser única. Tentar inserir chaves duplicadas resultará na substituição do valor anterior.\n\n\nDeclaração de Dicionários\nEm Python, dicionários podem ser criados de diversas maneiras, oferecendo flexibilidade para diferentes situações.\n\nCriação Direta com Chaves e Valores:\n\n\n\nCódigo\n# Dicionário com informações de uma receita\nreceita = {\n    \"farinha\": \"2 xícaras\",\n    \"ovos\": 3,\n    \"leite condensado\": \"1 lata\"\n}\n\n# Dicionário com números de telefone\ntelefones = {\"ana\": 123456, \"yudi\": 40028922, \"julia\": 4124492}\n\n\nNeste exemplo, \"ana\" é uma chave que está associada ao valor 123456. Cada par chave-valor é separado por vírgula.\n\n\nCódigo\nprint(receita)\n\n\n{'farinha': '2 xícaras', 'ovos': 3, 'leite condensado': '1 lata'}\n\n\nCódigo\nprint(telefones)\n\n\n{'ana': 123456, 'yudi': 40028922, 'julia': 4124492}\n\n\n\nCriação de um Dicionário Vazio:\n\nVocê pode criar um dicionário vazio usando apenas chaves {}:\n\n\nCódigo\ncontatos = {}\ncontatos\n\n\n{}\n\n\n\nCriação com a Função dict():\n\nA função dict() permite criar dicionários de forma mais explícita, especialmente quando as chaves são strings simples:\n\n\nCódigo\npessoa = dict(nome=\"Carlos\", idade=30, cidade=\"São Paulo\")\npessoa\n\n\n{'nome': 'Carlos', 'idade': 30, 'cidade': 'São Paulo'}\n\n\n\nCom uma lista de listas:\n\n\n\nCódigo\n# Definindo três listas diferentes\nl1 = [\"brigadeiro\", \"leite condesado, achocolatado\"]\nl2 = [\"omelete\", \"ovos, azeite, condimentos a gosto\"]\nl3 = [\"ovo frito\", \"ovo, óleo, condimentos a gosto\"]\n\n# Criando uma lista de listas\nlr = [l1, l2, l3]\n\n# Visualizando resultado\nlr\n\n\n[['brigadeiro', 'leite condesado, achocolatado'], ['omelete', 'ovos, azeite, condimentos a gosto'], ['ovo frito', 'ovo, óleo, condimentos a gosto']]\n\n\n\n\nCódigo\n# Transformando lista de listas em um dicionário\nreceitas = dict(lr)\n\n# Visualizando o resultado\nreceitas\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, óleo, condimentos a gosto'}\n\n\n\n\nChaves\nPodemos acessar os valores de um dicionário através de suas chaves:\n\n\nCódigo\n# Definindo um dicionário para capitais de estados brasileiros\ncapitais = {\"SP\": \"São Paulo\", \"AC\": \"Rio Branco\", \"TO\": \"Palmas\",\n            \"RJ\": \"Rio de Janeiro\", \"SE\": \"Aracaju\", \"MG\": \"Belo Horizonte\"}\n\n# Acessando o valor correspondente a chave \"MG\"\ncapitais[\"MG\"]\n\n\n'Belo Horizonte'\n\n\nCaso a chave não exista, podemos evitar erros usando o método get():\n\n\nCódigo\ncapitais.get(\"PA\")\n\n\n\n\nCódigo\ncapitais.get(\"PA\", \"Não tem!\")\n\n\n'Não tem!'\n\n\nNote que o método get() funciona de forma similar ao código dicionário[chave], entretanto, caso a chave não exista garantimos que o código não gere erro diferente do que aconteceria caso fosse usado dicionário[chave].\nRepare, também, que a chave \"PA\" não foi adicionada ao dicionário.\n\n\nCódigo\ncapitais\n\n\n{'SP': 'São Paulo', 'AC': 'Rio Branco', 'TO': 'Palmas', 'RJ': 'Rio de Janeiro', 'SE': 'Aracaju', 'MG': 'Belo Horizonte'}\n\n\nAgora, se o objetivo não for saber o valor associado a determinada chave, mas sim saber se a chave existe, isso pode ser feito usando o método keys e o operador lógico in:\n\n\nCódigo\n# Chaves do Dicionário\nprint(capitais.keys())\n\n\ndict_keys(['SP', 'AC', 'TO', 'RJ', 'SE', 'MG'])\n\n\nCódigo\n# Verificando\nprint(f'A chave \"PA\" está no dicionário capitais? {\"PA\" in capitais.keys()}')\n\n\nA chave \"PA\" está no dicionário capitais? False\n\n\nNote que os valores de um dicionário pode ser qualquer tipo de objeto. No entanto, foi usado, até então, para exemplos, apenas strings. Porém, pode-se colocar todo tipo de coisa dentro dos dicionários, incluindo listas e até mesmo outros dicionários:\n\n\nCódigo\nnumeros = {\"primos\": [2, 3, 5], \"pares\": [0, 2, 4], \"ímpares\": [1, 3, 5]}\nprint(numeros)\n\n\n{'primos': [2, 3, 5], 'pares': [0, 2, 4], 'ímpares': [1, 3, 5]}\n\n\n\n\nCódigo\ndocente = {\n  \"Nome\": \"Prof Dr Vinícius Duarte Lima\", \n  \"Formação\": {\"Graduação\": \"Eng Elétrica\", \"Mestrado\": \"Eng Elétrica\", \"Doutorado\": \"Eng Elétrica\"},\n  \"Idade\": 45,\n}\n\nprint(docente)\n\n\n{'Nome': 'Prof Dr Vinícius Duarte Lima', 'Formação': {'Graduação': 'Eng Elétrica', 'Mestrado': 'Eng Elétrica', 'Doutorado': 'Eng Elétrica'}, 'Idade': 45}\n\n\nMesmo que os pares chave: valor estejam organizados na ordem que foram colocados, não podemos acessá-los por índices como faríamos em listas:\n[Input]  : numeros[2]\n[Output] : KeyError: 2\nAssim como os valores não precisam ser do tipo string, o mesmo vale para as chaves:\n\n\nCódigo\nnumeros_por_extenso = {2: \"dois\", 1: \"um\", 3: \"três\", 0: \"zero\"}\nnumeros_por_extenso[0]\n\n\n'zero'\n\n\n\n\nCódigo\nnumeros_por_extenso[2]\n\n\n'dois'\n\n\n\nNota: Listas e outros dicionários não podem ser usados como chaves por serem de tipos mutáveis.\n\n\n\nAdicionando, Alterando e Removendo Elementos\nPara exemplificar os comandos desta seção, considere o dicionário abaixo.\n\n\nCódigo\n# Informações de Cleiton\npessoa = {\"nome\": \"Cleiton\", \"idade\": 34, \"família\": {\"mãe\": \"Maria\", \"pai\": \"Enzo\"}}\n\n# Visualizando\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'família': {'mãe': 'Maria', 'pai': 'Enzo'}}\n\n\nPara adicionar o item \"masculino\" a chave \"genêro\" podemos usar os seguintes comandos:\n\n\nCódigo\n# Adicionando elemento\npessoa[\"genêro\"] = \"romântico\"\n\n# Visualizando\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'família': {'mãe': 'Maria', 'pai': 'Enzo'}, 'genêro': 'romântico'}\n\n\nDe forma equivalente, temos:\n\n\nCódigo\n# Dicionário de meses do ano\nmeses = {1: \"Janeiro\", 2: \"Fevereiro\", 3: \"Março\"}\n\n# Adicionando o mês de \"Abril\" na chave 4\nmeses[4] = \"Setembro\"\n\n# Visualizando\nmeses\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Março', 4: 'Setembro'}\n\n\nAs vezes, podem haver inconsistências nos dados, logo, se torna necessário corrigir tais inconsistências. Isso pode ser feito de forma muito simples, veja:\n\n\nCódigo\n# Executando alterações\npessoa[\"genêro\"] = \"masculino\"\nmeses[4] = \"Abril\"\n\n# Visualizando\nprint(pessoa)\n\n\n{'nome': 'Cleiton', 'idade': 34, 'família': {'mãe': 'Maria', 'pai': 'Enzo'}, 'genêro': 'masculino'}\n\n\nCódigo\nprint(meses)\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Março', 4: 'Abril'}\n\n\nUm dúvida que talvez possa surgir é como fazer alteração em listas que estão contidas em dicionários. Na verdade, isso é feito de forma bastante objetiva, veja:\n\n\nCódigo\n# Novo dicionário\nlixo = {\"plástico\": [\"garrafa\", \"copinho\", \"canudo\"], \n        \"papel\": [\"folha amassada\", \"guardanapo\"], \n        \"orgânico\": [\"batata\", \"resto do bandeco\", \"casca de banana\"]}\n\n# Visualizando\nprint(lixo)\n\n\n{'plástico': ['garrafa', 'copinho', 'canudo'], 'papel': ['folha amassada', 'guardanapo'], 'orgânico': ['batata', 'resto do bandeco', 'casca de banana']}\n\n\nCódigo\n# Obtendo lista de interesse para alteração\nlista_de_interesse = lixo[\"plástico\"]\n\n# Verificando em qual posição está o elemneto que deve ser alterado\nid = lista_de_interesse.index(\"garrafa\")\n\n# Fazendo a alteração diretamente no dicionário\nlixo['plástico'][id] = \"sacola\"\n\n# Visualizando dicionário alterado\nlixo\n\n\n{'plástico': ['sacola', 'copinho', 'canudo'], 'papel': ['folha amassada', 'guardanapo'], 'orgânico': ['batata', 'resto do bandeco', 'casca de banana']}\n\n\nNote que poderiamos ser mais direto, pois as listas em questão têm comprimentos pequenos. Porém, tal código já pode ser implementado para listas de grande comprimento.\nPorém, ao lidarmos com dicionários, talvez precisemos excluir algum elemento. Serão apresentadas duas formas de fazer isso.\n\nUsando o método pop():\n\n\n\nCódigo\npessoa.pop(\"família\")\n\n\n{'mãe': 'Maria', 'pai': 'Enzo'}\n\n\nRepare que dicionário.pop(chave) excluí o elemento e retorna os itens da chave excluída. Para visualizarmos o resultado basta chamar o dicionário.\n\n\nCódigo\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'genêro': 'masculino'}\n\n\n\nUsando o comando del do Python Básico:\n\n\n\nCódigo\ndel meses[4]\n\n\nDiferente do método pop(), o comando del não retorna nada. Porém, para visualizar o resultado, precisamos chamar o objeto.\n\n\nCódigo\nmeses\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Março'}\n\n\nPara excluir todos os elementos de um dicionário, temos o método clear():\n\n\nCódigo\n# Apagando todos os elementos do dicionário\nlixo.clear()\n\n# Visualizando\nlixo\n\n\n{}\n\n\n\n\nFunção list() e Função len() para Dicionários\nA função list() converte um dicionário em uma lista contendo apenas suas chaves:\n\n\nCódigo\ninstitutos_uspsc = {\n    \"IFSC\": \"Instituto de Física de São Carlos\",\n    \"ICMC\": \"Instituto de Ciências Matemáticas e de Computação\",\n    \"EESC\": \"Escola de Engenharia de São Carlos\",\n    \"IAU\": \"Instituto de Arquitetura e Urbanismo\",\n    \"IQSC\": \"Instituto de Química de São Carlos\"\n}\n\n# Convertendo dicionário em lista de chaves\nlista_chaves = list(institutos_uspsc)\nprint(lista_chaves)\n\n\n['IFSC', 'ICMC', 'EESC', 'IAU', 'IQSC']\n\n\nA função len() retorna o número de itens em um objeto. Para dicionários, ela conta o número de pares chave-valor:\n\n\nCódigo\n# Contando itens no dicionário\nquantidade_institutos = len(institutos_uspsc)\nprint(quantidade_institutos)\n\n\n5\n\n\nCódigo\n# Equivalente a contar as chaves convertidas em lista\nprint(len(list(institutos_uspsc)))\n\n\n5\n\n\n\n\nOutros comandos para dicionários\nVejamos agora os métodos items() e values(). Considere o seguinte dicionário:\n\n\nCódigo\npessoa = {\"nome\": \"Enzo\", \"RA\": 242334, \"curso\": \"fiscomp\"}\n\n\n\nitems() - Retorna uma visão dos pares chave-valor:\n\n\n\nCódigo\npares = pessoa.items()\nprint(list(pares))\n\n\n[('nome', 'Enzo'), ('RA', 242334), ('curso', 'fiscomp')]\n\n\n\nvalues() - Retorna uma visão dos valores armazenados:\n\n\n\nCódigo\nvalores = list(pessoa.values())\nprint(valores)\n\n\n['Enzo', 242334, 'fiscomp']\n\n\nObservação importante: A função list() aplicada diretamente a um dicionário (list(pessoa)) retorna apenas as chaves, equivalente a list(pessoa.keys()).\nDicionários em Python (versões 3.7+) mantêm a ordem de inserção, mas a igualdade entre dicionários considera apenas os pares chave-valor, não a ordem:\n\n\nCódigo\nnumerinhos = {\"um\": 1, \"dois\": 2, \"três\": 3}\nnumeritos = {\"três\": 3, \"dois\": 2, \"um\": 1}\n\nprint(numerinhos == numeritos)\n\n\nTrue\n\n\nCódigo\nprint(numerinhos)  # Mostra na ordem de inserção\n\n\n{'um': 1, 'dois': 2, 'três': 3}\n\n\nCódigo\nprint(numeritos)   # Mostra na ordem de inserção diferente\n\n\n{'três': 3, 'dois': 2, 'um': 1}\n\n\nOutro comando que pode ser usado para adicionar elementos em um dicionário pode ser o método update().\n\n\nCódigo\n# Lembra do dicionários receitas?\nprint(receitas)\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, óleo, condimentos a gosto'}\n\n\nCódigo\n# Nova receita\noutros_elementos = {\"mingau\": \"massa, leite, açúcar\"}\n\n# Adicionando a nova receita\nreceitas.update(outros_elementos)\n\n# Visualizando\nprint(receitas)\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, óleo, condimentos a gosto', 'mingau': 'massa, leite, açúcar'}\n\n\n\nResumão:\n\n\nOs métodos items() e values() (e keys()) retornam objetos de visualização que refletem automaticamente as alterações no dicionário original;\nA partir do Python 3.7, a ordem de inserção é preservada como característica da implementação, tornando-se parte da especificação na versão 3.8;\nUso do método update para integralização de dicionários.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/03_FlowControl_&_Functions.html",
    "href": "Módulo I/03_FlowControl_&_Functions.html",
    "title": "Controle de Fluxo & Funções em Python",
    "section": "",
    "text": "Introdução\nEm programação, o controle de fluxo determina a ordem em que as instruções são executadas em um programa. Em Python, isso permite criar programas que tomam decisões e repetem ações com base em condições específicas, tornando seu código mais dinâmico e adaptável.\nNesta seção, exploraremos as principais estruturas de controle de fluxo:\nPor que o controle de fluxo é importante? Imagine um programa que:\nSem controle de fluxo, nossos programas seriam lineares e limitados. Com ele, ganhamos flexibilidade e poder para resolver problemas complexos.\nDominar o controle de fluxo é essencial para qualquer pessoa que esteja aprendendo programação, pois ele está presente em praticamente todo código real. Vamos começar a explorar cada conceito com exemplos práticos e exercícios!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo & Funções em Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/03_FlowControl_&_Functions.html#introdução",
    "href": "Módulo I/03_FlowControl_&_Functions.html#introdução",
    "title": "Controle de Fluxo & Funções em Python",
    "section": "",
    "text": "Condicionais - if, elif e else: Permitem executar blocos de código diferentes dependendo se uma condição é verdadeira ou falsa.\nLaços - for e while: Permitem repetir um bloco de código várias vezes, seja por um número específico de vezes ou enquanto uma condição for verdadeira.\nTratamento de exceções - try, except e finally: Permitem lidar com erros e situações inesperadas sem interromper o programa.\nPalavras-chave - break e continue: Permitem controlar o fluxo de execução dentro de laços.\n\n\n\nDecide se um usuário tem acesso a um sistema (if).\nRepete uma ação até que um download seja concluído (while).\nPercorre uma lista de produtos para calcular descontos (for).\nPrevine erros se um arquivo não for encontrado (try/except).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo & Funções em Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/03_FlowControl_&_Functions.html#estruturas-de-decisão",
    "href": "Módulo I/03_FlowControl_&_Functions.html#estruturas-de-decisão",
    "title": "Controle de Fluxo & Funções em Python",
    "section": "Estruturas de Decisão",
    "text": "Estruturas de Decisão\nAs estruturas de decisão em Python são usadas para controlar o fluxo do programa, ou seja, para decidir qual bloco de código será executado dependendo de uma ou mais condições. Pense como um semáforo: dependendo da cor, uma ação diferente deve ser tomada — o mesmo acontece em um programa.\n\nExemplo do mundo real:\n\nSe estiver nublado:\n    Levarei guarda-chuva\nSenão:\n    Não levarei\n\nNota: Em Python, a indentação (recuo de quatro espaços ou um tab) é obrigatória para definir os blocos de código. Isso significa que o que estiver indentado será considerado parte da condição.\n\n\n\nEstrutura if Simples\nA estrutura mais básica do controle de fluxo é o if, que permite executar um bloco de código apenas se uma condição for verdadeira.\n\n\nCódigo\nidade = 20\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\n\n\nVocê é maior de idade.\n\n\n\nNeste exemplo, como idade é 20, que é maior que 18, a mensagem será exibida.\n\n\n\n\nEstrutura if/else\nSe quisermos executar um código para o caso em que a condição não é satisfeita, usamos o else.\n\n\nCódigo\nidade = 16\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\nelse:\n    print(\"Você é menor de idade.\")\n\n\nVocê é menor de idade.\n\n\n\n\n\nEstrutura if/elif/else\nPara avaliar múltiplas condições, usamos elif (“else if”).\n\n\nCódigo\nnota = 8\nif nota &gt;= 9:\n    conceito = \"A\"\nelif nota &gt;= 7:\n    conceito = \"B\"\nelif nota &gt;= 5:\n    conceito = \"C\"\nelse:\n    conceito = \"D\"\n\nprint(\"Conceito:\", conceito)\n\n\nConceito: B\n\n\n\n\n\nDiferença entre if/elif e múltiplos if independentes\nHá uma diferênça ao usar as condições if/elif e usar vários if de forma consecutivas. É importante entender como essa diferênça funciona para que o seu programa não atenda mais de uma condição quando na verdade “apenas uma” é a verdadeira. Vamos há um exemplo claro e objetivo.\n\n\nCódigo\nif 1 == 1:\n    print(\"Caiu no 1º if\")\nelif 1 &gt;= 1:\n    print(\"Caiu no elif\")\nelse:\n    print(\"Caiu no else\")\n\n\nCaiu no 1º if\n\n\nPerceba que duas condições em teste são verdadeiras. Porém, ao usarmos a estrutura if/elif, apenas o bloco com a primeira condição verdadeira é executado. No exemplo, apenas o blobo seguinte a condição if a == 1 foi executado.\nAgora, veja o exemplo adaptado a estrutura de if consecutivos:\n\n\nCódigo\nif 1 == 1:\n    print(\"Caiu no 1º if\")\n\n\nCaiu no 1º if\n\n\nCódigo\nif 1 &gt;= 1:\n    print(\"Caiu no 2º if\")\nelse:\n    print(\"Caiu no else\")\n\n\nCaiu no 2º if\n\n\nNo bloco de código acima não há uma regra pré definida pelo Python. Ambos os blocos if serão avaliados independentemente. Isso pode ser útil em algumas situações, mas exige atenção!\n\n\n\nOutros Exemplos de Condicionais\n\n1º Exemplo - Condicionais Aninhadas: Útil quando queremos verificar uma condição dada que outra já foi satisfeita. Ou seja, uma estrutura condicional pode estar dentro de outra.\n\n\n\nCódigo\n# Definindo uma variável numérica\nvalue = 2.35\n\n# 1ª condição (externa)\nif value &lt;= 1:\n  print(\"O valor é menor ou igual a 1\")\n  \n  # 1ª condição (interna) dada que 1ª condição (externa) foi satisfeita\n  if value &lt; 0.5:\n    print(\"E é menor que 0,5\")\n    \n  # 2ª condição (interna) dada que 1ª condição (externa) foi satisfeita\n  elif value == 0.5:\n    print(\"O valor é igual a 0,5\")\n    \n  # 3ª condição (interna) dada que 1ª condição (externa) foi satisfeita\n  else:\n    print(\"O valor é maior que 0,5\")\n    \n# 2ª condição\nelif value &lt;= 2:\n  print(\"O valor é menor ou igual a 2\")\n  \n  # 1ª condição (interna) dada que 2ª condição (externa) foi satisfeita\n  if value &lt; 1.5:\n    print(\"E é menor que 1,5\")\n    \n  # 2ª condição (interna) dada que 2ª condição (externa) foi satisfeita\n  elif value == 1.5:\n    print(\"O valor é igual a 1,5\")\n    \n  # 3ª condição (interna) dada que 2ª condição (externa) foi satisfeita\n  else:\n    print(\"O valor é maior que 1,5\")\n    \n# 3ª condição\nelse:\n  print(\"Sabe-se apenas que o valor é maior que 2\")\n  \n  # 1ª condição (interna) dada que 3ª condição (externa) foi satisfeita\n  if value &lt;= 2.5:\n    print(\"Podendo variar entre (2; 2,5]\")\n    \n  # 2ª condição (interna) dada que 3ª condição (externa) foi satisfeita\n  elif value &lt;= 3:\n    print(\"Podendo variar entre (2,5; 3]\")\n    \n  # 3ª condição (interna) dada que 3ª condição (externa) foi satisfeita\n  else:\n    print(\"O valor é maior que 3\")\n\n\nSabe-se apenas que o valor é maior que 2\nPodendo variar entre (2; 2,5]\n\n\n\n2º Exemplo - Classificação de Valores: Já pararam para pensar como o conceito é dado pelo sistema da Universidade Federal do Pará? A classificação ocorre da seguinte maneira:\n\n\n\nCódigo\nimport random as rd\n\nrd.seed(123456789)\nreview = [10 * rd.random() for _ in range(5)]\nmean = sum(review) / len(review)\nprint(f\"Média das Avaliações: {round(mean, 2)}\")\n\n\nMédia das Avaliações: 7.66\n\n\nCódigo\n# Em qual conceito está média estaria?\nif (mean &gt;= 0) and (mean &lt; 5):\n  print(\"O conceito do aluno foi INSUFICIENTE\")\nelif (mean &gt;= 5) and (mean &lt; 7):\n  print(\"O conceito do aluno foi REGULAR\")\nelif (mean &gt;= 7) and (mean &lt; 9):\n  print(\"O conceito do aluno foi BOM\")\nelif (mean &gt;= 9) and (mean &lt;= 10):\n  print(\"O conceito do aluno foi EXCELENTE\")\nelse:\n  print(\"Média de Avaliações Inválida\")\n\n\nO conceito do aluno foi BOM\n\n\n\n2º Exemplo - Classificação de Valores: Já pararam para pensar como o conceito é dado pelo sistema da Universidade Federal do Pará? Mas também pode ser feita de forma mais direta:\n\n\n\nCódigo\nprint(f\"Média das Avaliações: {round(mean, 2)}\")\n\n\nMédia das Avaliações: 7.66\n\n\nCódigo\n# Em qual conceito está média estaria?\nif 0 &lt;= mean &lt; 5:\n  print(\"O conceito do aluno foi INSUFICIENTE\")\nelif 5 &lt;= mean &lt; 7:\n  print(\"O conceito do aluno foi REGULAR\")\nelif 7 &lt;= mean &lt; 9:\n  print(\"O conceito do aluno foi BOM\")\nelif 9 &lt;= mean &lt; 10:\n  print(\"O conceito do aluno foi EXCELENTE\")\nelse:\n  print(\"Média de Avaliações Inválida\")\n\n\nO conceito do aluno foi BOM\n\n\n\n3º Exemplo - Condição com Expressão Ternária: Forma reduzida do if/else, muito últil para atribuições simples. Exemplo com string:\n\n\n\nCódigo\n# Dados do usuário\nage = 19\nCNH = True\n\n# Verificação com Expressão Ternária\nresult = \"Está apto a dirigir!\" if age &gt;= 18 and CNH != False else \"Não está apto a dirigir!\"\n\n# Visualizar\nprint(result)\n\n\nEstá apto a dirigir!\n\n\n\n3º Exemplo - Condição com Expressão Ternária: Forma reduzida do if/else, muito últil para atribuições simples. Exemplo com number:\n\n\n\nCódigo\n# Definindo números\nx, y = 4, 5\n\n# Verificação com Expressão Ternária\nmaior_valor = x if x &gt; y else y\n\n# Visualizar\nprint(maior_valor)\n\n\n5\n\n\n\n\n\nConsiderações e Boas Práticas\n\nUse elif quando apenas uma entre várias condições pode ser verdadeira;\nEvite aninhamentos profundos de if;\nUse operações compostas como 7 &lt;= mean &lt; 9 para mais clareza;\nSempre comente blocos de código complexos;\nLembre das ?tbl-operLogic que apresentam os operadores lógicos e ?tbl-conecLogic que mostra os conectores lógicos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo & Funções em Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/03_FlowControl_&_Functions.html#estruturas-de-repetição",
    "href": "Módulo I/03_FlowControl_&_Functions.html#estruturas-de-repetição",
    "title": "Controle de Fluxo & Funções em Python",
    "section": "Estruturas de Repetição",
    "text": "Estruturas de Repetição\nAs estruturas de repetição são usadas para executar um bloco de código várias vezes, de forma automática, até que uma condição seja satisfeita ou uma sequência de elementos seja percorrida.\nEm Python, temos duas principais formas de repetição:\n\nfor: Ideal quando sabemos o número de repetições ou estamos percorrendo uma estrutura (lista, string, dicionário, etc);\nwhile: Ideal quando não sabemos o número exato de repetições e precisamos que o código continue enquanto uma condição for verdadeira.\n\n\n\nEstrutura for\nA estrutura for é uma das formas mais comuns de repetição em Python. Ela é ideal quando:\n\nSabemos de antemão quantas vezes o código deve ser repetido; ou\nQueremos percorrer os elementos de uma sequência (como listas, strings, dicionários, etc.).\n\nVamos começar com o básico: o objeto range().\n\n\nCódigo\n# Lembra do objeto range()?\nrange(3)\n\n\nrange(0, 3)\n\n\nO comando acima não imprime os números, ele apenas cria um objeto que representa uma sequência de 0 até 2 (três elementos, começando do zero). Para visualizar os elementos, podemos convertê-lo em uma lista:\n\n\nCódigo\nlist(range(3))\n\n\n[0, 1, 2]\n\n\nAgora vamos usar o range() dentro de um laço for:\n\n\nCódigo\nfor i in range(3):\n    print(i)\n\n\n0\n1\n2\n\n\n\nAqui, o loop for vai executar o bloco de código três vezes, e a variável i assume os valores 0, 1 e 2 a cada repetição.\n\nVocê também pode fazer a mesma coisa passando uma lista explicitamente:\n\n\nCódigo\nprint(f\"Lista exemplo para iteração: {list(range(3))}\")\n\n\nLista exemplo para iteração: [0, 1, 2]\n\n\nCódigo\nprint(\"Iniciando contagem:\")\n\n\nIniciando contagem:\n\n\nCódigo\nfor contador in list(range(3)):\n  print(f\"Passo {contador + 1}: Valor atual = {contador}\")\n\n\nPasso 1: Valor atual = 0\nPasso 2: Valor atual = 1\nPasso 3: Valor atual = 2\n\n\nCódigo\nprint(\"Contagem concluída!\")\n\n\nContagem concluída!\n\n\n\nO resultado será o mesmo. Nesse caso, você está iterando diretamente sobre os elementos de uma lista.\n\n\n\nIterando em Strings\nStrings são sequências de caracteres, e podemos percorrê-las com o for.\n\n\nCódigo\ntexto = \"Curso de Python para Análise de Dados.\"\nfor caractere in texto:\n    print(caractere)\n\n\nC\nu\nr\ns\no\n \nd\ne\n \nP\ny\nt\nh\no\nn\n \np\na\nr\na\n \nA\nn\ná\nl\ni\ns\ne\n \nd\ne\n \nD\na\nd\no\ns\n.\n\n\n\nA cada repetição, a variável letra recebe um caractere da string. Esse recurso é útil para manipulações de texto.\n\n\n\n\nInterando em Listas\nSuponha que você tenha uma lista com nomes de frutas, e deseja imprimir cada fruta em letras maiúsculas.\n\n\nCódigo\n# Lista de frutas\nfrutas = [\"maçã\", \"banana\", \"laranja\", \"abacaxi\", \"uva\"]\n\n# Imprimindo cada fruta em caixa alta\nfor fruta in frutas:\n    print(fruta.upper())\n\n\nMAÇÃ\nBANANA\nLARANJA\nABACAXI\nUVA\n\n\n\nO método upper() transforma a string para letras maiúsculas. A variável fruta assume o valor de cada elemento da lista a cada iteração.\n\nVamos ver outro exemplo: elevar números ao quadrado e ao cubo:\n\n\nCódigo\n# Criando a lista de números de 0 a 5\nnumbers = list(range(6))\n\n# Iterando sobre a lista\nfor number in numbers:\n    print(f\"Número: {number}\")\n    print(f\"Número ao quadrado: {number ** 2}\")\n    print(f\"Número ao cubo: {number ** 3}\\n\")\n\n\nNúmero: 0\nNúmero ao quadrado: 0\nNúmero ao cubo: 0\n\nNúmero: 1\nNúmero ao quadrado: 1\nNúmero ao cubo: 1\n\nNúmero: 2\nNúmero ao quadrado: 4\nNúmero ao cubo: 8\n\nNúmero: 3\nNúmero ao quadrado: 9\nNúmero ao cubo: 27\n\nNúmero: 4\nNúmero ao quadrado: 16\nNúmero ao cubo: 64\n\nNúmero: 5\nNúmero ao quadrado: 25\nNúmero ao cubo: 125\n\n\n\nnumber assume os valores de 0 a 5 e cada iteração é mensurado o seu quadrado e o seu cubo.\n\n\n\n\nIterando em Dicionários\nDicionários são estruturas de dados compostas por pares chave:valor. Podemos iterar por eles usando o método items(), que retorna as chaves e valores simultaneamente:\n\n\nCódigo\n# Dicionário com traduções da palavra \"gato\"\ntranslations = {\"Português\": \"gato\", \"Inglês\": \"cat\", \"Francês\": \"chat\"}\n\n# Percorrendo as chaves e os valores\nfor idioma, palavra in translations.items():\n    print(f\"{idioma} -&gt; {palavra}\")\n\n\nPortuguês -&gt; gato\nInglês -&gt; cat\nFrancês -&gt; chat\n\n\n\nA cada iteração, idioma recebe a chave e palavra recebe o valor correspondente.\n\nVocê também pode usar zip() para fazer a iteração:\n\n\nCódigo\n# Outra forma de iterar: combinando as chaves e os valores com zip()\nfor idioma, palavra in zip(translations.keys(), translations.values()):\n    print(f\"{idioma} -&gt; {palavra}\")\n\n\nPortuguês -&gt; gato\nInglês -&gt; cat\nFrancês -&gt; chat\n\n\n\nO zip() combina os elementos das duas listas (chaves e valores) em pares.\n\nIterando com enumerate(): Às vezes, além de acessar o valor de uma lista ou dicionário, também queremos saber a posição (índice) do elemento. Para isso, usamos enumerate().\nVamos aplicar isso a um dicionário um pouco mais complexo:\n\n\nCódigo\n# Dicionário com informações de pessoas\ndados = {\n    \"Nome\": [\"Igor\", \"Allan\", \"Victória\", \"Izabella\", \"Fernando\"],\n    \"Idade\": [39, 17, 98, 45, 27],\n    \"Animal de Estimação\": [\"Gato\", \"Tigre\", \"Arara\", \"Javali\", \"Ratatouille\"]\n}\n\n# Percorrendo os dados\nfor i, key in enumerate(dados.keys()):\n    if i == 0:\n        print(\"Informações Coletadas:\")\n    for id in dados[key]:\n        if id == dados[key][0]:\n            print(f\"   {i + 1}. {key}:\")\n            print(f\"      {id}\")\n        else:\n            print(f\"      {id}\")\n\n\nInformações Coletadas:\n   1. Nome:\n      Igor\n      Allan\n      Victória\n      Izabella\n      Fernando\n   2. Idade:\n      39\n      17\n      98\n      45\n      27\n   3. Animal de Estimação:\n      Gato\n      Tigre\n      Arara\n      Javali\n      Ratatouille\n\n\n\nAqui temos dois níveis de repetição. O primeiro laço percorre cada “coluna” do dicionário, enquanto o segundo imprime os dados. O enumerate() é usado para acessar o índice i da chave atual, que nos ajuda a numerar facilitando a visualização de chave a chave.\n\nEsse tipo de estrutura é útil para imprimir dados de maneira organizada, como se fosse uma tabela ou relatório.\n\n\n\nCompreensão de Listas (List Comprehension)\nUma forma compacta e elegante de construir listas com base em laços for é a compreensão de listas.\nA sintaxe básica é:\n[expressao for item in lista]\nIsso pode ser lido como: aplique a expressao a cada item da lista.\nVejamos um exemplo simples.\n\n\nCódigo\n# Forma tradicional\nquadrados = []\nfor num in range(1, 11):\n    quadrados.append(num ** 2)\n\n# Visualizar\nprint(quadrados)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nCódigo\n# Forma com list comprehension\nquadrados = [num ** 2 for num in range(1, 11)]\n\n# Visualizar\nprint(quadrados)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\n\nA cada iteração é calculado o quadrado do num que assume valores de 1 a 10.\n\n\n\nCompreensão de Listas com Condição if\nÉ possível aplicar condicionais em compreensão de listas. De forma geral, a seguinte sintaxe é seguida:\n[expression for item in list if condition]\nLogo, a linha de código acima diz aplique a expression para cada item da list dado que condition é verdadeira.\nVejamos alguns exemplos:\n\n\nCódigo\n# Forma tradiconal\npares = []\nfor num in range(1, 21):\n  if num % 2 == 0:\n    pares.append(num)\n\n# Visualizar  \nprint(pares)\n\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\nCódigo\n# Forma com list comprehension\npares = [num for num in range(1, 21) if num % 2 == 0]\n\n# Visualizar  \nprint(pares)\n\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\nApenas os números pares serão incluídos na lista.\n\nTambém é possível combinar várias condições:\n\n\nCódigo\n# Forma tradiconal\nmultiplos = []\nfor num in range(100):\n  if num % 2 == 0 and num % 5 == 0:\n    multiplos.append(num)\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n\n\nCódigo\n# Forma com list comprehension\nmultiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0]\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n\n\n\nA lista conterá números múltiplos de 2 e de 5.\n\n\n\nCódigo\n# Forma tradiconal\nmultiplos = []\nfor num in range(100):\n  if num % 2 == 0 and num % 5 == 0 and num % 6 == 0:\n    multiplos.append(num)\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 30, 60, 90]\n\n\nCódigo\n# Forma com list comprehension\nmultiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0 and num % 6 == 0]\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 30, 60, 90]\n\n\n\nA lista conterá números múltiplos de 2, 5 e 6.\n\n\n\nCódigo\n# Forma tradiconal\nmultiplos = []\nfor num in range(100):\n  if num % 2 == 0 and num % 5 == 0 or num % 6 == 0:\n    multiplos.append(num)\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 6, 10, 12, 18, 20, 24, 30, 36, 40, 42, 48, 50, 54, 60, 66, 70, 72, 78, 80, 84, 90, 96]\n\n\nCódigo\n# Forma com list comprehension\nmultiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0 or num % 6 == 0]\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 6, 10, 12, 18, 20, 24, 30, 36, 40, 42, 48, 50, 54, 60, 66, 70, 72, 78, 80, 84, 90, 96]\n\n\n\nA lista conterá números múltiplos de 2 e de 5 ou de 6.\n\n\n\n\nCompreensão de Listas com if e else\nA estrutura muda levemente:\n[expression_if if condition else expression_else for item in list]\nEm outras palavras: execute expression_if caso condition seja verdadeira e expression_else caso contrário para cada item da list.\nVamos a um exemplo.\n\n\nCódigo\n# Forma tradiconal\nsucess_number_div_5 = []\nfor number in range(26):\n  if number % 5 == 0:\n    sucess_number_div_5.append(\"sucess\")\n  else:\n    sucess_number_div_5.append(\"failure\")\n\n# Visualizar  \nprint(sucess_number_div_5)\n\n\n['sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess']\n\n\nCódigo\n# Forma com list comprehension\nsucess_number_div_5 = [\"sucess\" if number % 5 == 0 else \"failure\" for number in range(26)]\n\n# Visualizar  \nprint(sucess_number_div_5)\n\n\n['sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess']\n\n\n\nA expressão acima retorna uma lista com as palavras \"sucess\" ou \"failure\" dependendo do valor de cada número.\n\n\n\n\nMúltiplas Compreensão de Listas\nAqui é exigida um pouco mais de atenção. Considere a matriz \\mathbf{x} = \\begin{bmatrix} 1 & 2 & 3 & 4 \\\\ 5 & 6 & 7 & 8 \\\\ 9 & 10 & 11 & 12 \\end{bmatrix} e \\mathbf{x^{\\intercal}} = \\begin{bmatrix} 1 & 5 & 9 \\\\ 2 & 6 & 10 \\\\ 3 & 7 & 11 \\\\ 4 & 8 & 12 \\end{bmatrix}. Como fazer isso usando compreensão de listas?\n\n\nCódigo\nmatrix = [\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9, 10, 11, 12]\n]\n\nprint(matrix)\n\n\n[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n\n\nPara facilitar o entendimento e melhorar a aprendizagem, vamos fazer usando estrutura for de forma simples.\n\n\nCódigo\n# Forma tradiconal\ntransposta = []\nfor column in range(len(matrix[0])):\n  row = []\n  \n  for element in matrix:\n    row.append(element[column])\n    \n  transposta.append(row)\n\n# Visualizar  \nprint(transposta)\n\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n\n\nEntretanto, é possível otimizar o código usando compreensão de listas.\n\n\nCódigo\n# Forma com list comprehension\ntransposta = [[element[column] for element in matrix] for column in range(len(matrix[0]))]\n\n# Visualizar  \nprint(transposta)\n\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n\n\n\n\n\n\n\nEstrutura while\nA estrutura de repetição while é usada quando não sabemos com antecedência quantas vezes o bloco de código deve ser repetido. A repetição acontece enquanto uma condição lógica for verdadeira. Assim que essa condição se torna falsa, o laço é encerrado automaticamente.\nA estrutura geral é:\nwhile condição:\n    # bloco de código\nIsso significa que o código dentro do while será executado repetidamente enquanto a condição especificada for verdadeira. Por isso, é muito importante garantir que a condição eventualmente se torne falsa — do contrário, o programa pode entrar em um loop infinito.\n\n\nExemplos de Uso\n\nContador Simples\n\n\nCódigo\ncontador = 1\n\nwhile contador &lt;= 5:\n    print(f\"Contador: {contador}\")\n    contador += 1\n\n\nContador: 1\nContador: 2\nContador: 3\nContador: 4\nContador: 5\n\n\nEsse é o uso mais básico de um while. A variável de controle é atualizada em cada repetição até que a condição se torne falsa.\n\n\n\nApenas Números Pares\n\n\nCódigo\nn = 1\n\nwhile n &lt;= 10:\n    if n % 2 == 0:\n        print(f\"{n} é par\")\n    n += 1\n\n\n2 é par\n4 é par\n6 é par\n8 é par\n10 é par\n\n\nNeste exemplo, o if dentro do while adiciona uma condição extra, filtrando apenas os números pares entre 1 e 10.\n\n\n\nExemplo com input()\nnumber = int(input(\"Digite um número positivo: \"))\n\nwhile number &lt;= 0:\n    print(\"O número fornecido não é positivo. Tente novamente!\")\n    number = int(input(\"Digite um número positivo: \"))\n\nprint(f\"Parabêns. O número fornecido é positivo!\")\nEsse exemplo usa input() para verificar se o valor digitado é positivo ou não.\n\n\n\nExemplo com string: invertendo uma palavra\n\n\nCódigo\npalavra = \"Python\"\nreverso = \"\"\ni = len(palavra) - 1\n\nwhile i &gt;= 0:\n    reverso += palavra[i]\n    i -= 1\n\nprint(f\"A palavra '{palavra}' invertida é '{reverso}'.\")\n\n\nA palavra 'Python' invertida é 'nohtyP'.\n\n\nAqui usamos while para percorrer uma string de trás para frente e gerar sua versão invertida.\n\n\n\nExemplo com lista: somando números até esvaziar a lista\n\n\nCódigo\nnumeros = [10, 20, 30, 40, 50]\nsoma = 0\n\nwhile numeros:\n    valor = numeros.pop()  # Remove o último elemento\n    soma += valor\n\nprint(f\"Soma dos valores: {soma}\")\n\n\nSoma dos valores: 150\n\n\nEsse exemplo mostra como o while pode operar enquanto uma lista tiver elementos — uma abordagem comum para estrutura de pilha.\n\n\n\nExemplo com múltiplas condições\n\n\nCódigo\ndados, i = [12, -3, 5, 0, -8, 19, -1, 0, 7], 0\n\npositivos, negativos, zeros = 0, 0, 0\n\nwhile i &lt; len(dados):\n    if dados[i] &gt; 0:\n        positivos += 1\n    elif dados[i] &lt; 0:\n        negativos += 1\n    else:\n        zeros += 1\n    i += 1\n\nprint(f\"Positivos: {positivos}, Negativos: {negativos}, Zeros: {zeros}\")\n\n\nPositivos: 4, Negativos: 3, Zeros: 2\n\n\nEsse exemplo simula uma classificação de dados usando while com múltiplas condições if-elif-else.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo & Funções em Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/03_FlowControl_&_Functions.html#comandos-chave",
    "href": "Módulo I/03_FlowControl_&_Functions.html#comandos-chave",
    "title": "Controle de Fluxo & Funções em Python",
    "section": "Comandos-Chave",
    "text": "Comandos-Chave\nEm desenvolvimento Python, à medida que a complexidade do código aumenta, torna-se fundamental o domínio de mecanismos para o tratamento robusto de erros e o controle preciso da execução de estruturas de repetição. Esta seção explora dois grupos essenciais de comandos que possibilitam um fluxo de execução mais refinado e resiliente.\n\nTratamento de Exceções: Python oferece um conjunto de construções para o tratamento de exceções, permitindo o desenvolvimento de código capaz de responder de forma controlada a eventos inesperados durante a execução. Ao utilizar blocos try, except e, opcionalmente, finally, é possível interceptar e manipular erros, evitando a interrupção abrupta do programa e implementando estratégias de recuperação ou finalização controlada de recursos.\nControle de Fluxo em Loops: Adicionalmente às estruturas condicionais básicas, Python disponibiliza palavras-chave específicas para o controle do fluxo de execução dentro de laços de repetição (for e while). Os comandos break e continue fornecem mecanismos para alterar o comportamento padrão dos loops:\n\nbreak: Interrompe a execução do loop corrente e transfere o controle para a próxima instrução após o loop.\ncontinue: Interrompe a iteração corrente e passa para a próxima iteração do loop.\n\n\nO domínio destas ferramentas de tratamento de exceções e controle de fluxo em loops é crucial para a escrita de código Python robusto, eficiente e capaz de lidar com cenários complexos de execução. A correta aplicação destes conceitos contribui significativamente para a qualidade e a manutenibilidade de projetos de software.\n\n\nTratamento de Exceções\nEm Python, erros em tempo de execução são inevitáveis (e.g., entrada inválida, divisão por zero, arquivo ausente). O tratamento de exceções, via blocos try/except, permite que o programa continue executando ao invés de interromper. Ao prever e capturar erros específicos, o código reage de forma controlada, garantindo maior robustez e estabilidade da aplicação. Essencial para software confiável.\nUm exemplo da estrutura básica é apresentado no bloco de código abaixo:\ntry:\n    # Código que pode gerar erros\n    numero = int(input(\"Digite um número: \"))\n    resultado = 10 / numero\n    print(\"Resultado:\", resultado)\nexcept ZeroDivisionError:\n    # Executado se ocorrer o erro específico\n    print(\"Erro: Divisão por zero!\")\nexcept Exception as e:\n    # Captura qualquer outro erro\n    print(f\"Erro inesperado: {e}\")\nelse:\n    # Executado se NENHUM erro ocorrer\n    print(\"Operação bem-sucedida!\")\nfinally:\n    # Sempre executado (com ou sem erros)\n    print(\"Fim do bloco try-except\")\n\n\nCódigo\ntry:\n    # Código que pode gerar erros\n    numero = 0\n    resultado = 10 / numero\n    print(\"Resultado:\", resultado)\nexcept ZeroDivisionError:\n    # Executado se ocorrer o erro específico\n    print(\"Erro: Divisão por zero!\")\nexcept Exception as e:\n    # Captura qualquer outro erro\n    print(f\"Erro inesperado: {e}\")\nelse:\n    # Executado se NENHUM erro ocorrer\n    print(\"Operação bem-sucedida!\")\nfinally:\n    # Sempre executado (com ou sem erros)\n    print(\"Fim do bloco try-except\")\n\n\nErro: Divisão por zero!\nFim do bloco try-except\n\n\n\nO bloco try encapsula o código passível de gerar erros em tempo de execução.\nO bloco except especifica o tratamento para tipos particulares de erros (exceções) que possam ocorrer dentro do bloco try. Múltiplos blocos except podem ser definidos para lidar com diferentes tipos de exceções. A captura genérica de qualquer exceção pode ser realizada com except Exception.\nO bloco finally é executado invariavelmente, independentemente da ocorrência ou não de uma exceção dentro do bloco try. Sua principal aplicação reside na execução de rotinas de finalização, como o fechamento de arquivos ou a liberação de conexões.\n\n\n\n\nPalavras-Chave\nDentro de laços de repetição for e while em Python, as palavras-chave break e continue oferecem mecanismos essenciais para o controle preciso do fluxo de execução. break interrompe imediatamente a execução do loop, transferindo o controle para a instrução seguinte ao bloco do loop. continue, por sua vez, encerra a iteração corrente e passa para a próxima iteração do loop. A utilização estratégica dessas palavras-chave contribui para a organização e a eficiência do código em cenários onde a execução padrão do loop necessita ser alterada condicionalmente.\n\n\nbreak\n\n\nCódigo\n# Encontra o primeiro número divisível por 7\nfor num in range(1, 10):\n    if num % 7 == 0:\n        print(f\"Encontrado: {num}\")\n        break\n    print(num)\n\n\n1\n2\n3\n4\n5\n6\nEncontrado: 7\n\n\nwhile True:\n    senha = input(\"Digite a senha (1234) para sair: \")\n    if senha == \"1234\":\n        print(\"Senha correta! Saindo...\")\n        break\n    print(\"Senha incorreta!\")\n\n\n\ncontinue\n\n\nCódigo\n# Não irá imprimir o número 7\nfor num in range(1, 10):\n    if num == 7:\n        continue\n    print(num)\n\n\n1\n2\n3\n4\n5\n6\n8\n9\n\n\n\n\nCódigo\nprodutos = [\"camiseta\", \"caneca\", None, \"poster\", \"\", \"adesivo\"]\nfor item in produtos:\n    if not item:  # None ou string vazia\n        continue\n    print(f\"Processando: {item.upper()}\")\n\n\nProcessando: CAMISETA\nProcessando: CANECA\nProcessando: POSTER\nProcessando: ADESIVO",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo & Funções em Python</span>"
    ]
  },
  {
    "objectID": "Módulo I/03_FlowControl_&_Functions.html#funções",
    "href": "Módulo I/03_FlowControl_&_Functions.html#funções",
    "title": "Controle de Fluxo & Funções em Python",
    "section": "Funções",
    "text": "Funções\nVamos relembrar o conceito de função dada por Guidorizzi (2001):\n\n“Uma função f é uma relação entre dois conjuntos A e B, representada pela tripla (A, B, a \\mapsto b), onde A é o conjunto de partida (domínio), B é o conjunto de chegada (contradomínio) e a \\mapsto b é a regra que associa a cada elemento a \\in A um único elemento b \\in B.”\n\nPara fins técnicos, as funções em Python seguem esse mesmo raciocínio. Uma função é um bloco de código que executa uma tarefa específica e pode ser reutilizado várias vezes ao longo do programa. Ao invés de repetir o mesmo conjunto de comandos, colocamos esses comandos dentro de uma função e chamamos essa função sempre que precisarmos dela. Pense nela como uma “minifábrica” que recebe certas entradas (opcionalmente), processa-as e produz uma saída (opcionalmente).\nNo universo da programação, a capacidade de organizar o código de forma organizad, modular e reutilizável é um pilar para a construção de sistemas eficientes e de fácil manutenção. Em Python, esse pilar é sustentado pelas funções. Nesta seção, exploraremos desde os conceitos básicos até aspectos mais avançados, com aplicações práticas.\nVocê pode pensar em uma função como uma “máquina” que recebe certos dados (chamados parâmetros ou argumentos), processa esses dados e, em muitos casos, devolve um resultado (valor de retorno).\nA importância das funções é multifacetada, apresentando várias vantagens de fazer seu uso. Elas são fundamentais para:\n\nModularidade: Funções permitem quebrar programas grandes e complexos em partes menores e mais gerenciáveis. Isso facilita o desenvolvimento, a depuração e a compreensão do código.\nReusabilidade de Código (DRY - Don’t Repeat Yourself): Uma vez definida, uma função pode ser chamada múltiplas vezes de diferentes partes do programa, eliminando a necessidade de reescrever o mesmo código repetidamente.\nAbstração: Funções escondem os detalhes de implementação de uma tarefa complexa. Você precisa saber o que a função faz (sua finalidade), mas não necessariamente como ela faz.\nManutenção: Se uma alteração for necessária em uma lógica específica, basta modificar a função correspondente. Isso é muito mais eficiente do que procurar e alterar várias ocorrências do mesmo código espalhado pelo programa.\nLegibilidade: O uso de funções com nomes descritivos torna o código mais fácil de ler e entender, pois cada função representa uma etapa lógica clara no fluxo do programa.\n\n\nSintaxe Básica\nEm Python, para definir uma função é utilizado a palavra chave def, seguida do nome da função e parênteses para os possíveis parâmetros e :. Ao pressionar enter o bloco será automaticamnete identado (quatro espações ou um tab) pelo editor. Todo código identado faz parte da função.\ndef name_function():\n  # seu código será disposto aqui\n  # e o Python irá compreende-lo como parte da função\n\nExemplos:\n\n\n\nCódigo\ndef greeting1():\n  print(\"Olá. Sejá bem-vindo ao Curso de Python para Análise de Dados!\")\n\n\ndef greeting2(nome):\n  print(f\"Olá, {nome}. Sejá bem-vindo ao Curso de Python para Análise de Dados!\")\n  \n\ngreeting1()\n\n\nOlá. Sejá bem-vindo ao Curso de Python para Análise de Dados!\n\n\nCódigo\ngreeting2(\"Breno\")\n\n\nOlá, Breno. Sejá bem-vindo ao Curso de Python para Análise de Dados!\n\n\n\n\nParâmetros e Argumentos\nFunções podem receber dados de entrada para realizar suas tarefas. Esses dados são passados através de parâmetros na definição da função e argumentos na chamada da função.\n\n\nTipos de Parâmetros/Argumentos:\n\nArgumentos Posicionais: São os argumentos passados na ordem em que os parâmetros são definidos.\n\n\n\nCódigo\ndef saudar(nome, sobrenome):\n  print(f\"Olá, {nome} {sobrenome}!\")\n\nsaudar(\"Maria\", \"Silva\") # Saída: Olá, Maria Silva!\n\n\nOlá, Maria Silva!\n\n\nCódigo\nsaudar(\"Silva\", \"Maria\") # Saída: Olá, Silva Maria!\n\n\nOlá, Silva Maria!\n\n\n\nArgumentos de Palavra-chave (Keyword Arguments): São passados explicitamente associando o nome do parâmetro ao seu valor. A ordem não importa.\n\n\n\nCódigo\ndef email(nome, dominio=\"icen.ufpa.br\"):\n    return f\"{nome.lower()}@{dominio}\"\n\nprint(email(nome=\"joao\"))                            # Saída: joao@icen.ufpa.br\n\n\njoao@icen.ufpa.br\n\n\nCódigo\nprint(email(dominio=\"ufpa.br\", nome=\"ANA\")) # Saída: ana@ufpa.br\n\n\nana@ufpa.br\n\n\n\nParâmetros com Valores Padrão (Default Parameters): Permitem definir um valor padrão para um parâmetro. Se o argumento não for fornecido na chamada da função, o valor padrão é utilizado.\n\n\n\nCódigo\ndef calcular_potencia(base, expoente=2): # expoente tem valor padrão 2\n    return base ** expoente\n\nprint(calcular_potencia(3))    # Saída: 9 (3^2)\n\n\n9\n\n\nCódigo\nprint(calcular_potencia(2, 4)) # Saída: 16 (2^4)\n\n\n16\n\n\nCuidado: Parâmetros com valores padrão devem ser definidos após os parâmetros sem valores padrão.\n\nArgumentos Arbitrários (*args e **kwargs): Permitem que uma função aceite um número variável de argumentos.\n\n\n*args (non-keyword arguments): Coleta um número variável de argumentos posicionais em uma tupla.\n\n\n\nCódigo\ndef soma_tudo(*numeros):\n    total = 0\n    for num in numeros:\n        total += num\n    return total\n\nprint(soma_tudo(1, 2, 3))        # Saída: 6\n\n\n6\n\n\nCódigo\nprint(soma_tudo(10, 20, 30, 40)) # Saída: 100\n\n\n100\n\n\n\n**kwargs (keyword arguments): Coleta um número variável de argumentos de palavra-chave em um dicionário.\n\n\n\nCódigo\ndef exibir_perfil(**info):\n  for chave, valor in info.items():\n      print(f\"{chave.replace(\"_\", \" \").title()}: {valor}\")\n\nexibir_perfil(nome=\"Carlos\", idade=30, cidade=\"São Paulo\")\n\n\nNome: Carlos\nIdade: 30\nCidade: São Paulo\n\n\nCódigo\n# Saída:\n# Nome: Carlos\n# Idade: 30\n# Cidade: São Paulo\n\nexibir_perfil(nome_cliente=\"Carlos\", idade_cliente=30, cidade_cliente=\"São Paulo\")\n\n\nNome Cliente: Carlos\nIdade Cliente: 30\nCidade Cliente: São Paulo\n\n\nCódigo\n# Saída:\n# Nome Cliente: Carlos\n# Idade Cliente: 30\n# Cidade Cliente: São Paulo\n\n\n\n\nRetorno de Valores\nVimos que é possível imprimir valores na tela através de funções. Entretanto e se precisarmos dos valores que são calculados por determinada função? De acordo com o que apreendemos basta atribuir a saída do programa a uma variável.\n\n\nCódigo\n# Atribuição\ngrr = greeting2(\"Emilly Rose\")\n\n\nOlá, Emilly Rose. Sejá bem-vindo ao Curso de Python para Análise de Dados!\n\n\nTambém de acordo com o que apreendemos, basta chamar a variável grr em qualquer parte do código que ela mostrará a frase: Olá, Emilly Rose. Sejá bem-vindo ao Curso de Python para Análise de Dados!.\n\n\nCódigo\n# Chamando variável\ngrr\n\n\nNote que a saída do código acima, não resultou em nada. Ou ainda, pode ter resultado, porém, o resutado foi vazio (None).\n\n\nCódigo\n# Verificação\ngrr == None\n\n\nTrue\n\n\nNote que, por consequência, valores definidos dentro de uma função não são exportados para fora dela. Isto é, algo definido no local de um função não será definido no ambiente global.\n\n\nCódigo\ndef minha_funcao():\n      arr = 10  # Variável local\n      print(arr)\n\nminha_funcao()\n\n\n10\n\n\nCódigo\ntry:\n  print(arr)  # Erro! 'arr' só existe dentro da função.\n\nexcept NameError:\n  print(\"Variável 'arr' não definida!\")\n\n\nVariável 'arr' não definida!\n\n\nIsso ocorre porque a estrutura que está sendo utilizada pela função greeting2 não foi feita para retornar valores, mas sim, para apenas os imprimir na tela.\n\nBoas Práticas de Escopo:\n\nPriorize o Escopo Local: É uma boa prática projetar funções para serem o mais independentes possível, evitando depender de variáveis globais. Isso melhora a modularidade e reduz efeitos colaterais indesejados.\nEvite o Uso de global: A palavra-chave global permite modificar uma variável global dentro de uma função. Seu uso deve ser evitado ao máximo, pois pode levar a um código confuso e difícil de depurar. Se uma função precisa alterar dados globais, é preferível que ela retorne os novos valores para que o código chamador possa atualizar a variável global explicitamente.\nPassagem de Argumentos: Sempre que uma função precisar de dados externos, passe-os como argumentos, em vez de depender de variáveis globais.\n\n\nPara que a função realmente retorne o valor que foi obtido/calculado por ela, basta utilizar um comando interno do Python chamado return. Vamos a exemplos:\n\nSoma de dois termos:\n\n\n\nCódigo\ndef my_function_sum1(a, b):\n  summ = a + b\n  \n  return summ\n  \ndef my_function_sum2(a, b):\n  return a + b\n\n\na = my_function_sum1(1/2, 1/2)\nb = my_function_sum2(1/2, 1/2)\n\nprint(a == b)\n\n\nTrue\n\n\n\nSoma de n termos:\n\n\n\nCódigo\ndef my_function_sum(*numbers):\n  summ = 0\n  for num in numbers:\n    if type(num) == list:\n      for n in num:\n        if (type(n) != int) or (type(n) != float):\n          continue\n        \n        summ += n\n    else:\n        summ += num\n    \n  return summ\n  \nmy_function_sum([1, 2, \"a\", 3], 5, 10, 20, 32)\n\n\n67\n\n\nNote que, se eu quiser o resultados desta soma para usá-lo em outra hora, basta atribuir isso a uma variável.\n\n\nCódigo\n# Guardando soma\nsumm = my_function_sum([1, 2, \"a\", 3], 5, 10, 20, 32)\n\n# Visualizando\nprint(summ)\n\n\n67\n\n\nCódigo\n# Verificando\nprint(summ == None) # A saída deve ser: False\n\n\nFalse\n\n\n\n\nFunções Anônimas - lambda functions\nFunções lambda são pequenas funções anônimas (sem nome) que são definidas usando a palavra-chave lambda. Elas são restritas a uma única expressão e são frequentemente usadas para tarefas curtas e simples onde uma função completa seria excessiva.\n\nSintaxe: lambda argumentos: expressão\n\n\n\nCódigo\n# Definindo função anônima\nsquare = lambda x: x ** 2\n\n# Fazendo uso da função\nprint(square(2))\n\n\n4\n\n\nCódigo\n# Definindo função anônima\nlinear = lambda x, y: 2 * x + y\n\n# Fazendo uso da função\nprint(linear(2, 3))\n\n\n7\n\n\nCódigo\n# Definindo função anônima\ntt = lambda x: x * 2 + x\n\n# Fazendo uso da função\nprint(tt([1, 2, 3]))\n\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\nEssa maniera de se definir uma função é comumente usada em conjunto das funções sorted(), filter() e map().\n\n\nCódigo\nlist_of_numbers = [2.5, 1, 5, 9, 0.1, 2, 8, 3, 12]\n\n# Exemplo de uso com sorted()\nprint(sorted(list_of_numbers, key = lambda x: 1 / x ** 2))\n\n\n[12, 9, 8, 5, 3, 2.5, 2, 1, 0.1]\n\n\nCódigo\n# Exemplo de uso com filter()\nprint(list(filter(lambda x: x % 2 == 0, list_of_numbers)))\n\n\n[2, 8, 12]\n\n\nCódigo\n# Exemplo de um com map()\nprint(list(map(lambda x: x * 2, list_of_numbers)))\n\n\n[5.0, 2, 10, 18, 0.2, 4, 16, 6, 24]\n\n\n\n\n\n\n\n\n\n\n\n\n\nGuidorizzi, Hamilton Luiz. 2001. Um Curso de Cálculo, Volume 1. 5ª ed. Rio de Janeiro: LTC.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo & Funções em Python</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referêcias",
    "section": "",
    "text": "Guidorizzi, Hamilton Luiz. 2001. Um Curso de Cálculo, Volume 1.\n5ª ed. Rio de Janeiro: LTC.",
    "crumbs": [
      "Referêcias"
    ]
  }
]