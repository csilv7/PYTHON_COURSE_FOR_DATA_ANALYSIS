[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Python",
    "section": "",
    "text": "1 Boas-vindas ao Universo da An√°lise de Dados com Python!\nSeja muito bem-vindo(a) ao Curso de Python para An√°lise de Dados! Se voc√™ est√° aqui, provavelmente compartilha da curiosidade e do desejo de transformar dados brutos em informa√ß√µes valiosas e decis√µes estrat√©gicas. Este curso foi meticulosamente planejado para ser sua porta de entrada nesse universo fascinante, guiando voc√™ desde os primeiros passos na programa√ß√£o com Python at√© a aplica√ß√£o de t√©cnicas essenciais de an√°lise de dados.\nPython se consolidou como uma das linguagens de programa√ß√£o mais influentes e requisitadas no campo da Ci√™ncia e An√°lise de Dados. Sua popularidade n√£o √© por acaso: a sintaxe intuitiva, a vasta cole√ß√£o de bibliotecas especializadas e uma comunidade global ativa tornam o aprendizado mais acess√≠vel e o desenvolvimento mais eficiente. Aqui, voc√™ descobrir√° como aproveitar todo esse potencial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#sobre-o-autor",
    "href": "index.html#sobre-o-autor",
    "title": "Curso de Python",
    "section": "1.1 Sobre o Autor",
    "text": "1.1 Sobre o Autor\n\n\n\n\n\n\nConhe√ßa o Instrutor\n\n\n\nMeu nome √© Breno C R Silva, sou Bacharelando em Estat√≠stica pela Universidade Federal do Par√° com foco em Estat√≠stica Descritiva, Probabilidade, Estat√≠stica Infer√™ncial, Modelos de Regress√£o e Classifica√ß√£o e, em especial, An√°lise de S√©ries Temporais e An√°lise de Sobreviv√™ncia.\nTrabalho com Python e An√°lise de Dados h√° 3 anos, aplicando essas ferramentas em Previs√£o do ICMS, Modelagem Semiparam√©trica em Dados Sujeitos a Censura Intervalar, Previs√£o de Concess√£o de Cr√©dito entre outros projetos.\nCriei este curso para compartilhar meu conhecimento e ajudar mais pessoas a descobrirem o poder dos dados. Espero que aproveitem a jornada!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#por-que-aprender-python-para-an√°lise-de-dados",
    "href": "index.html#por-que-aprender-python-para-an√°lise-de-dados",
    "title": "Curso de Python",
    "section": "1.2 Por Que Aprender Python para An√°lise de Dados?",
    "text": "1.2 Por Que Aprender Python para An√°lise de Dados?\nVivemos na era dos dados. Empresas, institui√ß√µes de pesquisa e organiza√ß√µes de todos os tipos coletam volumes massivos de informa√ß√µes diariamente. A capacidade de analisar esses dados para extrair insights, identificar padr√µes, prever tend√™ncias e comunicar descobertas tornou-se uma habilidade crucial e altamente valorizada no mercado de trabalho.\nPython, com seu ecossistema robusto (especialmente bibliotecas como Pandas, NumPy, Matplotlib e Seaborn), oferece as ferramentas perfeitas para realizar todo o ciclo de vida da an√°lise de dados:\n\nColeta e Limpeza: Obter dados de diversas fontes e prepar√°-los para an√°lise, tratando inconsist√™ncias e valores ausentes.\nManipula√ß√£o e Transforma√ß√£o: Estruturar, filtrar, agregar e remodelar os dados para atender √†s necessidades da an√°lise.\nAn√°lise Explorat√≥ria (EDA): Investigar os dados para entender suas caracter√≠sticas principais, descobrir rela√ß√µes e formular hip√≥teses.\nVisualiza√ß√£o: Criar gr√°ficos e representa√ß√µes visuais claras e impactantes para comunicar os resultados.\nComunica√ß√£o: Gerar relat√≥rios e apresenta√ß√µes que traduzam as descobertas t√©cnicas em informa√ß√µes acion√°veis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#objetivos-de-aprendizagem-do-curso",
    "href": "index.html#objetivos-de-aprendizagem-do-curso",
    "title": "Curso de Python",
    "section": "1.3 Objetivos de Aprendizagem do Curso",
    "text": "1.3 Objetivos de Aprendizagem do Curso\nAo concluir este curso, voc√™ estar√° apto(a) a:\n\nDominar os Fundamentos de Python: Escrever c√≥digo Python claro e eficiente, utilizando vari√°veis, tipos de dados, operadores, estruturas de controle (condicionais e loops) e fun√ß√µes.\nManipular Dados com Pandas: Utilizar DataFrames e Series para carregar, limpar, transformar, filtrar, agregar e combinar conjuntos de dados de forma eficaz.\nRealizar C√°lculos Num√©ricos com NumPy: Empregar arrays NumPy para opera√ß√µes matem√°ticas e estat√≠sticas vetorizadas de alta performance.\nCriar Visualiza√ß√µes com Matplotlib e Seaborn: Gerar diversos tipos de gr√°ficos (linhas, barras, dispers√£o, histogramas, boxplots, etc.) para explorar dados e comunicar resultados visualmente.\nAplicar o Processo de An√°lise de Dados: Integrar as ferramentas aprendidas para realizar an√°lises explorat√≥rias b√°sicas em conjuntos de dados reais ou simulados.\nDesenvolver Racioc√≠nio Anal√≠tico: Interpretar os resultados das an√°lises e das visualiza√ß√µes para extrair conclus√µes relevantes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#a-quem-se-destina-este-curso",
    "href": "index.html#a-quem-se-destina-este-curso",
    "title": "Curso de Python",
    "section": "1.4 A Quem Se Destina Este Curso?",
    "text": "1.4 A Quem Se Destina Este Curso?\nEste material foi pensado com carinho para um p√∫blico diversificado, incluindo:\n\nEstudantes Universit√°rios: De cursos como Estat√≠stica, Ci√™ncia da Computa√ß√£o, Engenharias, Economia, Administra√ß√£o e √°reas afins que desejam uma introdu√ß√£o pr√°tica √† an√°lise de dados com Python.\nProfissionais em Transi√ß√£o de Carreira: Pessoas que buscam adquirir habilidades em an√°lise de dados para novas oportunidades no mercado.\nCuriosos e Entusiastas: Qualquer pessoa com interesse em aprender a programar e a trabalhar com dados. Acreditamos que a vontade de aprender √© o principal pr√©-requisito!\nIniciantes em Programa√ß√£o: Se voc√™ nunca programou antes, n√£o se preocupe! Come√ßaremos do b√°sico.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-detalhada-do-curso",
    "href": "index.html#estrutura-detalhada-do-curso",
    "title": "Curso de Python",
    "section": "1.5 Estrutura Detalhada do Curso",
    "text": "1.5 Estrutura Detalhada do Curso\nNossa jornada ser√° dividida em m√≥dulos progressivos, construindo seu conhecimento passo a passo:\n\nM√≥dulo 1: Fundamentos Essenciais de Python:\n\nIntrodu√ß√£o √† linguagem e configura√ß√£o do ambiente (Anaconda, Jupyter Notebook).\nSintaxe b√°sica, vari√°veis, tipos de dados (n√∫meros, strings, booleanos).\nOperadores (aritm√©ticos, compara√ß√£o, l√≥gicos).\nEstruturas de dados nativas: Listas, Tuplas, Dicion√°rios e Conjuntos (Sets).\nEstruturas de controle: Condicionais (if, elif, else) e La√ßos de repeti√ß√£o (for, while).\nDefini√ß√£o e uso de Fun√ß√µes para modularizar o c√≥digo.\n\nM√≥dulo 2: Computa√ß√£o Num√©rica com NumPy:\n\nIntrodu√ß√£o aos arrays NumPy (ndarrays) e suas vantagens.\nCria√ß√£o, indexa√ß√£o e fatiamento de arrays uni e multidimensionais.\nOpera√ß√µes matem√°ticas vetorizadas e broadcasting.\nFun√ß√µes estat√≠sticas e manipula√ß√£o de arrays.\n\nM√≥dulo 3: Manipula√ß√£o e An√°lise de Dados com Pandas:\n\nAs estruturas chave: Series e DataFrames.\nLeitura e escrita de dados (CSV, Excel, etc.).\nSele√ß√£o e filtragem de dados (loc, iloc, boolean indexing).\nLimpeza de dados: Tratamento de valores ausentes e duplicados.\nTransforma√ß√£o de dados: Aplica√ß√£o de fun√ß√µes, cria√ß√£o de novas colunas.\nAgrupamento e agrega√ß√£o com groupby().\nCombina√ß√£o de DataFrames (merge, concat, join).\n\nM√≥dulo 4: Visualiza√ß√£o de Dados com Matplotlib e Seaborn:\n\nPrinc√≠pios da visualiza√ß√£o de dados.\nCria√ß√£o de gr√°ficos b√°sicos e customiza√ß√£o com Matplotlib.\nGera√ß√£o de gr√°ficos estat√≠sticos avan√ßados e esteticamente agrad√°veis com Seaborn.\nIntegra√ß√£o com Pandas para visualiza√ß√£o direta de DataFrames.\n\nM√≥dulo 5: Projeto de An√°lise Explorat√≥ria de Dados (EDA):\n\nAplica√ß√£o integrada dos conhecimentos adquiridos em um projeto pr√°tico.\nPasso a passo: Defini√ß√£o do problema, coleta/carregamento dos dados, limpeza, an√°lise explorat√≥ria, visualiza√ß√£o e comunica√ß√£o dos resultados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#nossa-metodologia-de-ensino",
    "href": "index.html#nossa-metodologia-de-ensino",
    "title": "Curso de Python",
    "section": "1.6 Nossa Metodologia de Ensino",
    "text": "1.6 Nossa Metodologia de Ensino\nBuscamos um equil√≠brio entre teoria e pr√°tica, utilizando uma abordagem ativa:\n\nConte√∫do Conceitual Claro: Explica√ß√µes diretas e objetivas dos conceitos fundamentais, utilizando analogias e exemplos simples.\nC√≥digo Comentado e Exemplos Pr√°ticos: Demonstra√ß√µes passo a passo de como aplicar cada conceito e ferramenta em Python, com c√≥digo funcional e comentado.\nFoco na Resolu√ß√£o de Problemas: Apresenta√ß√£o de cen√°rios e problemas t√≠picos da an√°lise de dados para contextualizar o aprendizado.\nExerc√≠cios Progressivos: Desafios pr√°ticos ao final das se√ß√µes para voc√™ testar e consolidar seu entendimento.\nProjetos Integradores: Aplica√ß√£o do conhecimento em projetos que simulam situa√ß√µes reais de an√°lise.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#pr√©-requisitos-e-ferramentas",
    "href": "index.html#pr√©-requisitos-e-ferramentas",
    "title": "Curso de Python",
    "section": "1.7 Pr√©-requisitos e Ferramentas",
    "text": "1.7 Pr√©-requisitos e Ferramentas\n\n1.7.1 Pr√©-requisitos\n\nFamiliaridade b√°sica com o uso de computadores: Saber navegar em pastas, usar um navegador de internet e instalar programas simples.\nCuriosidade e Vontade de Aprender: A motiva√ß√£o √© seu maior trunfo!\nNenhuma experi√™ncia pr√©via em programa√ß√£o √© exigida. O curso foi desenhado para iniciantes.\n\n\n\n1.7.2 Ferramentas Recomendadas\nPara acompanhar o curso, voc√™ precisar√° de um ambiente Python configurado. Recomendamos fortemente a instala√ß√£o da Distribui√ß√£o Anaconda, que j√° inclui Python, o Jupyter Notebook e as principais bibliotecas que usaremos.\n\nAnaconda: Baixe em anaconda.com/download. Siga as instru√ß√µes de instala√ß√£o para seu sistema operacional.\nJupyter Notebook/JupyterLab: Ambiente interativo ideal para aprender e experimentar com c√≥digo e visualiza√ß√µes. Vem com o Anaconda.\nAlternativas Online (sem instala√ß√£o):\n\nGoogle Colaboratory: Ambiente Jupyter Notebook gratuito na nuvem, oferecido pelo Google.\nJupyterLite (via Jupyter.org): Executa um ambiente JupyterLab diretamente no seu navegador.\nProgramiz Online Compiler: √ötil para testar pequenos trechos de c√≥digo Python rapidamente.\n\nEditor de C√≥digo (Opcional Avan√ßado): Se preferir, pode usar editores como VSCode com a extens√£o Python, mas o Jupyter √© mais indicado para o formato do curso.\n\n\n\n\n\n\n\nDica de Instala√ß√£o\n\n\n\nRecomendamos fortemente o uso do Anaconda, pois ele simplifica a gest√£o das bibliotecas (pacotes) que usaremos ao longo do curso. Se encontrar dificuldades na instala√ß√£o, procure tutoriais espec√≠ficos para seu sistema operacional ou utilize as alternativas online.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "index.html#recursos-adicionais-e-comunidade",
    "href": "index.html#recursos-adicionais-e-comunidade",
    "title": "Curso de Python",
    "section": "1.8 Recursos Adicionais e Comunidade",
    "text": "1.8 Recursos Adicionais e Comunidade\nO aprendizado n√£o termina aqui! Explore estes recursos para aprofundar seus conhecimentos:\n\nDocumenta√ß√£o Oficial:\n\nPython\nNumPy\nPandas\nMatplotlib\nSeaborn\n\nComunidades Online: Stack Overflow, Reddit (r/learnpython, r/datascience), f√≥runs espec√≠ficos.\nPlataformas de Aprendizado: Kaggle Learn, DataCamp, Coursera, edX.\nSites de Apoio (mencionados anteriormente):\n\nPython Academy\nPython Examples\nHashtag Treinamentos (YouTube)\n\n\n\nEstamos muito animados para come√ßar esta jornada de aprendizado com voc√™! Prepare-se para mergulhar no mundo da programa√ß√£o Python e descobrir como os dados podem contar hist√≥rias incr√≠veis. Vamos l√°!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Boas-vindas ao Universo da An√°lise de Dados com Python!</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/01_Fundamentals_of_Python.html",
    "href": "M√≥dulo I/01_Fundamentals_of_Python.html",
    "title": "Primeiros Passos",
    "section": "",
    "text": "Introdu√ß√£o ao Python\nNeste primeiro cap√≠tulo, daremos os passos iniciais no mundo da programa√ß√£o com Python. Vamos entender o que √© essa linguagem, por que ela se tornou t√£o popular (especialmente para an√°lise de dados) e como preparar nosso ambiente para come√ßar a codificar.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/01_Fundamentals_of_Python.html#introdu√ß√£o-ao-python",
    "href": "M√≥dulo I/01_Fundamentals_of_Python.html#introdu√ß√£o-ao-python",
    "title": "Primeiros Passos",
    "section": "",
    "text": "O Que Torna Python Especial?\nPython √© frequentemente descrita como uma linguagem de programa√ß√£o poderosa, vers√°til e, acima de tudo, leg√≠vel. Mas o que isso significa na pr√°tica?\n\nLinguagem Interpretada: Diferente de linguagens compiladas (como C++ ou Java), onde o c√≥digo fonte √© traduzido para c√≥digo de m√°quina antes da execu√ß√£o, o c√≥digo Python √© executado linha por linha por um programa chamado interpretador. Isso facilita o desenvolvimento e o teste, pois voc√™ pode executar pequenos trechos de c√≥digo rapidamente.\nAlto N√≠vel: Python abstrai muitos detalhes complexos do hardware do computador (como gerenciamento de mem√≥ria). Isso permite que voc√™ se concentre na l√≥gica do problema que est√° tentando resolver, em vez de se preocupar com detalhes de baixo n√≠vel.\nTipagem Din√¢mica: Voc√™ n√£o precisa declarar explicitamente o tipo de uma vari√°vel (inteiro, texto, etc.) antes de us√°-la. O Python infere o tipo automaticamente durante a execu√ß√£o. Isso torna o c√≥digo mais conciso, mas exige aten√ß√£o para evitar erros relacionados a tipos inesperados.\nProp√≥sito Geral: Python n√£o se limita a uma √∫nica √°rea. √â usada em desenvolvimento web, automa√ß√£o de tarefas, intelig√™ncia artificial, computa√ß√£o cient√≠fica e, claro, an√°lise e ci√™ncia de dados.\nSintaxe Clara e Leg√≠vel: A sintaxe do Python foi projetada para ser pr√≥xima da linguagem humana, utilizando indenta√ß√£o (espa√ßos no in√≠cio da linha) para definir blocos de c√≥digo, o que for√ßa a escrita de um c√≥digo visualmente organizado.\n\nEssas caracter√≠sticas, combinadas com um vasto ecossistema de bibliotecas (conjuntos de c√≥digo pr√©-escrito para tarefas espec√≠ficas), fazem do Python uma ferramenta excepcional para an√°lise de dados, adotada por gigantes como Google, NASA, Facebook (Meta), Amazon e Spotify.\n\n\nConfigurando o Ambiente: Anaconda e Jupyter Notebook\nPara come√ßar nossa jornada, precisamos instalar o Python e as ferramentas necess√°rias. A maneira mais recomendada para iniciantes em an√°lise de dados √© usar a Distribui√ß√£o Anaconda.\nO que √© Anaconda? √â um pacote que inclui:\n\nO interpretador Python.\nUm gerenciador de pacotes (bibliotecas) chamado conda.\nDiversas bibliotecas cient√≠ficas e de an√°lise de dados pr√©-instaladas (como NumPy, Pandas, Matplotlib).\nFerramentas √∫teis, como o Jupyter Notebook e o JupyterLab.\n\nO que √© Jupyter Notebook? √â uma aplica√ß√£o web interativa que permite criar e compartilhar documentos (chamados notebooks) que cont√™m c√≥digo execut√°vel (como Python), texto formatado (Markdown), equa√ß√µes, visualiza√ß√µes e muito mais. √â um ambiente ideal para aprendizado, experimenta√ß√£o e apresenta√ß√£o de an√°lises de dados.\nPassos para Instala√ß√£o:\n\nDownload: Acesse o site oficial do Anaconda: https://www.anaconda.com/download\nEscolha seu Sistema Operacional: Baixe o instalador apropriado para Windows, macOS ou Linux.\nInstala√ß√£o: Execute o instalador e siga as instru√ß√µes. Geralmente, as op√ß√µes padr√£o s√£o adequadas para iniciantes.\nV√≠deo de Apoio: Se precisar de ajuda visual, este tutorial de instala√ß√£o no YouTube pode ser √∫til.\n\n\n\n\n\n\n\nD√∫vidas na Instala√ß√£o?\n\n\n\nSe encontrar problemas, n√£o hesite em procurar tutoriais mais espec√≠ficos para sua vers√£o do sistema operacional ou entrar em contato:\n\nEmail do Instrutor: breno.silva@icen.ufpa.br\n\n\n\nAp√≥s a instala√ß√£o, voc√™ poder√° iniciar o Jupyter Notebook (geralmente atrav√©s do Anaconda Navigator ou pelo terminal/prompt de comando digitando jupyter notebook).",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/01_Fundamentals_of_Python.html#sintaxe-b√°sica-a-gram√°tica-do-python",
    "href": "M√≥dulo I/01_Fundamentals_of_Python.html#sintaxe-b√°sica-a-gram√°tica-do-python",
    "title": "Primeiros Passos",
    "section": "Sintaxe B√°sica: A Gram√°tica do Python",
    "text": "Sintaxe B√°sica: A Gram√°tica do Python\nToda linguagem tem suas regras. Em Python, a sintaxe define como escrevemos comandos v√°lidos que o interpretador possa entender. Vamos come√ßar com o b√°sico.\n\nExibindo Informa√ß√µes: A Fun√ß√£o print()\nA primeira fun√ß√£o que a maioria dos programadores aprende √© a print(). Sua finalidade √© exibir informa√ß√µes (texto, n√∫meros, resultados de c√°lculos) na tela (console ou sa√≠da do notebook).\nO famoso ‚ÄúHello, World!‚Äù:\nprint(\"Hello, World!\")\nComo funciona?\n\nprint √© o nome da fun√ß√£o.\nOs par√™nteses () s√£o usados para chamar a fun√ß√£o e passar informa√ß√µes para ela.\nO que est√° dentro dos par√™nteses √© chamado de argumento. Neste caso, o argumento √© o texto (string) \"Hello, World!\".\nStrings em Python s√£o definidas usando aspas simples ('...') ou duplas (\"...\").\n\n\nErros Comuns com print()\n√â normal cometer erros ao aprender. Vejamos alguns deslizes comuns com print():\n\nNome Incorreto (Case-Sensitive): Python diferencia mai√∫sculas de min√∫sculas.\n# Exemplo de C√≥digo Incorreto\nPrint(\"Ol√°\")\nErro Gerado: NameError: name 'Print' is not defined (O Python n√£o reconhece ‚ÄòPrint‚Äô com ‚ÄòP‚Äô mai√∫sculo).\nFaltando Aspas: Textos (strings) precisam estar entre aspas.\n# Exemplo de C√≥digo Incorreto\nprint(Ol√°)\nErro Gerado: SyntaxError: invalid syntax (O Python n√£o entende ‚ÄòOl√°‚Äô como um comando ou vari√°vel v√°lida sem aspas).\nAspas Incompletas: Abrir aspas e n√£o fechar (ou vice-versa).\n# Exemplo de C√≥digo Incorreto\nprint(\"Ol√°)\nErro Gerado: SyntaxError: unterminated string literal (A string n√£o foi finalizada corretamente).\nMisturar Tipos de Aspas: Come√ßar com simples e terminar com duplas (ou vice-versa).\n# Exemplo de C√≥digo Incorreto\nprint('Ol√°\")\nErro Gerado: SyntaxError: unterminated string literal.\n\n\n\n\n\n\n\nAten√ß√£o √† Sintaxe!\n\n\n\nErros de sintaxe s√£o como erros de gram√°tica. O interpretador Python precisa que as regras sejam seguidas para entender suas instru√ß√µes. Prestar aten√ß√£o aos detalhes (mai√∫sculas/min√∫sculas, par√™nteses, aspas) √© fundamental.\n\n\nUsando Aspas Dentro de Strings:\nSe precisar incluir aspas no seu texto, alterne os tipos de aspas:\nprint('Ele disse: \"Python √© incr√≠vel!\"')\nprint(\"O livro se chama 'O Guia do Mochileiro das Gal√°xias'.\")\nQuebras de Linha:\nPara inserir uma quebra de linha dentro de uma string, use o caractere especial \\n (barra invertida seguida de ‚Äòn‚Äô):\nprint(\"Linha 1\\nLinha 2\\nLinha 3\")\n\n\n\nOperadores Matem√°ticos: Calculando com Python\nPython pode ser usado como uma calculadora poderosa. Ele suporta os operadores matem√°ticos b√°sicos e alguns mais avan√ßados. Observe a Tabela¬†1.\n\n\n\n\nTabela¬†1: Operadores Matem√°ticos.\n\n\n\n\n\n\nOperador\nDescri√ß√£o\nExemplo\nResultado\n\n\n\n\n+\nAdi√ß√£o\n5 + 3\n8\n\n\n-\nSubtra√ß√£o\n5 - 3\n2\n\n\n*\nMultiplica√ß√£o\n5 * 3\n15\n\n\n/\nDivis√£o (float)\n10 / 3\n3.3333\n\n\n//\nDivis√£o (int)\n10 // 3\n3\n\n\n%\nM√≥dulo (Resto)\n10 % 3\n1\n\n\n**\nExponencia√ß√£o\n2 ** 3\n8\n\n\n\n\n\n\n\n\nExemplos:\n\n\nC√≥digo\n# Adi√ß√£o e Subtra√ß√£o\nprint(10 + 5)  \n\n\n15\n\n\nC√≥digo\nprint(10 - 5.5)\n\n\n4.5\n\n\nC√≥digo\n# Multiplica√ß√£o e Divis√£o\nprint(4 * 7)\n\n\n28\n\n\nC√≥digo\nprint(15 / 4)   # Divis√£o resulta em float\n\n\n3.75\n\n\nC√≥digo\n# Divis√£o Inteira (descarta a parte decimal)\nprint(15 // 4)  \n\n\n3\n\n\nC√≥digo\n# M√≥dulo (resto da divis√£o inteira)\nprint(15 % 4)   # 15 dividido por 4 √© 3, com resto 3\n\n\n3\n\n\nC√≥digo\n# Exponencia√ß√£o (pot√™ncia)\nprint(3 ** 4)   # 3 elevado √† 4¬™ pot√™ncia\n\n\n81\n\n\n\nAssim como na matem√°tica, tentar dividir por zero em Python gera um erro:\n10 / 0\nErro Gerado: ZeroDivisionError: division by zero\n\nCalculando Raiz Quadrada:\nPodemos usar exponencia√ß√£o com expoente fracion√°rio:\n\n\nC√≥digo\nprint(81 ** 0.5) # Raiz quadrada de 81\n\n\n9.0\n\n\nNo entanto, a forma mais comum e recomendada √© usar a fun√ß√£o sqrt() da biblioteca (m√≥dulo) math:\n\n\nC√≥digo\nimport math # Importa a biblioteca math\n\nprint(math.sqrt(81))\n\n\n9.0\n\n\n\n\n\n\n\n\nImportando M√≥dulos\n\n\n\nO comando import math torna todas as fun√ß√µes e constantes definidas no m√≥dulo math dispon√≠veis para uso no seu c√≥digo. Veremos mais sobre m√≥dulos e bibliotecas posteriormente.\n\n\n\n\nExpress√µes Num√©ricas e Preced√™ncia\nPodemos combinar m√∫ltiplos operadores em uma √∫nica express√£o:\n\n\nC√≥digo\n3 + 4 * 2 - 5 / 2 ** 2\n\n\n9.75\n\n\nQual a ordem de execu√ß√£o? Python segue a ordem de preced√™ncia padr√£o da matem√°tica, conhecida como PEMDAS:\n\nPar√™nteses () - Opera√ß√µes dentro de par√™nteses s√£o executadas primeiro.\nExponencia√ß√£o **\nMultiplica√ß√£o *, Divis√£o /, Divis√£o Inteira //, M√≥dulo % (executados da esquerda para a direita se tiverem a mesma preced√™ncia).\nAdi√ß√£o +, Subtra√ß√£o - (executados da esquerda para a direita se tiverem a mesma preced√™ncia).\n\nNo exemplo 3 + 4 * 2 - 5 / 2 ** 2:\n\n2 ** 2 √© 4\n4 * 2 √© 8\n5 / 4 √© 1.25\n3 + 8 √© 11\n11 - 1.25 √© 9.75\n\nUse par√™nteses para controlar a ordem quando necess√°rio:\n\n\nC√≥digo\n(3 + 4) * (2 - 5) / (2 ** 2)\n\n\n-5.25\n\n\nC√≥digo\n# (7) * (-3) / (4) = -21 / 4 = -5.25\n\n\n\nUma Nota Sobre N√∫meros Decimais (Ponto Flutuante)\nVoc√™ pode notar resultados ligeiramente inesperados ao trabalhar com n√∫meros decimais (chamados floats em Python):\n\n\nC√≥digo\nprint(0.1 + 0.2)\n\n\n0.30000000000000004\n\n\nPor que 0.30000000000000004 e n√£o 0.3? A maioria dos computadores utiliza a representa√ß√£o bin√°ria (base 2) para armazenar n√∫meros. O problema √© que muitas fra√ß√µes decimais (base 10), como 0.1, n√£o podem ser representadas exatamente em bin√°rio. Isso ocorre porque a representa√ß√£o bin√°ria tem um n√∫mero finito de d√≠gitos, assim como ocorre na representa√ß√£o decimal. Por exemplo, ao representar 1/3 em decimal, obt√©m-se uma repeti√ß√£o infinita: 0.3333 \\ldots Da mesma forma, a convers√£o de 0.1 para bin√°rio gera uma fra√ß√£o peri√≥dica infinita.\nOs computadores modernos seguem o padr√£o IEEE 754 para representar n√∫meros de ponto flutuante. Esse padr√£o define como os n√∫meros s√£o armazenados na mem√≥ria, incluindo a precis√£o. Em Python, os n√∫meros de ponto flutuante geralmente utilizam precis√£o dupla do IEEE 754, que oferece 53 bits de precis√£o. Quando um n√∫mero como 0.1 √© digitado, o computador encontra a fra√ß√£o bin√°ria mais pr√≥xima poss√≠vel dentro desse limite de precis√£o. O resultado √© um valor muito pr√≥ximo de 0.1, mas n√£o exatamente igual.\n\n\n\n\n\n\nLidando com Imprecis√µes de Float\n\n\n\nPara a maioria das aplica√ß√µes em an√°lise de dados, essa pequena imprecis√£o n√£o √© um problema. Ao exibir resultados, voc√™ pode arredondar os n√∫meros usando a fun√ß√£o round():\n\n\nC√≥digo\nprint(round(0.1 + 0.2, 2)) # Arredonda para 2 casas decimais\n\n\n0.3\n\n\nPara c√°lculos financeiros ou cient√≠ficos que exigem alta precis√£o, Python oferece m√≥dulos como Decimal.\n\n\n\n\n\nCompara√ß√µes e Operadores L√≥gicos\nFrequentemente, precisamos comparar valores em nossos programas. Python oferece operadores de compara√ß√£o que retornam um valor booleano: True (Verdadeiro) ou False (Falso).\n\n\n\n\nTabela¬†2: Operadores de Compara√ß√£o.\n\n\n\n\n\n\nOperador\nDescri√ß√£o\nExemplo\nResultado\n\n\n\n\n&lt;\nMenor que\n5 &lt; 10\nTrue\n\n\n&gt;\nMaior que\n5 &gt; 10\nFalse\n\n\n&lt;=\nMenor ou igual a\n10 &lt;= 10\nTrue\n\n\n&gt;=\nMaior ou igual a\n10 &gt;= 10\nTrue\n\n\n==\nIgual a\n5 == 5\nTrue\n\n\n!=\nDiferente de\n5 != 10\nTrue\n\n\n\n\n\n\n\n\nExemplos:\n\n\nC√≥digo\n# Idade M√≠nima igual a 18\n# Idade do Usu√°rio igual a 25\n\nprint(\"Usu√°rio √© maior de idade?\", 25 &gt;= 18)\n\n\nUsu√°rio √© maior de idade? True\n\n\nC√≥digo\nprint(\"As idades s√£o iguais?\", 25 &gt;= 18)\n\n\nAs idades s√£o iguais? True\n\n\nC√≥digo\nprint(\"As idades s√£o diferentes?\", 25 &gt;= 18)\n\n\nAs idades s√£o diferentes? True\n\n\nOperadores L√≥gicos:\nPodemos combinar m√∫ltiplas compara√ß√µes usando operadores l√≥gicos:\n\n\n\n\nTabela¬†3: Operadores L√≥gicos.\n\n\n\n\n\n\n\n\n\n\n\n\nOperador\nResultado √© True se\nExemplo\nResultado\n\n\n\n\nand\nAmbas as condi√ß√µes forem True\n(5 &lt; 10) and (10 &gt; 3)\nTrue\n\n\nor\nPelo menos uma das condi√ß√µes for True\n(5 &gt; 10) or (10 == 10)\nTrue\n\n\nnot\nA condi√ß√£o seguinte for False (inverte o valor l√≥gico)\nnot (5 == 10)\nTrue\n\n\n\n\n\n\n\n\nExemplos:\n\n\nC√≥digo\n# Tem Ingresso igual a True\n# √â maior de idade igual a False\n\n# Pode entrar na festa? (Precisa ter ingresso E ser maior de idade)\nprint(\"Pode entrar na festa?\", True and False)\n\n\nPode entrar na festa? False\n\n\nC√≥digo\n# Pode receber desconto? (Precisa ter ingresso OU ser maior de idade - exemplo hipot√©tico)\nprint(\"Pode receber desconto?\", True or False)\n\n\nPode receber desconto? True\n\n\nC√≥digo\n# N√£o tem ingresso?\nprint(\"N√£o tem ingresso?\", not True)\n\n\nN√£o tem ingresso? False\n\n\n\n\nC√≥digo\nprint((1 and 4) &lt; 3)\n\n\nFalse\n\n\nC√≥digo\nprint((1 or 4) &lt; 3)\n\n\nTrue\n\n\nC√≥digo\nprint((1 and 2 and 2.99) &lt; 3)\n\n\nTrue\n\n\nC√≥digo\nprint((1 or 2 or 2.99) &gt; 3)\n\n\nFalse\n\n\n\n\nC√≥digo\nprint((5 &gt;= 4.99) and (10 &lt;= 10.01))\n\n\nTrue\n\n\nC√≥digo\nprint((5 &gt;= 4.99) and (10 == 10.01))\n\n\nFalse\n\n\n\n\nC√≥digo\nprint((5 &gt;= 4.99) or (10 &lt;= 10.01))\n\n\nTrue\n\n\nC√≥digo\nprint((5 &gt;= 4.99) or (10 == 10.01))\n\n\nTrue\n\n\n\n\nC√≥digo\nprint(1 == 1)\n\n\nTrue\n\n\nC√≥digo\nprint(not 1 == 1)\n\n\nFalse\n\n\nC√≥digo\nprint(not not 1 == 1)\n\n\nTrue\n\n\nC√≥digo\nprint(not not not 1 == 1)\n\n\nFalse\n\n\nPreced√™ncia dos Operadores L√≥gicos:\nAssim como os operadores matem√°ticos, os l√≥gicos tamb√©m t√™m uma ordem de avalia√ß√£o:\n\nnot √© avaliado primeiro.\nand √© avaliado em seguida.\nor √© avaliado por √∫ltimo.\n\nExemplo:\n\n\nC√≥digo\nprint(not False and True or False)\n\n\nTrue\n\n\nC√≥digo\n# 1. not False -&gt; True\n# 2. True and True -&gt; True\n# 3. True or False -&gt; True\n\n\nUse par√™nteses () para garantir a ordem desejada quando a express√£o for complexa.\n\n\nVari√°veis: Armazenando Informa√ß√µes\nUma vari√°vel funciona como um r√≥tulo ou um nome que damos a um local na mem√≥ria do computador onde um valor (um objeto) est√° armazenado. Isso nos permite referenciar e reutilizar valores facilmente.\nO processo de criar uma vari√°vel e associar um valor a ela √© chamado de atribui√ß√£o, e usamos o sinal de igual (=) para isso.\n\n\nC√≥digo\n# Atribui√ß√£o\nquantidade_alunos = 19\npreco_produto = 34.99\nmensagem_boas_vindas = \"Ol√°, estudante!\"\ncurso_ativo = True\n\n# Usando as vari√°veis\nprint(quantidade_alunos)\n\n\n19\n\n\nC√≥digo\nprint(mensagem_boas_vindas)\n\n\nOl√°, estudante!\n\n\n\nRegras e Conven√ß√µes para Nomes de Vari√°veis\nEscolher nomes significativos torna o c√≥digo muito mais f√°cil de entender.\n\nRegras (Obrigat√≥rias):\n\nNomes devem come√ßar com uma letra (a-z, A-Z) ou underscore (_).\nO restante do nome pode conter letras, n√∫meros (0-9) e underscores.\nNomes s√£o case-sensitive (idade √© diferente de Idade).\nN√£o podem ser iguais a palavras-chave reservadas do Python (como if, else, for, while, def, class, import, True, False, None, etc.).\n\nConven√ß√µes (Boas Pr√°ticas - PEP 8):\n\nUse nomes em min√∫sculas.\nSepare palavras com underscores (estilo snake_case). Ex: taxa_juros, nome_cliente.\nEscolha nomes descritivos que indiquem o prop√≥sito da vari√°vel.\n\nExemplos V√°lidos: idade, nome_completo, total_vendas, _variavel_privada (conven√ß√£o)\nExemplos Inv√°lidos:\n# Errado: come√ßa com n√∫mero\n1_lugar = \"Ouro\"\n\n# Errado: cont√©m caractere especial (@)\nemail@cliente = \"teste@exemplo.com\"\n\n# Errado: usa palavra-chave (def)\ndef = \"defini√ß√£o\"\nTentar usar um nome inv√°lido ou uma palavra-chave resultar√° em SyntaxError. Tentar usar uma vari√°vel que n√£o foi definida (atribu√≠da) ainda resultar√° em NameError.\n\n\n\nAtribui√ß√£o com Express√µes e Atualiza√ß√£o\nPodemos atribuir o resultado de uma express√£o a uma vari√°vel:\n\n\nC√≥digo\npreco_unitario = 50\nquantidade = 5\ndesconto = 0.10\n\nvalor_bruto = preco_unitario * quantidade\nvalor_desconto = valor_bruto * desconto\nvalor_final = valor_bruto - valor_desconto\n\nprint(\"Valor final:\", valor_final)\n\n\nValor final: 225.0\n\n\nPara atualizar o valor de uma vari√°vel existente, podemos usar a pr√≥pria vari√°vel na express√£o √† direita do =:\n\n\nC√≥digo\ncontador = 0\nprint(\"Contador inicial:\", contador)\n\n\nContador inicial: 0\n\n\nC√≥digo\ncontador = contador + 1 # Incrementa o valor\nprint(\"Contador ap√≥s incremento:\", contador)\n\n\nContador ap√≥s incremento: 1\n\n\nPython oferece operadores de atribui√ß√£o compostos como atalhos:\n\n+= (Adi√ß√£o): x += 1 √© o mesmo que x = x + 1\n-= (Subtra√ß√£o): x -= 5 √© o mesmo que x = x - 5\n*= (Multiplica√ß√£o): x *= 2 √© o mesmo que x = x * 2\n/= (Divis√£o): x /= 4 √© o mesmo que x = x / 4\n//= , %= , **= (an√°logos para divis√£o inteira, m√≥dulo e exponencia√ß√£o)\n\n\n\nC√≥digo\nnum = 10\nnum += 3  # num agora √© 13\nprint(num)\n\n\n13\n\n\nC√≥digo\nnum *= 2  # num agora √© 26\nprint(num)\n\n\n26\n\n\n\n\nAtribui√ß√£o M√∫ltipla\nPython permite atribuir valores a m√∫ltiplas vari√°veis na mesma linha:\n\n\nC√≥digo\nx, y, z = 10, 20, \"teste\"\nprint(x)\n\n\n10\n\n\nC√≥digo\nprint(y)\n\n\n20\n\n\nC√≥digo\nprint(z)\n\n\nteste\n\n\nN√£o parece algo t√£o interessante, n√£o √©? Vamos a um exemplo. Imagine um problema que envolve duas vari√°veis a e b. O Python permite a atribui√ß√£o m√∫ltipla, o que pode ser √∫til para trocar valores entre vari√°veis de forma eficiente.\n\n\nC√≥digo\na, b = 1, 200\nprint(a, b)  # Sa√≠da: 1 200\n\n\n1 200\n\n\nAgora, pense como poderiamos trocar os valores dessas vari√°veis. Pensou? Em algum momento deve ter passado pela sua cabe√ßa a seguinte l√≥gica:\n\n\nC√≥digo\na = b # Perde-se o valor original de a (1)\nprint(a)\n\n\n200\n\n\nC√≥digo\nb = a # Como perdeu-se a, `b vai continuar com seu valor original (200)\nprint(b)\n\n\n200\n\n\nEm outras linguagens, para trocar valores entre duas vari√°veis, seria necess√°rio usar uma vari√°vel auxiliar:\n\n\nC√≥digo\na, b = 1, 200\nprint(a, b)  # Sa√≠da: 1 200\n\n\n1 200\n\n\nC√≥digo\naux = a\na = b\nb = aux\nprint(a, b)  # Agora a = 200 e b = 1\n\n\n200 1\n\n\nNo entanto, em Python, a troca pode ser feita de forma mais elegante usando atribui√ß√£o m√∫ltipla:\n\n\nC√≥digo\na, b = 1, 200\nprint(a, b)  # Sa√≠da: 1 200\n\n\n1 200\n\n\nC√≥digo\na, b = b, a\nprint(a, b)  # Agora a = 200 e b = 1\n\n\n200 1\n\n\nNote que essa abordagem pode ser expandida para m√∫ltiplas vari√°veis.\n\n\n\nTipos de Objetos Fundamentais\nJ√° vimos alguns tipos de dados (valores) que podemos armazenar em vari√°veis. Cada valor em Python √© um objeto, e cada objeto pertence a um tipo (ou classe). O tipo define quais opera√ß√µes podem ser realizadas com aquele objeto.\nPodemos verificar o tipo de um objeto usando a fun√ß√£o type():\n\n\nC√≥digo\nnumero_inteiro = 100\nnumero_decimal = 3.14159\ntexto = \"An√°lise de Dados\"\nlogico = False\n\nprint(type(numero_inteiro))\n\n\n&lt;class 'int'&gt;\n\n\nC√≥digo\nprint(type(numero_decimal))\n\n\n&lt;class 'float'&gt;\n\n\nC√≥digo\nprint(type(texto))\n\n\n&lt;class 'str'&gt;\n\n\nC√≥digo\nprint(type(logico))\n\n\n&lt;class 'bool'&gt;\n\n\nPrincipais Tipos Primitivos:\n\nint (Inteiro): N√∫meros inteiros, positivos ou negativos, sem parte decimal (ex: -10, 0, 42).\nfloat (Ponto Flutuante): N√∫meros reais, que possuem uma parte decimal (ex: -3.14, 0.0, 99.99).\nstr (String): Sequ√™ncias de caracteres (texto), delimitadas por aspas simples ou duplas (ex: 'Python', \"Ol√°, mundo!\").\nbool (Booleano): Representa valores l√≥gicos de Verdadeiro (True) ou Falso (False).\nNoneType (None): Um tipo especial que tem apenas um valor: None. Usado para representar a aus√™ncia de valor.\n\nAl√©m desses, Python possui tipos de dados mais complexos para agrupar informa√ß√µes, que veremos em detalhes mais adiante:\n\nlist (Lista): Cole√ß√£o ordenada e mut√°vel de itens.\ntuple (Tupla): Cole√ß√£o ordenada e imut√°vel de itens.\ndict (Dicion√°rio): Cole√ß√£o n√£o ordenada de pares chave-valor.\nset (Conjunto): Cole√ß√£o n√£o ordenada de itens √∫nicos.\n\n\n\nM√©todos e Atributos\nEm Python, os conceitos de m√©todos e atributos s√£o fundamentais na programa√ß√£o orientada a objetos (POO). Eles definem as caracter√≠sticas e comportamentos dos objetos.\n\nM√©todos\n\nDefini√ß√£o:\n\nM√©todos s√£o fun√ß√µes definidas dentro de um objeto. Eles definem os comportamentos ou a√ß√µes que um objeto pode realizar.\nPense neles como as ‚Äúa√ß√µes‚Äù que um objeto pode executar.\n\nExemplo:\n\nEm um objeto carro, m√©todos poderiam ser ligar(), acelerar() e frear().\n\nAcesso:\n\nChamamos m√©todos usando a sintaxe objeto.m√©todo().\n\n\n\n\nAtributos\n\nDefini√ß√£o:\n\nAtributos s√£o vari√°veis que armazenam dados dentro de um objeto. Eles representam as caracter√≠sticas ou propriedades de um objeto.\nPense neles como as ‚Äúinforma√ß√µes‚Äù (sobre o objeto por isso caracter√≠sticas) que um objeto carrega consigo.\n\nExemplo:\n\nEm um objeto carro, atributos poderiam ser cor, marca, modelo e ano.\n\nAcesso:\n\nAcessamos atributos usando a sintaxe objeto.atributo.\n\n\n\n\nRela√ß√£o entre M√©todos e Atributos\nM√©todos frequentemente manipulam os atributos de um objeto. Por exemplo, um m√©todo acelerar() pode modificar o atributo velocidade de um objeto carro.\nEm resumo:\n\nAtributos s√£o as caracter√≠sticas que um objeto possui.\nM√©todos s√£o as a√ß√µes que um objeto pode realizar.\n\nEssa distin√ß√£o permite criar objetos que representam entidades do mundo real com suas pr√≥prias caracter√≠sticas e comportamentos.\n\n\n\nObtendo Ajuda e Explorando\nPython oferece ferramentas para ajudar voc√™ a aprender e explorar:\n\nhelp(): Fornece documenta√ß√£o sobre fun√ß√µes, m√≥dulos ou tipos.\n# help(print) # Descomente para ver a ajuda da fun√ß√£o print\n# help(str)   # Descomente para ver a ajuda sobre o tipo string\n# help(math)  # Descomente para ver a ajuda sobre o m√≥dulo math (precisa importar antes)\ndir(): Lista os nomes (atributos e m√©todos) definidos por um objeto ou m√≥dulo.\n# print(dir(str)) # Lista m√©todos e atributos de strings\n# print(dir(math)) # Lista fun√ß√µes e constantes do m√≥dulo math\ntype(): Como j√° vimos, retorna o tipo de um objeto.\n\nNo ambiente Jupyter Notebook, voc√™ tamb√©m pode usar:\n\n? ap√≥s um nome de fun√ß√£o/objeto para ver sua documenta√ß√£o (ex: print? ou frase.upper?).\n?? ap√≥s um nome de fun√ß√£o/objeto para tentar ver o c√≥digo fonte (se dispon√≠vel).\nCompletar com Tab: Digite o in√≠cio de um nome de vari√°vel ou m√©todo e pressione Tab para ver sugest√µes.\n\n\nEste cap√≠tulo cobriu os fundamentos essenciais para come√ßar a programar em Python. Nos pr√≥ximos cap√≠tulos, construiremos sobre essa base para explorar estruturas de dados mais complexas e as ferramentas espec√≠ficas para an√°lise de dados.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/02_Data_Structure.html",
    "href": "M√≥dulo I/02_Data_Structure.html",
    "title": "Objetos no Python",
    "section": "",
    "text": "Introdu√ß√£o\nAo longo do curso, j√° mencionamos alguns tipos de objetos enquanto explor√°vamos conceitos b√°sicos de Python. Voc√™ provavelmente j√° viu vari√°veis sendo criadas e usadas, e at√© notou que diferentes valores podem ter diferentes tipos. Agora, chegou o momento de entender melhor os objetos b√°sicos do Python e como eles funcionam.\nNeste cap√≠tulo, vamos explorar os principais tipos de objetos que o Python nos oferece, como n√∫meros, strings, listas e dicion√°rios. Al√©m disso, veremos como identificar o tipo de um objeto, buscar ajuda sobre fun√ß√µes e entender melhor as vari√°veis dispon√≠veis no c√≥digo.\nCom essa nova organiza√ß√£o do curso, o conte√∫do foi dividido em cap√≠tulos menores para facilitar o aprendizado. Isso evita que tudo seja ensinado de uma vez, tornando a experi√™ncia mais din√¢mica e leve. Ent√£o, vamos come√ßar nossa jornada pelos objetos do Python! üöÄ",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/02_Data_Structure.html#strings",
    "href": "M√≥dulo I/02_Data_Structure.html#strings",
    "title": "Objetos no Python",
    "section": "Strings",
    "text": "Strings\nTamb√©m chamada de sequ√™ncia de caracteres, textos ou dados alfanum√©ricos, uma string √© um tipo de dado que armazena uma sequ√™ncia de caracteres. Em Python, pode ser definida com aspas simples ('), duplas (\") ou triplas (''' ou \"\"\").\n\n\nC√≥digo\n\"Texto com acentos e cedilhas: hoje √© dia de ca√ßa!\"\n\n\n'Texto com acentos e cedilhas: hoje √© dia de ca√ßa!'\n\n\n\n\nC√≥digo\n# As strings aceitam aspas simples tamb√©m\nnome = 'Silvio Santos'\nnome\n\n\n'Silvio Santos'\n\n\n\nOpera√ß√µes com Strings\nPodemos realizar diversas opera√ß√µes matem√°ticas e manipula√ß√µes em strings.\n\n\nC√≥digo\n# Multiplica√ß√£o repete a string\nnome * 3\n\n\n'Silvio SantosSilvio SantosSilvio Santos'\n\n\n[Input]:  nome * 3.14\n[Output]: TypeError: can't multiply sequence by non-int of type 'float'\n\n\nC√≥digo\n# Concatena√ß√£o de strings\ncanto1 = 'vem a√≠, '\ncanto2 = 'l√° '\nnome + ' ' + canto1 + canto2 * 6 + '!!'\n\n\n'Silvio Santos vem a√≠, l√° l√° l√° l√° l√° l√° !!'\n\n\n\n\nStrings Multilinhas\nPara definir strings que ocupam m√∫ltiplas linhas, utilize tr√™s aspas (''' ou \"\"\"):\n\n\nC√≥digo\nstr_grande = '''Aqui consigo inserir um text√£o com v√°rias linhas.\nPosso iniciar em uma...\n... continuar em outra...\n... e seguir quantas precisar.'''\n\nstr_grande\n\n\n'Aqui consigo inserir um text√£o com v√°rias linhas.\\nPosso iniciar em uma...\\n... continuar em outra...\\n... e seguir quantas precisar.'\n\n\n\n\nC√≥digo\nprint(str_grande)\n\n\nAqui consigo inserir um text√£o com v√°rias linhas.\nPosso iniciar em uma...\n... continuar em outra...\n... e seguir quantas precisar.\n\n\nCaso seja necess√°rio incluir aspas dentro da string, podemos alternar entre aspas simples e duplas:\n\n\nC√≥digo\nagua = \"Me d√° um copo d'√°gua\"\nagua\n\n\n\"Me d√° um copo d'√°gua\"\n\n\nTamb√©m podemos usar todas as aspas ao mesmo tempo:\n\n\nC√≥digo\ntodas_as_aspas = \"\"\"Essa √© uma string que tem:\n- aspas 'simples'\n- aspas \"duplas\"\n- aspas '''triplas'''\nLegal, n√©?\"\"\"\n                    \nprint(todas_as_aspas)\n\n\nEssa √© uma string que tem:\n- aspas 'simples'\n- aspas \"duplas\"\n- aspas '''triplas'''\nLegal, n√©?\n\n\n\n\nTamanho de uma String\nA fun√ß√£o embutida len() nos permite obter o n√∫mero de caracteres de uma string, incluindo espa√ßos e pontua√ß√£o:\n\n\nC√≥digo\nlen('Abracadabra')\n\n\n11\n\n\n\n\nC√≥digo\nfrase = 'Faz um pull request l√°'\nlen(frase)\n\n\n22\n\n\n\n\nC√≥digo\npalavra = \"Python\"\nlen(palavra)\n\n\n6\n\n\n\n\nManipula√ß√£o de Strings\n\nIndexa√ß√£o\nCada caractere em uma string possui um √≠ndice, come√ßando em 0 para o primeiro elemento e indo at√© len(string) - 1 para o √∫ltimo elemento ou -1.\n\n√çndices negativos percorrem de tr√°s para frente\n\nPara um melhor entendimento inicial, considere a vari√°vel criada na subse√ß√£o anterir:palavra. Partindo da defini√ß√£o acima, podemos afirmar que os √≠ndices da vari√°vel palavra segue o formato:\n\n\n\nP\ny\nt\nh\no\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n-6\n-5\n-4\n-3\n-2\n-1\n\n\n\nVejamos alguns exemplos:\n\n\nC√≥digo\n# Primeiro caractere\nprint(palavra[0])\n\n\nP\n\n\nC√≥digo\nprint(palavra[-6])\n\n\nP\n\n\n\n\nC√≥digo\n# Primeiro caractere\nprint(palavra[5])\n\n\nn\n\n\nC√≥digo\nprint(palavra[-1])\n\n\nn\n\n\n\n\nFatiamento\nFatiamento (slincing) √© a capacidade de extrair partes de uma string utilizando inicio:fim - 1:passo.\n\n\nC√≥digo\n# Guardando um objeto do tipo str na vari√°vel frase\nfrase = \"A programa√ß√£o em \" + palavra + \" √© diferenciada!\"\nfrase\n\n\n'A programa√ß√£o em Python √© diferenciada!'\n\n\n\n\nC√≥digo\n# Comprimento da vari√°vel frase\nnStr = len(frase)\nnStr\n\n\n39\n\n\n\n\nC√≥digo\n# Obtendo a frase completa usando fatiamento\nprint(frase[:nStr - 1])\n\n\nA programa√ß√£o em Python √© diferenciada\n\n\nC√≥digo\nprint(frase[-nStr:])\n\n\nA programa√ß√£o em Python √© diferenciada!\n\n\n\n\nC√≥digo\n# Obtendo a frase de dois em dois caractere\nprint(frase[:nStr - 1:2])\n\n\nAporm√ßoe yhn√©dfrnid\n\n\nC√≥digo\nprint(frase[-nStr::2])\n\n\nAporm√ßoe yhn√©dfrnid!\n\n\n\n\nC√≥digo\n# Obtendo apenas 'A programa√ß√£o'\nprint(frase[:14])\n\n\nA programa√ß√£o \n\n\nC√≥digo\nprint(frase[:-25])\n\n\nA programa√ß√£o \n\n\n\n\nC√≥digo\n# Obtendo o que h√° depois de 'A programa√ß√£o'\nprint(frase[14:])\n\n\nem Python √© diferenciada!\n\n\nC√≥digo\nprint(frase[-25:])\n\n\nem Python √© diferenciada!\n\n\n\n\nC√≥digo\n# Obtendo toda a frase de tr√°s para frente\nprint(frase[::-1])\n\n\n!adaicnerefid √© nohtyP me o√£√ßamargorp A\n\n\n\nNota: Omitir o primeiro √≠ndice (start) ou o segundo √≠ndice (stop) significa, respectivamente, come√ßar desde o come√ßo ou terminar no fim.\n\nResumindo: para fazer uma fatia de nossa string, precisamos saber de onde come√ßa, at√© onde vai e o tamanho do passo.\nfati√°vel[come√ßo : fim : passo]\n\nAten√ß√£o para o uso de indexa√ß√£o e fatiamento\nAs fatias incluem o √≠ndice do primeiro elemento e n√£o incluem o elemento do √≠ndice final. Por isso que frase[0:-1] perde o √∫ltimo elemento.\nCaso o fim da fatia seja antes do come√ßo, obtemos um resultado vazio:\n\n\nC√≥digo\nfrase[59:105]\n\n\n''\n\n\nO que acontece com uma fatia que est√° fora da string?\n\n\nC√≥digo\nfrase[123:345]\n\n\n''\n\n\nE se o fim da fatia for superior ao comprimento da string? Sem problemas, o Python pecorrer a string at√© o onde der:\n\n\nC√≥digo\nfrase[8:123456789]\n\n\n'ma√ß√£o em Python √© diferenciada!'\n\n\nMas um √≠ndice fora do intervalo em acesso direto gera erro:\n[Input]  : frase[123456789]\n[Output] : IndexError: string index out of range\nQuando usamos passos negativos, a fatia come√ßa no fim e termina no come√ßo e √© percorrida ao contr√°rio. Ou seja, invertemos a ordem. Mas tome cuidado:\n\n\nC√≥digo\n\"Python\"[2:6]\n\n\n'thon'\n\n\n\n\nC√≥digo\n\"Python\"[2:6:-1]\n\n\n''\n\n\n\n\nC√≥digo\n\"Python\"[6:2]\n\n\n''\n\n\n\n\nC√≥digo\n\"Python\"[6:2:-1]\n\n\n'noh'\n\n\n\n\"Python\"[6:2]: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© positivo (default). Nesse caso, o resultado √© uma string vazia, pois o slicing avan√ßa para a direita, mas o fim est√° √† esquerda.\n\"Python\"[2:6:-1]: O √≠ndice de in√≠cio (2) √© menor que o √≠ndice de fim (6), mas o passo √© negativo (-1). O slicing tenta avan√ßar para a esquerda, mas o fim est√° √† direita. Novamente, o resultado √© uma string vazia.\n\"Python\"[6:2:-1]: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© negativo (-1). O slicing avan√ßa para a esquerda, come√ßando do √≠ndice 6 (‚Äòn‚Äô) at√© o √≠ndice 2 (‚Äòt‚Äô), excluindo-o. Isso resulta na string ‚Äúnoh‚Äù.\n\n\n\n\n\nFormata√ß√£o de Strings\nPodemos formatar strings utilizando f-strings, .format() ou %:\n\n\nC√≥digo\nnome = \"Breno\"\nidade = 21\n\nprint(f\"Ol√°, meu nome √© {nome} e tenho {idade} anos.\")           # f-strings\n\n\nOl√°, meu nome √© Breno e tenho 21 anos.\n\n\nC√≥digo\nprint(\"Ol√°, meu nome √© {} e tenho {} anos.\".format(nome, idade)) # format()\n\n\nOl√°, meu nome √© Breno e tenho 21 anos.\n\n\nC√≥digo\nprint(\"Ol√°, meu nome √© %s e tenho %d anos.\" % (nome, idade))     # Estilo antigo\n\n\nOl√°, meu nome √© Breno e tenho 21 anos.\n\n\nO autor recomenda usar a primeira op√ß√£o.\n\n\nM√©todos √öteis para Strings\nAo definirmos o objeto string em Python, s√£o definidas tamb√©m algumas a√ß√µes que este objeto pode executar.\n\n\nC√≥digo\n# Defini-se um string qualquer\nfrase = \" Python √© legal! \"\n\n# Visualizar vari√°vel\nfrase\n\n\n' Python √© legal! '\n\n\n\nM√©todo str.lower(): Deixa qualquer caractere em min√∫sculo.\n\n\n\nC√≥digo\nfrase.lower()\n\n\n' python √© legal! '\n\n\n\nM√©todo str.upper(): Deixa qualquer caractere em mai√∫sculo.\n\n\n\nC√≥digo\nfrase.upper()\n\n\n' PYTHON √â LEGAL! '\n\n\n\nM√©todo str.strip(): Remove os espa√ßos extras.\n\n\n\nC√≥digo\nfrase.strip()\n\n\n'Python √© legal!'\n\n\n\nM√©todo str.title(): Primeiro caractere de cada palavra em letra mai√∫scula.\n\n\n\nC√≥digo\nfrase.strip().title()\n\n\n'Python √â Legal!'\n\n\n\nM√©todo str.replace(): Troca um determinado caractere (1¬∫ argumento) por um outro determinado caractere (2¬∫ argumento).\n\n\n\nC√≥digo\nfrase.replace(\"Python\", \"Programar\")\n\n\n' Programar √© legal! '\n\n\n\nM√©todo str.index(): Retorna o √≠ndice de determinado caractere contido na string.\n\n\n\nC√≥digo\nfrase.index(\"√©\")\n\n\n8\n\n\n\nM√©todo str.count(): Quantifica o n√∫mero de apari√ß√µes de determinado caractere na string.\n\n\n\nC√≥digo\nfrase.count(\"a\")\n\n\n1\n\n\n\nM√©todo str.split(): Cria uma lista a partir de fatias da string com base em um caractere.\n\n\n\nC√≥digo\n# M√©todo split sem argumento (default)\nprint(frase.split())\n\n\n['Python', '√©', 'legal!']\n\n\nC√≥digo\n# M√©todo split com argumento\nprint(frase.split(\"√©\"))\n\n\n[' Python ', ' legal! ']",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/02_Data_Structure.html#listas",
    "href": "M√≥dulo I/02_Data_Structure.html#listas",
    "title": "Objetos no Python",
    "section": "Listas",
    "text": "Listas\nListas s√£o uma das estruturas de dados mais usadas em Python. Elas permitem armazenar m√∫ltiplos valores em uma √∫nica vari√°vel e suportam diversos tipos de opera√ß√µes.\n\nDeclara√ß√£o de Listas\nUma lista em Python √© definida utilizando colchetes [], e seus elementos s√£o separados por v√≠rgulas:\n\n\nC√≥digo\n# Lista de n√∫meros\nnumeros = [1, 2, 3, 4, 5]\n\n# Lista de strings\nfrutas = [\"ma√ßa\", \"banana\", \"abacaxi\"]\n\n# Lista mista\ndados = [25, \"Jo√£o\", True, 3.14]\n\n\nUma lista tamb√©m pode ser vazia, algo que futaremente veremos que pode ser muito √∫til, por exemplo:\n\n\nC√≥digo\nvazia = []\nvazia\n\n\n[]\n\n\n\n\nIndexa√ß√£o e Fatiamento\nA ideia de √≠ndices e fatias de listas funciona de forma muito parecida com a que foi vista em strings.\n\n\nC√≥digo\nnumeros[0] # Primeiro elemento\n\n\n1\n\n\n\n\nC√≥digo\nnumeros[-1] # √öltimo elemento\n\n\n5\n\n\nAssim como na indexa√ß√£o de strings, ao tentar acessar um √≠ndice inv√°lido de uma lista √© retornado um erro.\nAo √≠nves de simplesmente acessar um elemneto atrav√©s de seu √≠ndice, podemos obter uma fatia, que pode ser muito mais interessante.\n\n\nC√≥digo\nnumeros[::2] # Do come√ßo ao fim, de 2 em 2 elementos\n\n\n[1, 3, 5]\n\n\n\n\nC√≥digo\nnumeros[::-2] # Do fim ao come√ßo, de 2 em 2 elementos\n\n\n[5, 3, 1]\n\n\n\n\nC√≥digo\nnumeros[:3]   # Tr√™s primeiros elementos\n\n\n[1, 2, 3]\n\n\n\n\nC√≥digo\nnumeros[3:]   # Elementos a partir do √≠ndice 3\n\n\n[4, 5]\n\n\n\n\nC√≥digo\nnumeros[::-1] # Lista invertida\n\n\n[5, 4, 3, 2, 1]\n\n\n\n\nTrabalhando com Listas\nImagine que se queira saber se um determinado elemento (objeto) est√° contido em determinada lista. Poderiamos ficar procurando elemento a elemento, vamos tentar essa abordagem. Verifique se o elemento 0.3146778807984779 est√° contido na lista abaixo:\n\n\nC√≥digo\nimport random as rd\n\nrd.seed(42)\n\nva = [rd.random() for _ in range(100)]\nva\n\n\n[0.6394267984578837, 0.025010755222666936, 0.27502931836911926, 0.22321073814882275, 0.7364712141640124, 0.6766994874229113, 0.8921795677048454, 0.08693883262941615, 0.4219218196852704, 0.029797219438070344, 0.21863797480360336, 0.5053552881033624, 0.026535969683863625, 0.1988376506866485, 0.6498844377795232, 0.5449414806032167, 0.2204406220406967, 0.5892656838759087, 0.8094304566778266, 0.006498759678061017, 0.8058192518328079, 0.6981393949882269, 0.3402505165179919, 0.15547949981178155, 0.9572130722067812, 0.33659454511262676, 0.09274584338014791, 0.09671637683346401, 0.8474943663474598, 0.6037260313668911, 0.8071282732743802, 0.7297317866938179, 0.5362280914547007, 0.9731157639793706, 0.3785343772083535, 0.552040631273227, 0.8294046642529949, 0.6185197523642461, 0.8617069003107772, 0.577352145256762, 0.7045718362149235, 0.045824383655662215, 0.22789827565154686, 0.28938796360210717, 0.0797919769236275, 0.23279088636103018, 0.10100142940972912, 0.2779736031100921, 0.6356844442644002, 0.36483217897008424, 0.37018096711688264, 0.2095070307714877, 0.26697782204911336, 0.936654587712494, 0.6480353852465935, 0.6091310056669882, 0.171138648198097, 0.7291267979503492, 0.1634024937619284, 0.3794554417576478, 0.9895233506365952, 0.6399997598540929, 0.5569497437746462, 0.6846142509898746, 0.8428519201898096, 0.7759999115462448, 0.22904807196410437, 0.03210024390403776, 0.3154530480590819, 0.26774087597570273, 0.21098284358632646, 0.9429097143350544, 0.8763676264726689, 0.3146778807984779, 0.65543866529488, 0.39563190106066426, 0.9145475897405435, 0.4588518525873988, 0.26488016649805246, 0.24662750769398345, 0.5613681341631508, 0.26274160852293527, 0.5845859902235405, 0.897822883602477, 0.39940050514039727, 0.21932075915728333, 0.9975376064951103, 0.5095262936764645, 0.09090941217379389, 0.04711637542473457, 0.10964913035065915, 0.62744604170309, 0.7920793643629641, 0.42215996679968404, 0.06352770615195713, 0.38161928650653676, 0.9961213802400968, 0.529114345099137, 0.9710783776136181, 0.8607797022344981]\n\n\nNote que n√£o √© vi√°vel essa abordagem. Para est√° finalidade devemos usar o operador l√≥gico in. Veja o exemplo:\n\n\nC√≥digo\n0.3146778807984779 in va # 'elemento' est√° contido em 'lista'\n\n\nTrue\n\n\nLembra do operador not? Podemos combin√°-lo com o in para verificar se um elemento ‚Äòn√£o est√°‚Äô contido em uma determina lista. Sendo o contr√°rio (nega√ß√£o) da afirma√ß√£o acima.\n\n\nC√≥digo\n0.3146778807984779 not in va # 'elemento' n√£o est√° contido em 'lista'\n\n\nFalse\n\n\nVeja um exemplo de como o in funciona em uma outra situa√ß√£o.\n\n\nC√≥digo\nlista_mista = ['duas palavras', 42, True, ['batman', 'robin'], -0.84, 'hip√≥fise']\n42 in lista_mista\n\n\nTrue\n\n\n\n\nC√≥digo\n'batman' in lista_mista\n\n\nFalse\n\n\n\n\nC√≥digo\n'batman' in lista_mista[3] # Note que o elemento com √≠ndice 3 tamb√©m √© uma lista\n\n\nTrue\n\n\nConsegue me dizer quantos elementos t√™m na lista va? Fique tranquilo! N√£o precisa contar, pode ser usado a fun√ß√£o len do Python para responder essa pergunta.\n\n\nC√≥digo\nlen(va)\n\n\n100\n\n\n\n\nC√≥digo\nlen(lista_mista[3])\n\n\n2\n\n\n\n\nAdicionar e Remover elementos de uma Lista\nPodemos adicionar elementos de diversas formas:\n\n\nC√≥digo\n# Adiciona um √∫nico elemento ao final da lista\nnumeros.append(6)\nnumeros\n\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nC√≥digo\n# Adiciona v√°rios elementos ao final da lista\nnumeros.extend([7, 8, 9])\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nC√≥digo\n# Adiciona um elemento em uma posi√ß√£o espec√≠fica\nnumeros.insert(2, 15)  # Insere o n√∫mero 15 na posi√ß√£o 2 (3¬∫ elemento)\nnumeros\n\n\n[1, 2, 15, 3, 4, 5, 6, 7, 8, 9]\n\n\nPodemos remover/excluir elementos de uma lista das seguintes formas:\n\n\nC√≥digo\n# Remove a primeira ocorr√™ncia de um valor espec√≠fico\nnumeros.remove(15)  # Remove o n√∫mero 15\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nC√≥digo\n# Exclui o √∫ltimo elemento da lista\ndel numeros[-1]\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8]\n\n\nE se, por exemplo, eu precisar come√ßar a lista do zero? Pode-se remover todos os elementos de uma lista, usando o m√©todo clear():\n\n\nC√≥digo\nva.clear()\nprint(\"Lista de n√∫meros aleat√≥rios:\")\n\n\nLista de n√∫meros aleat√≥rios:\n\n\nC√≥digo\nprint(va)\n\n\n[]\n\n\nC√≥digo\nva = [rd.random() for _ in range(100)]\nprint(\"Lista de n√∫meros aleat√≥rios:\")\n\n\nLista de n√∫meros aleat√≥rios:\n\n\nC√≥digo\nprint(va)\n\n\n[0.011481021942819636, 0.7207218193601946, 0.6817103690265748, 0.5369703304087952, 0.2668251899525428, 0.6409617985798081, 0.11155217359587644, 0.434765250669105, 0.45372370632920644, 0.9538159275210801, 0.8758529403781941, 0.26338905075109076, 0.5005861130502983, 0.17865188053013137, 0.9126278393448205, 0.8705185698367669, 0.2984447914486329, 0.6389494948660052, 0.6089702114381723, 0.1528392685496348, 0.7625108000751513, 0.5393790301196257, 0.7786264786305582, 0.5303536721951775, 0.0005718961279435053, 0.3241560570046731, 0.019476742385832302, 0.9290986162646171, 0.8787218778231842, 0.8316655293611794, 0.30751412540266143, 0.05792516649418755, 0.8780095992040405, 0.9469494452979941, 0.08565345206787878, 0.4859904633166138, 0.06921251846838361, 0.7606021652572316, 0.7658344293069878, 0.1283914644997628, 0.4752823780987313, 0.5498035934949439, 0.2650566289400591, 0.8724330410852574, 0.4231379402008869, 0.21179820544208205, 0.5392960887794583, 0.7299310690899762, 0.2011510633896959, 0.31171629130089495, 0.9951493566608947, 0.6498780576394535, 0.43810008391450406, 0.5175758410355906, 0.12100419586826572, 0.22469733703155736, 0.33808556214745533, 0.5883087184572333, 0.230114732596577, 0.22021738445155947, 0.07099308600903254, 0.6311029572700989, 0.22894178381115438, 0.905420013006128, 0.8596354002537465, 0.07085734988865344, 0.23800463436899522, 0.6689777782962806, 0.2142368073704386, 0.132311848725025, 0.935514240580671, 0.5710430933252845, 0.47267102631179414, 0.7846194242907534, 0.8074969977666434, 0.1904099143618777, 0.09693081422882333, 0.4310511824063775, 0.4235786230199208, 0.467024668036675, 0.7290758494598506, 0.6733645472933015, 0.9841652113659661, 0.09841787115195888, 0.4026212821022688, 0.33930260539496315, 0.8616725363527911, 0.24865633392028563, 0.1902089084408115, 0.4486135478331319, 0.4218816398344042, 0.27854514466694047, 0.2498064478821005, 0.9232655992760128, 0.44313074505345695, 0.8613491047618306, 0.5503253124498481, 0.05058832952488124, 0.9992824684127266, 0.8360275850799519]\n\n\n\n\nModificando elementos\nComo as listas s√£o mut√°veis, podemos alterar seus valores diretamente:\n\n\nC√≥digo\nprint(f\"Antes da modifica√ß√£o: \\n {frutas}\")\n\n\nAntes da modifica√ß√£o: \n ['ma√ßa', 'banana', 'abacaxi']\n\n\nC√≥digo\n# Alterando 'banana' por 'melancia'\nfrutas[1] = \"melancia\"\n\n# Visualizando\nprint(f\"Depois da modifica√ß√£o: \\n {frutas}\")\n\n\nDepois da modifica√ß√£o: \n ['ma√ßa', 'melancia', 'abacaxi']\n\n\nOutra forma de se fazer a modifica√ß√£o √©:\n\n\nC√≥digo\n# Obtendo a posi√ß√£o (√≠ndice) da fruta (string) 'melancia'\nid = frutas.index(\"melancia\")\n\n# Alterando 'melancia' por 'banana'\nfrutas[id] = \"banana\"\n\n# Visualizando\nprint(frutas)\n\n\n['ma√ßa', 'banana', 'abacaxi']\n\n\n\n\nOrdena√ß√£o de Listas\nPor v√°rios motivos, pode ser √∫til ter em m√£os uma lista ordenada. Como fazer isso? Veja os exemplos:\n\n\nC√≥digo\ndesordenada = ['b', 'z', 'k', 'a', 'h']\nprint(f\"Lista desordenada: \\n {desordenada}\")\n\n\nLista desordenada: \n ['b', 'z', 'k', 'a', 'h']\n\n\nC√≥digo\n# Ordenando\ndesordenada.sort()\nprint(f\"Lista ordenada: \\n {desordenada}\")\n\n\nLista ordenada: \n ['a', 'b', 'h', 'k', 'z']\n\n\nVoltemos a lista va:\n\n\nC√≥digo\n# Modificando va um pouco\nva_modified = [round(va[i] * 100) for i in range(len(va))]\nprint(va_modified)\n\n\n[1, 72, 68, 54, 27, 64, 11, 43, 45, 95, 88, 26, 50, 18, 91, 87, 30, 64, 61, 15, 76, 54, 78, 53, 0, 32, 2, 93, 88, 83, 31, 6, 88, 95, 9, 49, 7, 76, 77, 13, 48, 55, 27, 87, 42, 21, 54, 73, 20, 31, 100, 65, 44, 52, 12, 22, 34, 59, 23, 22, 7, 63, 23, 91, 86, 7, 24, 67, 21, 13, 94, 57, 47, 78, 81, 19, 10, 43, 42, 47, 73, 67, 98, 10, 40, 34, 86, 25, 19, 45, 42, 28, 25, 92, 44, 86, 55, 5, 100, 84]\n\n\nC√≥digo\n# Ordenado de forma crescente\nva_modified.sort()\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\nC√≥digo\n# Ordenado de forma decrescente\nva_modified.sort(reverse=True)\nprint(va_modified)\n\n\n[100, 100, 98, 95, 95, 94, 93, 92, 91, 91, 88, 88, 88, 87, 87, 86, 86, 86, 84, 83, 81, 78, 78, 77, 76, 76, 73, 73, 72, 68, 67, 67, 65, 64, 64, 63, 61, 59, 57, 55, 55, 54, 54, 54, 53, 52, 50, 49, 48, 47, 47, 45, 45, 44, 44, 43, 43, 42, 42, 42, 40, 34, 34, 32, 31, 31, 30, 28, 27, 27, 26, 25, 25, 24, 23, 23, 22, 22, 21, 21, 20, 19, 19, 18, 15, 13, 13, 12, 11, 10, 10, 9, 7, 7, 7, 6, 5, 2, 1, 0]\n\n\nAl√©m do m√©todo sort, tem a fun√ß√£o nativa do Python. Fun√ß√£o sorted():\n\n\nC√≥digo\n# Ordenado de forma crescente novamente\nva_modified = sorted(va_modified)\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\n\n\nC√≥pia de Listas\nC√≥pia ou c√≥pias de listas se torna algo de grande valor quando se quer fazer alguma manipula√ß√£o, por√©m n√£o se quer alterar as informa√ß√µes originais. Para isso, deve-se usar o m√©todo copy():\n\n\nC√≥digo\n# Criando listas\nl1 = [[1, 2, 3], [\"x\", \"y\", \"z\"], [True, False]]\nl2 = l1.copy() # l2 √© a c√≥pia de l1\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nC√≥digo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nC√≥digo\n# Adicioando um elemento novo somente a l2\nl2.append([1/4, 1/2, 3/4, 1])\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nC√≥digo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\nAgora, observe o que acontece se n√£o fizer uso do copy():\n\n\nC√≥digo\n# Criando listas\nl1 = [[1, 2, 3], [\"x\", \"y\", \"z\"], [True, False]]\nl2 = l1 # l2 'igual' a l1\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nC√≥digo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nC√≥digo\n# Adicioando um elemento novo somente a l2\nl2.append([1/4, 1/2, 3/4, 1])\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\nC√≥digo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\n\n\nOperando Listas\nFazendo uso ao conhecimento adquirido de strings. Temos os operadores + e *, que funcionam de forma muito similar e obdecem as mesmas regras.\nO operador + concatena (semelhante ao m√©todo extend()) listas:\n\n\nC√≥digo\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nc\n\n\n[1, 2, 3, 4, 5, 6]\n\n\nO operador * repete a lista dado um n√∫mero de vezes:\n\n\nC√≥digo\na * 2\n\n\n[1, 2, 3, 1, 2, 3]\n\n\n\n\nC√≥digo\nd = c + a + b + 2 * c\nd\n\n\n[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]\n\n\nO Python fornece v√°rias outras opera√ß√µes √∫teis para listas, calculadas com fun√ß√µes do m√≥dulo b√°sico do Python. Entretanto, tais fun√ß√µes s√≥ se aplicam a listas num√©ricas:\n\n\nC√≥digo\nprint(f\"Soma da lista 'd': {sum(d)}\")\n\n\nSoma da lista 'd': 84\n\n\nC√≥digo\nprint(f\"Maior valor da lista 'd': {max(d)}\")\n\n\nMaior valor da lista 'd': 6\n\n\nC√≥digo\nprint(f\"Menor valor da lista 'd': {min(d)}\")\n\n\nMenor valor da lista 'd': 1\n\n\nAgora, imagine que seja necess√°rio saber quantas vezes um determinado elemento se repete dentro de uma lista. Tal a√ß√£o pode ser feita pelo m√©todo count():\n\n\nC√≥digo\n# Lembra dessa lista\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\nC√≥digo\n# Quanta vezes o n√∫mero 100 aparece?\nprint(va_modified.count(100))\n\n\n2\n\n\n\n\nUso da Fun√ß√£o range() em Listas\nEm Python, al√©m de fun√ß√µes como print(), len(), sum(), max() e min(), temos a fun√ß√£o range(), que tamb√©m faz parte do m√≥dulo b√°sico. Essa fun√ß√£o √© extremamente √∫til para criar sequ√™ncias num√©ricas, especialmente listas. Imagine que voc√™ precise criar uma lista com os n√∫meros de 1 a 200. Como fazer isso de forma eficiente?\nUma abordagem seria escrever todos os n√∫meros manualmente:\nlista_grande = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ..., 200]\nNo entanto, essa n√£o √© a forma mais pr√°tica. √â a√≠ que entra a fun√ß√£o range(). Com ela, podemos gerar essa lista de forma muito mais simples:\n\n\nC√≥digo\nlist(range(1, 201))  # Note que o limite superior √© 201\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]\n\n\nO range() tamb√©m oferece flexibilidade para gerar sequ√™ncias com intervalos espec√≠ficos. Por exemplo, para obter os n√∫meros de 0 a 29, pulando de 5 em 5:\n\n\nC√≥digo\nlist(range(0, 30, 5))\n\n\n[0, 5, 10, 15, 20, 25]\n\n\nAl√©m disso, o range() tamb√©m oferece algumas coisas interessantes. Por exemplo, imprimir os n√∫meros espa√ßados de 5 em 5, entre 0 e 30:\n\n\nC√≥digo\nlist(range(0, 30, 5))\n\n\n[0, 5, 10, 15, 20, 25]\n\n\nA sintaxe geral do range() √©: range(start, stop, step), onde:\n\nstart: O valor inicial da sequ√™ncia (inclusivo).\nstop: O valor final da sequ√™ncia (exclusivo).\nstep: O intervalo entre os valores.\n\nPor que precisamos converter range() para list?\n\n\nC√≥digo\nprint(range(200))\n\n\nrange(0, 200)\n\n\nC√≥digo\nprint(type(range(200)))\n\n\n&lt;class 'range'&gt;\n\n\nIsso acontece porque range() retorna um objeto do tipo range, que representa uma sequ√™ncia num√©rica, mas n√£o √© uma lista em si. Para visualizar os n√∫meros, precisamos convert√™-lo explicitamente para uma lista:\n\n\nC√≥digo\nrange_lista = list(range(200))\nprint(range_lista)\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/02_Data_Structure.html#dicion√°rios",
    "href": "M√≥dulo I/02_Data_Structure.html#dicion√°rios",
    "title": "Objetos no Python",
    "section": "Dicion√°rios",
    "text": "Dicion√°rios\nDicion√°rios em Python s√£o estruturas de dados poderosas que armazenam informa√ß√µes no formato chave-valor. Diferentemente das listas, que s√£o indexadas por n√∫meros, os dicion√°rios usam chaves imut√°veis (strings, n√∫meros, tuplas, etc.) para acessar seus valores.\nUm dicion√°rio √© uma cole√ß√£o de pares chave-valor, onde cada chave √© √∫nica e est√° associada a um valor: {chave: valor}.\n\nChaves √önicas: Uma caracter√≠stica fundamental dos dicion√°rios √© que cada chave deve ser √∫nica. Tentar inserir chaves duplicadas resultar√° na substitui√ß√£o do valor anterior.\n\n\nDeclara√ß√£o de Dicion√°rios\nEm Python, dicion√°rios podem ser criados de diversas maneiras, oferecendo flexibilidade para diferentes situa√ß√µes.\n\nCria√ß√£o Direta com Chaves e Valores:\n\n\n\nC√≥digo\n# Dicion√°rio com informa√ß√µes de uma receita\nreceita = {\n    \"farinha\": \"2 x√≠caras\",\n    \"ovos\": 3,\n    \"leite condensado\": \"1 lata\"\n}\n\n# Dicion√°rio com n√∫meros de telefone\ntelefones = {\"ana\": 123456, \"yudi\": 40028922, \"julia\": 4124492}\n\n\nNeste exemplo, \"ana\" √© uma chave que est√° associada ao valor 123456. Cada par chave-valor √© separado por v√≠rgula.\n\n\nC√≥digo\nprint(receita)\n\n\n{'farinha': '2 x√≠caras', 'ovos': 3, 'leite condensado': '1 lata'}\n\n\nC√≥digo\nprint(telefones)\n\n\n{'ana': 123456, 'yudi': 40028922, 'julia': 4124492}\n\n\n\nCria√ß√£o de um Dicion√°rio Vazio:\n\nVoc√™ pode criar um dicion√°rio vazio usando apenas chaves {}:\n\n\nC√≥digo\ncontatos = {}\ncontatos\n\n\n{}\n\n\n\nCria√ß√£o com a Fun√ß√£o dict():\n\nA fun√ß√£o dict() permite criar dicion√°rios de forma mais expl√≠cita, especialmente quando as chaves s√£o strings simples:\n\n\nC√≥digo\npessoa = dict(nome=\"Carlos\", idade=30, cidade=\"S√£o Paulo\")\npessoa\n\n\n{'nome': 'Carlos', 'idade': 30, 'cidade': 'S√£o Paulo'}\n\n\n\nCom uma lista de listas:\n\n\n\nC√≥digo\n# Definindo tr√™s listas diferentes\nl1 = [\"brigadeiro\", \"leite condesado, achocolatado\"]\nl2 = [\"omelete\", \"ovos, azeite, condimentos a gosto\"]\nl3 = [\"ovo frito\", \"ovo, √≥leo, condimentos a gosto\"]\n\n# Criando uma lista de listas\nlr = [l1, l2, l3]\n\n# Visualizando resultado\nlr\n\n\n[['brigadeiro', 'leite condesado, achocolatado'], ['omelete', 'ovos, azeite, condimentos a gosto'], ['ovo frito', 'ovo, √≥leo, condimentos a gosto']]\n\n\n\n\nC√≥digo\n# Transformando lista de listas em um dicion√°rio\nreceitas = dict(lr)\n\n# Visualizando o resultado\nreceitas\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, √≥leo, condimentos a gosto'}\n\n\n\n\nChaves\nPodemos acessar os valores de um dicion√°rio atrav√©s de suas chaves:\n\n\nC√≥digo\n# Definindo um dicion√°rio para capitais de estados brasileiros\ncapitais = {\"SP\": \"S√£o Paulo\", \"AC\": \"Rio Branco\", \"TO\": \"Palmas\",\n            \"RJ\": \"Rio de Janeiro\", \"SE\": \"Aracaju\", \"MG\": \"Belo Horizonte\"}\n\n# Acessando o valor correspondente a chave \"MG\"\ncapitais[\"MG\"]\n\n\n'Belo Horizonte'\n\n\nCaso a chave n√£o exista, podemos evitar erros usando o m√©todo get():\n\n\nC√≥digo\ncapitais.get(\"PA\")\n\n\n\n\nC√≥digo\ncapitais.get(\"PA\", \"N√£o tem!\")\n\n\n'N√£o tem!'\n\n\nNote que o m√©todo get() funciona de forma similar ao c√≥digo dicion√°rio[chave], entretanto, caso a chave n√£o exista garantimos que o c√≥digo n√£o gere erro diferente do que aconteceria caso fosse usado dicion√°rio[chave].\nRepare, tamb√©m, que a chave \"PA\" n√£o foi adicionada ao dicion√°rio.\n\n\nC√≥digo\ncapitais\n\n\n{'SP': 'S√£o Paulo', 'AC': 'Rio Branco', 'TO': 'Palmas', 'RJ': 'Rio de Janeiro', 'SE': 'Aracaju', 'MG': 'Belo Horizonte'}\n\n\nAgora, se o objetivo n√£o for saber o valor associado a determinada chave, mas sim saber se a chave existe, isso pode ser feito usando o m√©todo keys e o operador l√≥gico in:\n\n\nC√≥digo\n# Chaves do Dicion√°rio\nprint(capitais.keys())\n\n\ndict_keys(['SP', 'AC', 'TO', 'RJ', 'SE', 'MG'])\n\n\nC√≥digo\n# Verificando\nprint(f'A chave \"PA\" est√° no dicion√°rio capitais? {\"PA\" in capitais.keys()}')\n\n\nA chave \"PA\" est√° no dicion√°rio capitais? False\n\n\nNote que os valores de um dicion√°rio pode ser qualquer tipo de objeto. No entanto, foi usado, at√© ent√£o, para exemplos, apenas strings. Por√©m, pode-se colocar todo tipo de coisa dentro dos dicion√°rios, incluindo listas e at√© mesmo outros dicion√°rios:\n\n\nC√≥digo\nnumeros = {\"primos\": [2, 3, 5], \"pares\": [0, 2, 4], \"√≠mpares\": [1, 3, 5]}\nprint(numeros)\n\n\n{'primos': [2, 3, 5], 'pares': [0, 2, 4], '√≠mpares': [1, 3, 5]}\n\n\n\n\nC√≥digo\ndocente = {\n  \"Nome\": \"Prof Dr Vin√≠cius Duarte Lima\", \n  \"Forma√ß√£o\": {\"Gradua√ß√£o\": \"Eng El√©trica\", \"Mestrado\": \"Eng El√©trica\", \"Doutorado\": \"Eng El√©trica\"},\n  \"Idade\": 45,\n}\n\nprint(docente)\n\n\n{'Nome': 'Prof Dr Vin√≠cius Duarte Lima', 'Forma√ß√£o': {'Gradua√ß√£o': 'Eng El√©trica', 'Mestrado': 'Eng El√©trica', 'Doutorado': 'Eng El√©trica'}, 'Idade': 45}\n\n\nMesmo que os pares chave: valor estejam organizados na ordem que foram colocados, n√£o podemos acess√°-los por √≠ndices como far√≠amos em listas:\n[Input]  : numeros[2]\n[Output] : KeyError: 2\nAssim como os valores n√£o precisam ser do tipo string, o mesmo vale para as chaves:\n\n\nC√≥digo\nnumeros_por_extenso = {2: \"dois\", 1: \"um\", 3: \"tr√™s\", 0: \"zero\"}\nnumeros_por_extenso[0]\n\n\n'zero'\n\n\n\n\nC√≥digo\nnumeros_por_extenso[2]\n\n\n'dois'\n\n\n\nNota: Listas e outros dicion√°rios n√£o podem ser usados como chaves por serem de tipos mut√°veis.\n\n\n\nAdicionando, Alterando e Removendo Elementos\nPara exemplificar os comandos desta se√ß√£o, considere o dicion√°rio abaixo.\n\n\nC√≥digo\n# Informa√ß√µes de Cleiton\npessoa = {\"nome\": \"Cleiton\", \"idade\": 34, \"fam√≠lia\": {\"m√£e\": \"Maria\", \"pai\": \"Enzo\"}}\n\n# Visualizando\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'fam√≠lia': {'m√£e': 'Maria', 'pai': 'Enzo'}}\n\n\nPara adicionar o item \"masculino\" a chave \"gen√™ro\" podemos usar os seguintes comandos:\n\n\nC√≥digo\n# Adicionando elemento\npessoa[\"gen√™ro\"] = \"rom√¢ntico\"\n\n# Visualizando\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'fam√≠lia': {'m√£e': 'Maria', 'pai': 'Enzo'}, 'gen√™ro': 'rom√¢ntico'}\n\n\nDe forma equivalente, temos:\n\n\nC√≥digo\n# Dicion√°rio de meses do ano\nmeses = {1: \"Janeiro\", 2: \"Fevereiro\", 3: \"Mar√ßo\"}\n\n# Adicionando o m√™s de \"Abril\" na chave 4\nmeses[4] = \"Setembro\"\n\n# Visualizando\nmeses\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Mar√ßo', 4: 'Setembro'}\n\n\nAs vezes, podem haver inconsist√™ncias nos dados, logo, se torna necess√°rio corrigir tais inconsist√™ncias. Isso pode ser feito de forma muito simples, veja:\n\n\nC√≥digo\n# Executando altera√ß√µes\npessoa[\"gen√™ro\"] = \"masculino\"\nmeses[4] = \"Abril\"\n\n# Visualizando\nprint(pessoa)\n\n\n{'nome': 'Cleiton', 'idade': 34, 'fam√≠lia': {'m√£e': 'Maria', 'pai': 'Enzo'}, 'gen√™ro': 'masculino'}\n\n\nC√≥digo\nprint(meses)\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Mar√ßo', 4: 'Abril'}\n\n\nUm d√∫vida que talvez possa surgir √© como fazer altera√ß√£o em listas que est√£o contidas em dicion√°rios. Na verdade, isso √© feito de forma bastante objetiva, veja:\n\n\nC√≥digo\n# Novo dicion√°rio\nlixo = {\"pl√°stico\": [\"garrafa\", \"copinho\", \"canudo\"], \n        \"papel\": [\"folha amassada\", \"guardanapo\"], \n        \"org√¢nico\": [\"batata\", \"resto do bandeco\", \"casca de banana\"]}\n\n# Visualizando\nprint(lixo)\n\n\n{'pl√°stico': ['garrafa', 'copinho', 'canudo'], 'papel': ['folha amassada', 'guardanapo'], 'org√¢nico': ['batata', 'resto do bandeco', 'casca de banana']}\n\n\nC√≥digo\n# Obtendo lista de interesse para altera√ß√£o\nlista_de_interesse = lixo[\"pl√°stico\"]\n\n# Verificando em qual posi√ß√£o est√° o elemneto que deve ser alterado\nid = lista_de_interesse.index(\"garrafa\")\n\n# Fazendo a altera√ß√£o diretamente no dicion√°rio\nlixo['pl√°stico'][id] = \"sacola\"\n\n# Visualizando dicion√°rio alterado\nlixo\n\n\n{'pl√°stico': ['sacola', 'copinho', 'canudo'], 'papel': ['folha amassada', 'guardanapo'], 'org√¢nico': ['batata', 'resto do bandeco', 'casca de banana']}\n\n\nNote que poderiamos ser mais direto, pois as listas em quest√£o t√™m comprimentos pequenos. Por√©m, tal c√≥digo j√° pode ser implementado para listas de grande comprimento.\nPor√©m, ao lidarmos com dicion√°rios, talvez precisemos excluir algum elemento. Ser√£o apresentadas duas formas de fazer isso.\n\nUsando o m√©todo pop():\n\n\n\nC√≥digo\npessoa.pop(\"fam√≠lia\")\n\n\n{'m√£e': 'Maria', 'pai': 'Enzo'}\n\n\nRepare que dicion√°rio.pop(chave) exclu√≠ o elemento e retorna os itens da chave exclu√≠da. Para visualizarmos o resultado basta chamar o dicion√°rio.\n\n\nC√≥digo\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'gen√™ro': 'masculino'}\n\n\n\nUsando o comando del do Python B√°sico:\n\n\n\nC√≥digo\ndel meses[4]\n\n\nDiferente do m√©todo pop(), o comando del n√£o retorna nada. Por√©m, para visualizar o resultado, precisamos chamar o objeto.\n\n\nC√≥digo\nmeses\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Mar√ßo'}\n\n\nPara excluir todos os elementos de um dicion√°rio, temos o m√©todo clear():\n\n\nC√≥digo\n# Apagando todos os elementos do dicion√°rio\nlixo.clear()\n\n# Visualizando\nlixo\n\n\n{}\n\n\n\n\nFun√ß√£o list() e Fun√ß√£o len() para Dicion√°rios\nA fun√ß√£o list() converte um dicion√°rio em uma lista contendo apenas suas chaves:\n\n\nC√≥digo\ninstitutos_uspsc = {\n    \"IFSC\": \"Instituto de F√≠sica de S√£o Carlos\",\n    \"ICMC\": \"Instituto de Ci√™ncias Matem√°ticas e de Computa√ß√£o\",\n    \"EESC\": \"Escola de Engenharia de S√£o Carlos\",\n    \"IAU\": \"Instituto de Arquitetura e Urbanismo\",\n    \"IQSC\": \"Instituto de Qu√≠mica de S√£o Carlos\"\n}\n\n# Convertendo dicion√°rio em lista de chaves\nlista_chaves = list(institutos_uspsc)\nprint(lista_chaves)\n\n\n['IFSC', 'ICMC', 'EESC', 'IAU', 'IQSC']\n\n\nA fun√ß√£o len() retorna o n√∫mero de itens em um objeto. Para dicion√°rios, ela conta o n√∫mero de pares chave-valor:\n\n\nC√≥digo\n# Contando itens no dicion√°rio\nquantidade_institutos = len(institutos_uspsc)\nprint(quantidade_institutos)\n\n\n5\n\n\nC√≥digo\n# Equivalente a contar as chaves convertidas em lista\nprint(len(list(institutos_uspsc)))\n\n\n5\n\n\n\n\nOutros comandos para dicion√°rios\nVejamos agora os m√©todos items() e values(). Considere o seguinte dicion√°rio:\n\n\nC√≥digo\npessoa = {\"nome\": \"Enzo\", \"RA\": 242334, \"curso\": \"fiscomp\"}\n\n\n\nitems() - Retorna uma vis√£o dos pares chave-valor:\n\n\n\nC√≥digo\npares = pessoa.items()\nprint(list(pares))\n\n\n[('nome', 'Enzo'), ('RA', 242334), ('curso', 'fiscomp')]\n\n\n\nvalues() - Retorna uma vis√£o dos valores armazenados:\n\n\n\nC√≥digo\nvalores = list(pessoa.values())\nprint(valores)\n\n\n['Enzo', 242334, 'fiscomp']\n\n\nObserva√ß√£o importante: A fun√ß√£o list() aplicada diretamente a um dicion√°rio (list(pessoa)) retorna apenas as chaves, equivalente a list(pessoa.keys()).\nDicion√°rios em Python (vers√µes 3.7+) mant√™m a ordem de inser√ß√£o, mas a igualdade entre dicion√°rios considera apenas os pares chave-valor, n√£o a ordem:\n\n\nC√≥digo\nnumerinhos = {\"um\": 1, \"dois\": 2, \"tr√™s\": 3}\nnumeritos = {\"tr√™s\": 3, \"dois\": 2, \"um\": 1}\n\nprint(numerinhos == numeritos)\n\n\nTrue\n\n\nC√≥digo\nprint(numerinhos)  # Mostra na ordem de inser√ß√£o\n\n\n{'um': 1, 'dois': 2, 'tr√™s': 3}\n\n\nC√≥digo\nprint(numeritos)   # Mostra na ordem de inser√ß√£o diferente\n\n\n{'tr√™s': 3, 'dois': 2, 'um': 1}\n\n\nOutro comando que pode ser usado para adicionar elementos em um dicion√°rio pode ser o m√©todo update().\n\n\nC√≥digo\n# Lembra do dicion√°rios receitas?\nprint(receitas)\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, √≥leo, condimentos a gosto'}\n\n\nC√≥digo\n# Nova receita\noutros_elementos = {\"mingau\": \"massa, leite, a√ß√∫car\"}\n\n# Adicionando a nova receita\nreceitas.update(outros_elementos)\n\n# Visualizando\nprint(receitas)\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, √≥leo, condimentos a gosto', 'mingau': 'massa, leite, a√ß√∫car'}\n\n\n\nResum√£o:\n\n\nOs m√©todos items() e values() (e keys()) retornam objetos de visualiza√ß√£o que refletem automaticamente as altera√ß√µes no dicion√°rio original;\nA partir do Python 3.7, a ordem de inser√ß√£o √© preservada como caracter√≠stica da implementa√ß√£o, tornando-se parte da especifica√ß√£o na vers√£o 3.8;\nUso do m√©todo update para integraliza√ß√£o de dicion√°rios.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/03_FlowControl_&_Functions.html",
    "href": "M√≥dulo I/03_FlowControl_&_Functions.html",
    "title": "Controle de Fluxo & Fun√ß√µes em Python",
    "section": "",
    "text": "Introdu√ß√£o\nEm programa√ß√£o, o controle de fluxo determina a ordem em que as instru√ß√µes s√£o executadas em um programa. Em Python, isso permite criar programas que tomam decis√µes e repetem a√ß√µes com base em condi√ß√µes espec√≠ficas, tornando seu c√≥digo mais din√¢mico e adapt√°vel.\nNesta se√ß√£o, exploraremos as principais estruturas de controle de fluxo:\nPor que o controle de fluxo √© importante? Imagine um programa que:\nSem controle de fluxo, nossos programas seriam lineares e limitados. Com ele, ganhamos flexibilidade e poder para resolver problemas complexos.\nDominar o controle de fluxo √© essencial para qualquer pessoa que esteja aprendendo programa√ß√£o, pois ele est√° presente em praticamente todo c√≥digo real. Vamos come√ßar a explorar cada conceito com exemplos pr√°ticos e exerc√≠cios!",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Controle de Fluxo & Fun√ß√µes em Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/03_FlowControl_&_Functions.html#introdu√ß√£o",
    "href": "M√≥dulo I/03_FlowControl_&_Functions.html#introdu√ß√£o",
    "title": "Controle de Fluxo & Fun√ß√µes em Python",
    "section": "",
    "text": "Condicionais - if, elif e else: Permitem executar blocos de c√≥digo diferentes dependendo se uma condi√ß√£o √© verdadeira ou falsa.\nLa√ßos - for e while: Permitem repetir um bloco de c√≥digo v√°rias vezes, seja por um n√∫mero espec√≠fico de vezes ou enquanto uma condi√ß√£o for verdadeira.\nTratamento de exce√ß√µes - try, except e finally: Permitem lidar com erros e situa√ß√µes inesperadas sem interromper o programa.\nPalavras-chave - break e continue: Permitem controlar o fluxo de execu√ß√£o dentro de la√ßos.\n\n\n\nDecide se um usu√°rio tem acesso a um sistema (if).\nRepete uma a√ß√£o at√© que um download seja conclu√≠do (while).\nPercorre uma lista de produtos para calcular descontos (for).\nPrevine erros se um arquivo n√£o for encontrado (try/except).",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Controle de Fluxo & Fun√ß√µes em Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/03_FlowControl_&_Functions.html#estruturas-de-decis√£o",
    "href": "M√≥dulo I/03_FlowControl_&_Functions.html#estruturas-de-decis√£o",
    "title": "Controle de Fluxo & Fun√ß√µes em Python",
    "section": "Estruturas de Decis√£o",
    "text": "Estruturas de Decis√£o\nAs estruturas de decis√£o em Python s√£o usadas para controlar o fluxo do programa, ou seja, para decidir qual bloco de c√≥digo ser√° executado dependendo de uma ou mais condi√ß√µes. Pense como um sem√°foro: dependendo da cor, uma a√ß√£o diferente deve ser tomada ‚Äî o mesmo acontece em um programa.\n\nExemplo do mundo real:\n\nSe estiver nublado:\n    Levarei guarda-chuva\nSen√£o:\n    N√£o levarei\n\nNota: Em Python, a indenta√ß√£o (recuo de quatro espa√ßos ou um tab) √© obrigat√≥ria para definir os blocos de c√≥digo. Isso significa que o que estiver indentado ser√° considerado parte da condi√ß√£o.\n\n\n\nEstrutura if Simples\nA estrutura mais b√°sica do controle de fluxo √© o if, que permite executar um bloco de c√≥digo apenas se uma condi√ß√£o for verdadeira.\n\n\nC√≥digo\nidade = 20\nif idade &gt;= 18:\n    print(\"Voc√™ √© maior de idade.\")\n\n\nVoc√™ √© maior de idade.\n\n\n\nNeste exemplo, como idade √© 20, que √© maior que 18, a mensagem ser√° exibida.\n\n\n\n\nEstrutura if/else\nSe quisermos executar um c√≥digo para o caso em que a condi√ß√£o n√£o √© satisfeita, usamos o else.\n\n\nC√≥digo\nidade = 16\nif idade &gt;= 18:\n    print(\"Voc√™ √© maior de idade.\")\nelse:\n    print(\"Voc√™ √© menor de idade.\")\n\n\nVoc√™ √© menor de idade.\n\n\n\n\n\nEstrutura if/elif/else\nPara avaliar m√∫ltiplas condi√ß√µes, usamos elif (‚Äúelse if‚Äù).\n\n\nC√≥digo\nnota = 8\nif nota &gt;= 9:\n    conceito = \"A\"\nelif nota &gt;= 7:\n    conceito = \"B\"\nelif nota &gt;= 5:\n    conceito = \"C\"\nelse:\n    conceito = \"D\"\n\nprint(\"Conceito:\", conceito)\n\n\nConceito: B\n\n\n\n\n\nDiferen√ßa entre if/elif e m√∫ltiplos if independentes\nH√° uma difer√™n√ßa ao usar as condi√ß√µes if/elif e usar v√°rios if de forma consecutivas. √â importante entender como essa difer√™n√ßa funciona para que o seu programa n√£o atenda mais de uma condi√ß√£o quando na verdade ‚Äúapenas uma‚Äù √© a verdadeira. Vamos h√° um exemplo claro e objetivo.\n\n\nC√≥digo\nif 1 == 1:\n    print(\"Caiu no 1¬∫ if\")\nelif 1 &gt;= 1:\n    print(\"Caiu no elif\")\nelse:\n    print(\"Caiu no else\")\n\n\nCaiu no 1¬∫ if\n\n\nPerceba que duas condi√ß√µes em teste s√£o verdadeiras. Por√©m, ao usarmos a estrutura if/elif, apenas o bloco com a primeira condi√ß√£o verdadeira √© executado. No exemplo, apenas o blobo seguinte a condi√ß√£o if a == 1 foi executado.\nAgora, veja o exemplo adaptado a estrutura de if consecutivos:\n\n\nC√≥digo\nif 1 == 1:\n    print(\"Caiu no 1¬∫ if\")\n\n\nCaiu no 1¬∫ if\n\n\nC√≥digo\nif 1 &gt;= 1:\n    print(\"Caiu no 2¬∫ if\")\nelse:\n    print(\"Caiu no else\")\n\n\nCaiu no 2¬∫ if\n\n\nNo bloco de c√≥digo acima n√£o h√° uma regra pr√© definida pelo Python. Ambos os blocos if ser√£o avaliados independentemente. Isso pode ser √∫til em algumas situa√ß√µes, mas exige aten√ß√£o!\n\n\n\nOutros Exemplos de Condicionais\n\n1¬∫ Exemplo - Condicionais Aninhadas: √ötil quando queremos verificar uma condi√ß√£o dada que outra j√° foi satisfeita. Ou seja, uma estrutura condicional pode estar dentro de outra.\n\n\n\nC√≥digo\n# Definindo uma vari√°vel num√©rica\nvalue = 2.35\n\n# 1¬™ condi√ß√£o (externa)\nif value &lt;= 1:\n  print(\"O valor √© menor ou igual a 1\")\n  \n  # 1¬™ condi√ß√£o (interna) dada que 1¬™ condi√ß√£o (externa) foi satisfeita\n  if value &lt; 0.5:\n    print(\"E √© menor que 0,5\")\n    \n  # 2¬™ condi√ß√£o (interna) dada que 1¬™ condi√ß√£o (externa) foi satisfeita\n  elif value == 0.5:\n    print(\"O valor √© igual a 0,5\")\n    \n  # 3¬™ condi√ß√£o (interna) dada que 1¬™ condi√ß√£o (externa) foi satisfeita\n  else:\n    print(\"O valor √© maior que 0,5\")\n    \n# 2¬™ condi√ß√£o\nelif value &lt;= 2:\n  print(\"O valor √© menor ou igual a 2\")\n  \n  # 1¬™ condi√ß√£o (interna) dada que 2¬™ condi√ß√£o (externa) foi satisfeita\n  if value &lt; 1.5:\n    print(\"E √© menor que 1,5\")\n    \n  # 2¬™ condi√ß√£o (interna) dada que 2¬™ condi√ß√£o (externa) foi satisfeita\n  elif value == 1.5:\n    print(\"O valor √© igual a 1,5\")\n    \n  # 3¬™ condi√ß√£o (interna) dada que 2¬™ condi√ß√£o (externa) foi satisfeita\n  else:\n    print(\"O valor √© maior que 1,5\")\n    \n# 3¬™ condi√ß√£o\nelse:\n  print(\"Sabe-se apenas que o valor √© maior que 2\")\n  \n  # 1¬™ condi√ß√£o (interna) dada que 3¬™ condi√ß√£o (externa) foi satisfeita\n  if value &lt;= 2.5:\n    print(\"Podendo variar entre (2; 2,5]\")\n    \n  # 2¬™ condi√ß√£o (interna) dada que 3¬™ condi√ß√£o (externa) foi satisfeita\n  elif value &lt;= 3:\n    print(\"Podendo variar entre (2,5; 3]\")\n    \n  # 3¬™ condi√ß√£o (interna) dada que 3¬™ condi√ß√£o (externa) foi satisfeita\n  else:\n    print(\"O valor √© maior que 3\")\n\n\nSabe-se apenas que o valor √© maior que 2\nPodendo variar entre (2; 2,5]\n\n\n\n2¬∫ Exemplo - Classifica√ß√£o de Valores: J√° pararam para pensar como o conceito √© dado pelo sistema da Universidade Federal do Par√°? A classifica√ß√£o ocorre da seguinte maneira:\n\n\n\nC√≥digo\nimport random as rd\n\nrd.seed(123456789)\nreview = [10 * rd.random() for _ in range(5)]\nmean = sum(review) / len(review)\nprint(f\"M√©dia das Avalia√ß√µes: {round(mean, 2)}\")\n\n\nM√©dia das Avalia√ß√µes: 7.66\n\n\nC√≥digo\n# Em qual conceito est√° m√©dia estaria?\nif (mean &gt;= 0) and (mean &lt; 5):\n  print(\"O conceito do aluno foi INSUFICIENTE\")\nelif (mean &gt;= 5) and (mean &lt; 7):\n  print(\"O conceito do aluno foi REGULAR\")\nelif (mean &gt;= 7) and (mean &lt; 9):\n  print(\"O conceito do aluno foi BOM\")\nelif (mean &gt;= 9) and (mean &lt;= 10):\n  print(\"O conceito do aluno foi EXCELENTE\")\nelse:\n  print(\"M√©dia de Avalia√ß√µes Inv√°lida\")\n\n\nO conceito do aluno foi BOM\n\n\n\n2¬∫ Exemplo - Classifica√ß√£o de Valores: J√° pararam para pensar como o conceito √© dado pelo sistema da Universidade Federal do Par√°? Mas tamb√©m pode ser feita de forma mais direta:\n\n\n\nC√≥digo\nprint(f\"M√©dia das Avalia√ß√µes: {round(mean, 2)}\")\n\n\nM√©dia das Avalia√ß√µes: 7.66\n\n\nC√≥digo\n# Em qual conceito est√° m√©dia estaria?\nif 0 &lt;= mean &lt; 5:\n  print(\"O conceito do aluno foi INSUFICIENTE\")\nelif 5 &lt;= mean &lt; 7:\n  print(\"O conceito do aluno foi REGULAR\")\nelif 7 &lt;= mean &lt; 9:\n  print(\"O conceito do aluno foi BOM\")\nelif 9 &lt;= mean &lt; 10:\n  print(\"O conceito do aluno foi EXCELENTE\")\nelse:\n  print(\"M√©dia de Avalia√ß√µes Inv√°lida\")\n\n\nO conceito do aluno foi BOM\n\n\n\n3¬∫ Exemplo - Condi√ß√£o com Express√£o Tern√°ria: Forma reduzida do if/else, muito √∫ltil para atribui√ß√µes simples. Exemplo com string:\n\n\n\nC√≥digo\n# Dados do usu√°rio\nage = 19\nCNH = True\n\n# Verifica√ß√£o com Express√£o Tern√°ria\nresult = \"Est√° apto a dirigir!\" if age &gt;= 18 and CNH != False else \"N√£o est√° apto a dirigir!\"\n\n# Visualizar\nprint(result)\n\n\nEst√° apto a dirigir!\n\n\n\n3¬∫ Exemplo - Condi√ß√£o com Express√£o Tern√°ria: Forma reduzida do if/else, muito √∫ltil para atribui√ß√µes simples. Exemplo com number:\n\n\n\nC√≥digo\n# Definindo n√∫meros\nx, y = 4, 5\n\n# Verifica√ß√£o com Express√£o Tern√°ria\nmaior_valor = x if x &gt; y else y\n\n# Visualizar\nprint(maior_valor)\n\n\n5\n\n\n\n\n\nConsidera√ß√µes e Boas Pr√°ticas\n\nUse elif quando apenas uma entre v√°rias condi√ß√µes pode ser verdadeira;\nEvite aninhamentos profundos de if;\nUse opera√ß√µes compostas como 7 &lt;= mean &lt; 9 para mais clareza;\nSempre comente blocos de c√≥digo complexos;\nLembre das ?tbl-operLogic que apresentam os operadores l√≥gicos e ?tbl-conecLogic que mostra os conectores l√≥gicos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Controle de Fluxo & Fun√ß√µes em Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/03_FlowControl_&_Functions.html#estruturas-de-repeti√ß√£o",
    "href": "M√≥dulo I/03_FlowControl_&_Functions.html#estruturas-de-repeti√ß√£o",
    "title": "Controle de Fluxo & Fun√ß√µes em Python",
    "section": "Estruturas de Repeti√ß√£o",
    "text": "Estruturas de Repeti√ß√£o\nAs estruturas de repeti√ß√£o s√£o usadas para executar um bloco de c√≥digo v√°rias vezes, de forma autom√°tica, at√© que uma condi√ß√£o seja satisfeita ou uma sequ√™ncia de elementos seja percorrida.\nEm Python, temos duas principais formas de repeti√ß√£o:\n\nfor: Ideal quando sabemos o n√∫mero de repeti√ß√µes ou estamos percorrendo uma estrutura (lista, string, dicion√°rio, etc);\nwhile: Ideal quando n√£o sabemos o n√∫mero exato de repeti√ß√µes e precisamos que o c√≥digo continue enquanto uma condi√ß√£o for verdadeira.\n\n\n\nEstrutura for\nA estrutura for √© uma das formas mais comuns de repeti√ß√£o em Python. Ela √© ideal quando:\n\nSabemos de antem√£o quantas vezes o c√≥digo deve ser repetido; ou\nQueremos percorrer os elementos de uma sequ√™ncia (como listas, strings, dicion√°rios, etc.).\n\nVamos come√ßar com o b√°sico: o objeto range().\n\n\nC√≥digo\n# Lembra do objeto range()?\nrange(3)\n\n\nrange(0, 3)\n\n\nO comando acima n√£o imprime os n√∫meros, ele apenas cria um objeto que representa uma sequ√™ncia de 0 at√© 2 (tr√™s elementos, come√ßando do zero). Para visualizar os elementos, podemos convert√™-lo em uma lista:\n\n\nC√≥digo\nlist(range(3))\n\n\n[0, 1, 2]\n\n\nAgora vamos usar o range() dentro de um la√ßo for:\n\n\nC√≥digo\nfor i in range(3):\n    print(i)\n\n\n0\n1\n2\n\n\n\nAqui, o loop for vai executar o bloco de c√≥digo tr√™s vezes, e a vari√°vel i assume os valores 0, 1 e 2 a cada repeti√ß√£o.\n\nVoc√™ tamb√©m pode fazer a mesma coisa passando uma lista explicitamente:\n\n\nC√≥digo\nprint(f\"Lista exemplo para itera√ß√£o: {list(range(3))}\")\n\n\nLista exemplo para itera√ß√£o: [0, 1, 2]\n\n\nC√≥digo\nprint(\"Iniciando contagem:\")\n\n\nIniciando contagem:\n\n\nC√≥digo\nfor contador in list(range(3)):\n  print(f\"Passo {contador + 1}: Valor atual = {contador}\")\n\n\nPasso 1: Valor atual = 0\nPasso 2: Valor atual = 1\nPasso 3: Valor atual = 2\n\n\nC√≥digo\nprint(\"Contagem conclu√≠da!\")\n\n\nContagem conclu√≠da!\n\n\n\nO resultado ser√° o mesmo. Nesse caso, voc√™ est√° iterando diretamente sobre os elementos de uma lista.\n\n\n\nIterando em Strings\nStrings s√£o sequ√™ncias de caracteres, e podemos percorr√™-las com o for.\n\n\nC√≥digo\ntexto = \"Curso de Python para An√°lise de Dados.\"\nfor caractere in texto:\n    print(caractere)\n\n\nC\nu\nr\ns\no\n \nd\ne\n \nP\ny\nt\nh\no\nn\n \np\na\nr\na\n \nA\nn\n√°\nl\ni\ns\ne\n \nd\ne\n \nD\na\nd\no\ns\n.\n\n\n\nA cada repeti√ß√£o, a vari√°vel letra recebe um caractere da string. Esse recurso √© √∫til para manipula√ß√µes de texto.\n\n\n\n\nInterando em Listas\nSuponha que voc√™ tenha uma lista com nomes de frutas, e deseja imprimir cada fruta em letras mai√∫sculas.\n\n\nC√≥digo\n# Lista de frutas\nfrutas = [\"ma√ß√£\", \"banana\", \"laranja\", \"abacaxi\", \"uva\"]\n\n# Imprimindo cada fruta em caixa alta\nfor fruta in frutas:\n    print(fruta.upper())\n\n\nMA√á√É\nBANANA\nLARANJA\nABACAXI\nUVA\n\n\n\nO m√©todo upper() transforma a string para letras mai√∫sculas. A vari√°vel fruta assume o valor de cada elemento da lista a cada itera√ß√£o.\n\nVamos ver outro exemplo: elevar n√∫meros ao quadrado e ao cubo:\n\n\nC√≥digo\n# Criando a lista de n√∫meros de 0 a 5\nnumbers = list(range(6))\n\n# Iterando sobre a lista\nfor number in numbers:\n    print(f\"N√∫mero: {number}\")\n    print(f\"N√∫mero ao quadrado: {number ** 2}\")\n    print(f\"N√∫mero ao cubo: {number ** 3}\\n\")\n\n\nN√∫mero: 0\nN√∫mero ao quadrado: 0\nN√∫mero ao cubo: 0\n\nN√∫mero: 1\nN√∫mero ao quadrado: 1\nN√∫mero ao cubo: 1\n\nN√∫mero: 2\nN√∫mero ao quadrado: 4\nN√∫mero ao cubo: 8\n\nN√∫mero: 3\nN√∫mero ao quadrado: 9\nN√∫mero ao cubo: 27\n\nN√∫mero: 4\nN√∫mero ao quadrado: 16\nN√∫mero ao cubo: 64\n\nN√∫mero: 5\nN√∫mero ao quadrado: 25\nN√∫mero ao cubo: 125\n\n\n\nnumber assume os valores de 0 a 5 e cada itera√ß√£o √© mensurado o seu quadrado e o seu cubo.\n\n\n\n\nIterando em Dicion√°rios\nDicion√°rios s√£o estruturas de dados compostas por pares chave:valor. Podemos iterar por eles usando o m√©todo items(), que retorna as chaves e valores simultaneamente:\n\n\nC√≥digo\n# Dicion√°rio com tradu√ß√µes da palavra \"gato\"\ntranslations = {\"Portugu√™s\": \"gato\", \"Ingl√™s\": \"cat\", \"Franc√™s\": \"chat\"}\n\n# Percorrendo as chaves e os valores\nfor idioma, palavra in translations.items():\n    print(f\"{idioma} -&gt; {palavra}\")\n\n\nPortugu√™s -&gt; gato\nIngl√™s -&gt; cat\nFranc√™s -&gt; chat\n\n\n\nA cada itera√ß√£o, idioma recebe a chave e palavra recebe o valor correspondente.\n\nVoc√™ tamb√©m pode usar zip() para fazer a itera√ß√£o:\n\n\nC√≥digo\n# Outra forma de iterar: combinando as chaves e os valores com zip()\nfor idioma, palavra in zip(translations.keys(), translations.values()):\n    print(f\"{idioma} -&gt; {palavra}\")\n\n\nPortugu√™s -&gt; gato\nIngl√™s -&gt; cat\nFranc√™s -&gt; chat\n\n\n\nO zip() combina os elementos das duas listas (chaves e valores) em pares.\n\nIterando com enumerate(): √Äs vezes, al√©m de acessar o valor de uma lista ou dicion√°rio, tamb√©m queremos saber a posi√ß√£o (√≠ndice) do elemento. Para isso, usamos enumerate().\nVamos aplicar isso a um dicion√°rio um pouco mais complexo:\n\n\nC√≥digo\n# Dicion√°rio com informa√ß√µes de pessoas\ndados = {\n    \"Nome\": [\"Igor\", \"Allan\", \"Vict√≥ria\", \"Izabella\", \"Fernando\"],\n    \"Idade\": [39, 17, 98, 45, 27],\n    \"Animal de Estima√ß√£o\": [\"Gato\", \"Tigre\", \"Arara\", \"Javali\", \"Ratatouille\"]\n}\n\n# Percorrendo os dados\nfor i, key in enumerate(dados.keys()):\n    if i == 0:\n        print(\"Informa√ß√µes Coletadas:\")\n    for id in dados[key]:\n        if id == dados[key][0]:\n            print(f\"   {i + 1}. {key}:\")\n            print(f\"      {id}\")\n        else:\n            print(f\"      {id}\")\n\n\nInforma√ß√µes Coletadas:\n   1. Nome:\n      Igor\n      Allan\n      Vict√≥ria\n      Izabella\n      Fernando\n   2. Idade:\n      39\n      17\n      98\n      45\n      27\n   3. Animal de Estima√ß√£o:\n      Gato\n      Tigre\n      Arara\n      Javali\n      Ratatouille\n\n\n\nAqui temos dois n√≠veis de repeti√ß√£o. O primeiro la√ßo percorre cada ‚Äúcoluna‚Äù do dicion√°rio, enquanto o segundo imprime os dados. O enumerate() √© usado para acessar o √≠ndice i da chave atual, que nos ajuda a numerar facilitando a visualiza√ß√£o de chave a chave.\n\nEsse tipo de estrutura √© √∫til para imprimir dados de maneira organizada, como se fosse uma tabela ou relat√≥rio.\n\n\n\nCompreens√£o de Listas (List Comprehension)\nUma forma compacta e elegante de construir listas com base em la√ßos for √© a compreens√£o de listas.\nA sintaxe b√°sica √©:\n[expressao for item in lista]\nIsso pode ser lido como: aplique a expressao a cada item da lista.\nVejamos um exemplo simples.\n\n\nC√≥digo\n# Forma tradicional\nquadrados = []\nfor num in range(1, 11):\n    quadrados.append(num ** 2)\n\n# Visualizar\nprint(quadrados)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nC√≥digo\n# Forma com list comprehension\nquadrados = [num ** 2 for num in range(1, 11)]\n\n# Visualizar\nprint(quadrados)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\n\nA cada itera√ß√£o √© calculado o quadrado do num que assume valores de 1 a 10.\n\n\n\nCompreens√£o de Listas com Condi√ß√£o if\n√â poss√≠vel aplicar condicionais em compreens√£o de listas. De forma geral, a seguinte sintaxe √© seguida:\n[expression for item in list if condition]\nLogo, a linha de c√≥digo acima diz aplique a expression para cada item da list dado que condition √© verdadeira.\nVejamos alguns exemplos:\n\n\nC√≥digo\n# Forma tradiconal\npares = []\nfor num in range(1, 21):\n  if num % 2 == 0:\n    pares.append(num)\n\n# Visualizar  \nprint(pares)\n\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\nC√≥digo\n# Forma com list comprehension\npares = [num for num in range(1, 21) if num % 2 == 0]\n\n# Visualizar  \nprint(pares)\n\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\nApenas os n√∫meros pares ser√£o inclu√≠dos na lista.\n\nTamb√©m √© poss√≠vel combinar v√°rias condi√ß√µes:\n\n\nC√≥digo\n# Forma tradiconal\nmultiplos = []\nfor num in range(100):\n  if num % 2 == 0 and num % 5 == 0:\n    multiplos.append(num)\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n\n\nC√≥digo\n# Forma com list comprehension\nmultiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0]\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n\n\n\nA lista conter√° n√∫meros m√∫ltiplos de 2 e de 5.\n\n\n\nC√≥digo\n# Forma tradiconal\nmultiplos = []\nfor num in range(100):\n  if num % 2 == 0 and num % 5 == 0 and num % 6 == 0:\n    multiplos.append(num)\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 30, 60, 90]\n\n\nC√≥digo\n# Forma com list comprehension\nmultiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0 and num % 6 == 0]\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 30, 60, 90]\n\n\n\nA lista conter√° n√∫meros m√∫ltiplos de 2, 5 e 6.\n\n\n\nC√≥digo\n# Forma tradiconal\nmultiplos = []\nfor num in range(100):\n  if num % 2 == 0 and num % 5 == 0 or num % 6 == 0:\n    multiplos.append(num)\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 6, 10, 12, 18, 20, 24, 30, 36, 40, 42, 48, 50, 54, 60, 66, 70, 72, 78, 80, 84, 90, 96]\n\n\nC√≥digo\n# Forma com list comprehension\nmultiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0 or num % 6 == 0]\n\n# Visualizar  \nprint(multiplos)\n\n\n[0, 6, 10, 12, 18, 20, 24, 30, 36, 40, 42, 48, 50, 54, 60, 66, 70, 72, 78, 80, 84, 90, 96]\n\n\n\nA lista conter√° n√∫meros m√∫ltiplos de 2 e de 5 ou de 6.\n\n\n\n\nCompreens√£o de Listas com if e else\nA estrutura muda levemente:\n[expression_if if condition else expression_else for item in list]\nEm outras palavras: execute expression_if caso condition seja verdadeira e expression_else caso contr√°rio para cada item da list.\nVamos a um exemplo.\n\n\nC√≥digo\n# Forma tradiconal\nsucess_number_div_5 = []\nfor number in range(26):\n  if number % 5 == 0:\n    sucess_number_div_5.append(\"sucess\")\n  else:\n    sucess_number_div_5.append(\"failure\")\n\n# Visualizar  \nprint(sucess_number_div_5)\n\n\n['sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess']\n\n\nC√≥digo\n# Forma com list comprehension\nsucess_number_div_5 = [\"sucess\" if number % 5 == 0 else \"failure\" for number in range(26)]\n\n# Visualizar  \nprint(sucess_number_div_5)\n\n\n['sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess', 'failure', 'failure', 'failure', 'failure', 'sucess']\n\n\n\nA express√£o acima retorna uma lista com as palavras \"sucess\" ou \"failure\" dependendo do valor de cada n√∫mero.\n\n\n\n\nM√∫ltiplas Compreens√£o de Listas\nAqui √© exigida um pouco mais de aten√ß√£o. Considere a matriz \\mathbf{x} = \\begin{bmatrix} 1 & 2 & 3 & 4 \\\\ 5 & 6 & 7 & 8 \\\\ 9 & 10 & 11 & 12 \\end{bmatrix} e \\mathbf{x^{\\intercal}} = \\begin{bmatrix} 1 & 5 & 9 \\\\ 2 & 6 & 10 \\\\ 3 & 7 & 11 \\\\ 4 & 8 & 12 \\end{bmatrix}. Como fazer isso usando compreens√£o de listas?\n\n\nC√≥digo\nmatrix = [\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9, 10, 11, 12]\n]\n\nprint(matrix)\n\n\n[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n\n\nPara facilitar o entendimento e melhorar a aprendizagem, vamos fazer usando estrutura for de forma simples.\n\n\nC√≥digo\n# Forma tradiconal\ntransposta = []\nfor column in range(len(matrix[0])):\n  row = []\n  \n  for element in matrix:\n    row.append(element[column])\n    \n  transposta.append(row)\n\n# Visualizar  \nprint(transposta)\n\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n\n\nEntretanto, √© poss√≠vel otimizar o c√≥digo usando compreens√£o de listas.\n\n\nC√≥digo\n# Forma com list comprehension\ntransposta = [[element[column] for element in matrix] for column in range(len(matrix[0]))]\n\n# Visualizar  \nprint(transposta)\n\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n\n\n\n\n\n\n\nEstrutura while\nA estrutura de repeti√ß√£o while √© usada quando n√£o sabemos com anteced√™ncia quantas vezes o bloco de c√≥digo deve ser repetido. A repeti√ß√£o acontece enquanto uma condi√ß√£o l√≥gica for verdadeira. Assim que essa condi√ß√£o se torna falsa, o la√ßo √© encerrado automaticamente.\nA estrutura geral √©:\nwhile condi√ß√£o:\n    # bloco de c√≥digo\nIsso significa que o c√≥digo dentro do while ser√° executado repetidamente enquanto a condi√ß√£o especificada for verdadeira. Por isso, √© muito importante garantir que a condi√ß√£o eventualmente se torne falsa ‚Äî do contr√°rio, o programa pode entrar em um loop infinito.\n\n\nExemplos de Uso\n\nContador Simples\n\n\nC√≥digo\ncontador = 1\n\nwhile contador &lt;= 5:\n    print(f\"Contador: {contador}\")\n    contador += 1\n\n\nContador: 1\nContador: 2\nContador: 3\nContador: 4\nContador: 5\n\n\nEsse √© o uso mais b√°sico de um while. A vari√°vel de controle √© atualizada em cada repeti√ß√£o at√© que a condi√ß√£o se torne falsa.\n\n\n\nApenas N√∫meros Pares\n\n\nC√≥digo\nn = 1\n\nwhile n &lt;= 10:\n    if n % 2 == 0:\n        print(f\"{n} √© par\")\n    n += 1\n\n\n2 √© par\n4 √© par\n6 √© par\n8 √© par\n10 √© par\n\n\nNeste exemplo, o if dentro do while adiciona uma condi√ß√£o extra, filtrando apenas os n√∫meros pares entre 1 e 10.\n\n\n\nExemplo com input()\nnumber = int(input(\"Digite um n√∫mero positivo: \"))\n\nwhile number &lt;= 0:\n    print(\"O n√∫mero fornecido n√£o √© positivo. Tente novamente!\")\n    number = int(input(\"Digite um n√∫mero positivo: \"))\n\nprint(f\"Parab√™ns. O n√∫mero fornecido √© positivo!\")\nEsse exemplo usa input() para verificar se o valor digitado √© positivo ou n√£o.\n\n\n\nExemplo com string: invertendo uma palavra\n\n\nC√≥digo\npalavra = \"Python\"\nreverso = \"\"\ni = len(palavra) - 1\n\nwhile i &gt;= 0:\n    reverso += palavra[i]\n    i -= 1\n\nprint(f\"A palavra '{palavra}' invertida √© '{reverso}'.\")\n\n\nA palavra 'Python' invertida √© 'nohtyP'.\n\n\nAqui usamos while para percorrer uma string de tr√°s para frente e gerar sua vers√£o invertida.\n\n\n\nExemplo com lista: somando n√∫meros at√© esvaziar a lista\n\n\nC√≥digo\nnumeros = [10, 20, 30, 40, 50]\nsoma = 0\n\nwhile numeros:\n    valor = numeros.pop()  # Remove o √∫ltimo elemento\n    soma += valor\n\nprint(f\"Soma dos valores: {soma}\")\n\n\nSoma dos valores: 150\n\n\nEsse exemplo mostra como o while pode operar enquanto uma lista tiver elementos ‚Äî uma abordagem comum para estrutura de pilha.\n\n\n\nExemplo com m√∫ltiplas condi√ß√µes\n\n\nC√≥digo\ndados, i = [12, -3, 5, 0, -8, 19, -1, 0, 7], 0\n\npositivos, negativos, zeros = 0, 0, 0\n\nwhile i &lt; len(dados):\n    if dados[i] &gt; 0:\n        positivos += 1\n    elif dados[i] &lt; 0:\n        negativos += 1\n    else:\n        zeros += 1\n    i += 1\n\nprint(f\"Positivos: {positivos}, Negativos: {negativos}, Zeros: {zeros}\")\n\n\nPositivos: 4, Negativos: 3, Zeros: 2\n\n\nEsse exemplo simula uma classifica√ß√£o de dados usando while com m√∫ltiplas condi√ß√µes if-elif-else.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Controle de Fluxo & Fun√ß√µes em Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/03_FlowControl_&_Functions.html#comandos-chave",
    "href": "M√≥dulo I/03_FlowControl_&_Functions.html#comandos-chave",
    "title": "Controle de Fluxo & Fun√ß√µes em Python",
    "section": "Comandos-Chave",
    "text": "Comandos-Chave\nEm desenvolvimento Python, √† medida que a complexidade do c√≥digo aumenta, torna-se fundamental o dom√≠nio de mecanismos para o tratamento robusto de erros e o controle preciso da execu√ß√£o de estruturas de repeti√ß√£o. Esta se√ß√£o explora dois grupos essenciais de comandos que possibilitam um fluxo de execu√ß√£o mais refinado e resiliente.\n\nTratamento de Exce√ß√µes: Python oferece um conjunto de constru√ß√µes para o tratamento de exce√ß√µes, permitindo o desenvolvimento de c√≥digo capaz de responder de forma controlada a eventos inesperados durante a execu√ß√£o. Ao utilizar blocos try, except e, opcionalmente, finally, √© poss√≠vel interceptar e manipular erros, evitando a interrup√ß√£o abrupta do programa e implementando estrat√©gias de recupera√ß√£o ou finaliza√ß√£o controlada de recursos.\nControle de Fluxo em Loops: Adicionalmente √†s estruturas condicionais b√°sicas, Python disponibiliza palavras-chave espec√≠ficas para o controle do fluxo de execu√ß√£o dentro de la√ßos de repeti√ß√£o (for e while). Os comandos break e continue fornecem mecanismos para alterar o comportamento padr√£o dos loops:\n\nbreak: Interrompe a execu√ß√£o do loop corrente e transfere o controle para a pr√≥xima instru√ß√£o ap√≥s o loop.\ncontinue: Interrompe a itera√ß√£o corrente e passa para a pr√≥xima itera√ß√£o do loop.\n\n\nO dom√≠nio destas ferramentas de tratamento de exce√ß√µes e controle de fluxo em loops √© crucial para a escrita de c√≥digo Python robusto, eficiente e capaz de lidar com cen√°rios complexos de execu√ß√£o. A correta aplica√ß√£o destes conceitos contribui significativamente para a qualidade e a manutenibilidade de projetos de software.\n\n\nTratamento de Exce√ß√µes\nEm Python, erros em tempo de execu√ß√£o s√£o inevit√°veis (e.g., entrada inv√°lida, divis√£o por zero, arquivo ausente). O tratamento de exce√ß√µes, via blocos try/except, permite que o programa continue executando ao inv√©s de interromper. Ao prever e capturar erros espec√≠ficos, o c√≥digo reage de forma controlada, garantindo maior robustez e estabilidade da aplica√ß√£o. Essencial para software confi√°vel.\nUm exemplo da estrutura b√°sica √© apresentado no bloco de c√≥digo abaixo:\ntry:\n    # C√≥digo que pode gerar erros\n    numero = int(input(\"Digite um n√∫mero: \"))\n    resultado = 10 / numero\n    print(\"Resultado:\", resultado)\nexcept ZeroDivisionError:\n    # Executado se ocorrer o erro espec√≠fico\n    print(\"Erro: Divis√£o por zero!\")\nexcept Exception as e:\n    # Captura qualquer outro erro\n    print(f\"Erro inesperado: {e}\")\nelse:\n    # Executado se NENHUM erro ocorrer\n    print(\"Opera√ß√£o bem-sucedida!\")\nfinally:\n    # Sempre executado (com ou sem erros)\n    print(\"Fim do bloco try-except\")\n\n\nC√≥digo\ntry:\n    # C√≥digo que pode gerar erros\n    numero = 0\n    resultado = 10 / numero\n    print(\"Resultado:\", resultado)\nexcept ZeroDivisionError:\n    # Executado se ocorrer o erro espec√≠fico\n    print(\"Erro: Divis√£o por zero!\")\nexcept Exception as e:\n    # Captura qualquer outro erro\n    print(f\"Erro inesperado: {e}\")\nelse:\n    # Executado se NENHUM erro ocorrer\n    print(\"Opera√ß√£o bem-sucedida!\")\nfinally:\n    # Sempre executado (com ou sem erros)\n    print(\"Fim do bloco try-except\")\n\n\nErro: Divis√£o por zero!\nFim do bloco try-except\n\n\n\nO bloco try encapsula o c√≥digo pass√≠vel de gerar erros em tempo de execu√ß√£o.\nO bloco except especifica o tratamento para tipos particulares de erros (exce√ß√µes) que possam ocorrer dentro do bloco try. M√∫ltiplos blocos except podem ser definidos para lidar com diferentes tipos de exce√ß√µes. A captura gen√©rica de qualquer exce√ß√£o pode ser realizada com except Exception.\nO bloco finally √© executado invariavelmente, independentemente da ocorr√™ncia ou n√£o de uma exce√ß√£o dentro do bloco try. Sua principal aplica√ß√£o reside na execu√ß√£o de rotinas de finaliza√ß√£o, como o fechamento de arquivos ou a libera√ß√£o de conex√µes.\n\n\n\n\nPalavras-Chave\nDentro de la√ßos de repeti√ß√£o for e while em Python, as palavras-chave break e continue oferecem mecanismos essenciais para o controle preciso do fluxo de execu√ß√£o. break interrompe imediatamente a execu√ß√£o do loop, transferindo o controle para a instru√ß√£o seguinte ao bloco do loop. continue, por sua vez, encerra a itera√ß√£o corrente e passa para a pr√≥xima itera√ß√£o do loop. A utiliza√ß√£o estrat√©gica dessas palavras-chave contribui para a organiza√ß√£o e a efici√™ncia do c√≥digo em cen√°rios onde a execu√ß√£o padr√£o do loop necessita ser alterada condicionalmente.\n\n\nbreak\n\n\nC√≥digo\n# Encontra o primeiro n√∫mero divis√≠vel por 7\nfor num in range(1, 10):\n    if num % 7 == 0:\n        print(f\"Encontrado: {num}\")\n        break\n    print(num)\n\n\n1\n2\n3\n4\n5\n6\nEncontrado: 7\n\n\nwhile True:\n    senha = input(\"Digite a senha (1234) para sair: \")\n    if senha == \"1234\":\n        print(\"Senha correta! Saindo...\")\n        break\n    print(\"Senha incorreta!\")\n\n\n\ncontinue\n\n\nC√≥digo\n# N√£o ir√° imprimir o n√∫mero 7\nfor num in range(1, 10):\n    if num == 7:\n        continue\n    print(num)\n\n\n1\n2\n3\n4\n5\n6\n8\n9\n\n\n\n\nC√≥digo\nprodutos = [\"camiseta\", \"caneca\", None, \"poster\", \"\", \"adesivo\"]\nfor item in produtos:\n    if not item:  # None ou string vazia\n        continue\n    print(f\"Processando: {item.upper()}\")\n\n\nProcessando: CAMISETA\nProcessando: CANECA\nProcessando: POSTER\nProcessando: ADESIVO",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Controle de Fluxo & Fun√ß√µes em Python</span>"
    ]
  },
  {
    "objectID": "M√≥dulo I/03_FlowControl_&_Functions.html#fun√ß√µes",
    "href": "M√≥dulo I/03_FlowControl_&_Functions.html#fun√ß√µes",
    "title": "Controle de Fluxo & Fun√ß√µes em Python",
    "section": "Fun√ß√µes",
    "text": "Fun√ß√µes\nVamos relembrar o conceito de fun√ß√£o dada por Guidorizzi (2001):\n\n‚ÄúUma fun√ß√£o f √© uma rela√ß√£o entre dois conjuntos A e B, representada pela tripla (A, B, a \\mapsto b), onde A √© o conjunto de partida (dom√≠nio), B √© o conjunto de chegada (contradom√≠nio) e a \\mapsto b √© a regra que associa a cada elemento a \\in A um √∫nico elemento b \\in B.‚Äù\n\nPara fins t√©cnicos, as fun√ß√µes em Python seguem esse mesmo racioc√≠nio. Uma fun√ß√£o √© um bloco de c√≥digo que executa uma tarefa espec√≠fica e pode ser reutilizado v√°rias vezes ao longo do programa. Ao inv√©s de repetir o mesmo conjunto de comandos, colocamos esses comandos dentro de uma fun√ß√£o e chamamos essa fun√ß√£o sempre que precisarmos dela. Pense nela como uma ‚Äúminif√°brica‚Äù que recebe certas entradas (opcionalmente), processa-as e produz uma sa√≠da (opcionalmente).\nNo universo da programa√ß√£o, a capacidade de organizar o c√≥digo de forma organizad, modular e reutiliz√°vel √© um pilar para a constru√ß√£o de sistemas eficientes e de f√°cil manuten√ß√£o. Em Python, esse pilar √© sustentado pelas fun√ß√µes. Nesta se√ß√£o, exploraremos desde os conceitos b√°sicos at√© aspectos mais avan√ßados, com aplica√ß√µes pr√°ticas.\nVoc√™ pode pensar em uma fun√ß√£o como uma ‚Äúm√°quina‚Äù que recebe certos dados (chamados par√¢metros ou argumentos), processa esses dados e, em muitos casos, devolve um resultado (valor de retorno).\nA import√¢ncia das fun√ß√µes √© multifacetada, apresentando v√°rias vantagens de fazer seu uso. Elas s√£o fundamentais para:\n\nModularidade: Fun√ß√µes permitem quebrar programas grandes e complexos em partes menores e mais gerenci√°veis. Isso facilita o desenvolvimento, a depura√ß√£o e a compreens√£o do c√≥digo.\nReusabilidade de C√≥digo (DRY - Don‚Äôt Repeat Yourself): Uma vez definida, uma fun√ß√£o pode ser chamada m√∫ltiplas vezes de diferentes partes do programa, eliminando a necessidade de reescrever o mesmo c√≥digo repetidamente.\nAbstra√ß√£o: Fun√ß√µes escondem os detalhes de implementa√ß√£o de uma tarefa complexa. Voc√™ precisa saber o que a fun√ß√£o faz (sua finalidade), mas n√£o necessariamente como ela faz.\nManuten√ß√£o: Se uma altera√ß√£o for necess√°ria em uma l√≥gica espec√≠fica, basta modificar a fun√ß√£o correspondente. Isso √© muito mais eficiente do que procurar e alterar v√°rias ocorr√™ncias do mesmo c√≥digo espalhado pelo programa.\nLegibilidade: O uso de fun√ß√µes com nomes descritivos torna o c√≥digo mais f√°cil de ler e entender, pois cada fun√ß√£o representa uma etapa l√≥gica clara no fluxo do programa.\n\n\nSintaxe B√°sica\nEm Python, para definir uma fun√ß√£o √© utilizado a palavra chave def, seguida do nome da fun√ß√£o e par√™nteses para os poss√≠veis par√¢metros e :. Ao pressionar enter o bloco ser√° automaticamnete identado (quatro espa√ß√µes ou um tab) pelo editor. Todo c√≥digo identado faz parte da fun√ß√£o.\ndef name_function():\n  # seu c√≥digo ser√° disposto aqui\n  # e o Python ir√° compreende-lo como parte da fun√ß√£o\n\nExemplos:\n\n\n\nC√≥digo\ndef greeting1():\n  print(\"Ol√°. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!\")\n\n\ndef greeting2(nome):\n  print(f\"Ol√°, {nome}. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!\")\n  \n\ngreeting1()\n\n\nOl√°. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!\n\n\nC√≥digo\ngreeting2(\"Breno\")\n\n\nOl√°, Breno. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!\n\n\n\n\nPar√¢metros e Argumentos\nFun√ß√µes podem receber dados de entrada para realizar suas tarefas. Esses dados s√£o passados atrav√©s de par√¢metros na defini√ß√£o da fun√ß√£o e argumentos na chamada da fun√ß√£o.\n\n\nTipos de Par√¢metros/Argumentos:\n\nArgumentos Posicionais: S√£o os argumentos passados na ordem em que os par√¢metros s√£o definidos.\n\n\n\nC√≥digo\ndef saudar(nome, sobrenome):\n  print(f\"Ol√°, {nome} {sobrenome}!\")\n\nsaudar(\"Maria\", \"Silva\") # Sa√≠da: Ol√°, Maria Silva!\n\n\nOl√°, Maria Silva!\n\n\nC√≥digo\nsaudar(\"Silva\", \"Maria\") # Sa√≠da: Ol√°, Silva Maria!\n\n\nOl√°, Silva Maria!\n\n\n\nArgumentos de Palavra-chave (Keyword Arguments): S√£o passados explicitamente associando o nome do par√¢metro ao seu valor. A ordem n√£o importa.\n\n\n\nC√≥digo\ndef email(nome, dominio=\"icen.ufpa.br\"):\n    return f\"{nome.lower()}@{dominio}\"\n\nprint(email(nome=\"joao\"))                            # Sa√≠da: joao@icen.ufpa.br\n\n\njoao@icen.ufpa.br\n\n\nC√≥digo\nprint(email(dominio=\"ufpa.br\", nome=\"ANA\")) # Sa√≠da: ana@ufpa.br\n\n\nana@ufpa.br\n\n\n\nPar√¢metros com Valores Padr√£o (Default Parameters): Permitem definir um valor padr√£o para um par√¢metro. Se o argumento n√£o for fornecido na chamada da fun√ß√£o, o valor padr√£o √© utilizado.\n\n\n\nC√≥digo\ndef calcular_potencia(base, expoente=2): # expoente tem valor padr√£o 2\n    return base ** expoente\n\nprint(calcular_potencia(3))    # Sa√≠da: 9 (3^2)\n\n\n9\n\n\nC√≥digo\nprint(calcular_potencia(2, 4)) # Sa√≠da: 16 (2^4)\n\n\n16\n\n\nCuidado: Par√¢metros com valores padr√£o devem ser definidos ap√≥s os par√¢metros sem valores padr√£o.\n\nArgumentos Arbitr√°rios (*args e **kwargs): Permitem que uma fun√ß√£o aceite um n√∫mero vari√°vel de argumentos.\n\n\n*args (non-keyword arguments): Coleta um n√∫mero vari√°vel de argumentos posicionais em uma tupla.\n\n\n\nC√≥digo\ndef soma_tudo(*numeros):\n    total = 0\n    for num in numeros:\n        total += num\n    return total\n\nprint(soma_tudo(1, 2, 3))        # Sa√≠da: 6\n\n\n6\n\n\nC√≥digo\nprint(soma_tudo(10, 20, 30, 40)) # Sa√≠da: 100\n\n\n100\n\n\n\n**kwargs (keyword arguments): Coleta um n√∫mero vari√°vel de argumentos de palavra-chave em um dicion√°rio.\n\n\n\nC√≥digo\ndef exibir_perfil(**info):\n  for chave, valor in info.items():\n      print(f\"{chave.replace(\"_\", \" \").title()}: {valor}\")\n\nexibir_perfil(nome=\"Carlos\", idade=30, cidade=\"S√£o Paulo\")\n\n\nNome: Carlos\nIdade: 30\nCidade: S√£o Paulo\n\n\nC√≥digo\n# Sa√≠da:\n# Nome: Carlos\n# Idade: 30\n# Cidade: S√£o Paulo\n\nexibir_perfil(nome_cliente=\"Carlos\", idade_cliente=30, cidade_cliente=\"S√£o Paulo\")\n\n\nNome Cliente: Carlos\nIdade Cliente: 30\nCidade Cliente: S√£o Paulo\n\n\nC√≥digo\n# Sa√≠da:\n# Nome Cliente: Carlos\n# Idade Cliente: 30\n# Cidade Cliente: S√£o Paulo\n\n\n\n\nRetorno de Valores\nVimos que √© poss√≠vel imprimir valores na tela atrav√©s de fun√ß√µes. Entretanto e se precisarmos dos valores que s√£o calculados por determinada fun√ß√£o? De acordo com o que apreendemos basta atribuir a sa√≠da do programa a uma vari√°vel.\n\n\nC√≥digo\n# Atribui√ß√£o\ngrr = greeting2(\"Emilly Rose\")\n\n\nOl√°, Emilly Rose. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!\n\n\nTamb√©m de acordo com o que apreendemos, basta chamar a vari√°vel grr em qualquer parte do c√≥digo que ela mostrar√° a frase: Ol√°, Emilly Rose. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!.\n\n\nC√≥digo\n# Chamando vari√°vel\ngrr\n\n\nNote que a sa√≠da do c√≥digo acima, n√£o resultou em nada. Ou ainda, pode ter resultado, por√©m, o resutado foi vazio (None).\n\n\nC√≥digo\n# Verifica√ß√£o\ngrr == None\n\n\nTrue\n\n\nNote que, por consequ√™ncia, valores definidos dentro de uma fun√ß√£o n√£o s√£o exportados para fora dela. Isto √©, algo definido no local de um fun√ß√£o n√£o ser√° definido no ambiente global.\n\n\nC√≥digo\ndef minha_funcao():\n      arr = 10  # Vari√°vel local\n      print(arr)\n\nminha_funcao()\n\n\n10\n\n\nC√≥digo\ntry:\n  print(arr)  # Erro! 'arr' s√≥ existe dentro da fun√ß√£o.\n\nexcept NameError:\n  print(\"Vari√°vel 'arr' n√£o definida!\")\n\n\nVari√°vel 'arr' n√£o definida!\n\n\nIsso ocorre porque a estrutura que est√° sendo utilizada pela fun√ß√£o greeting2 n√£o foi feita para retornar valores, mas sim, para apenas os imprimir na tela.\n\nBoas Pr√°ticas de Escopo:\n\nPriorize o Escopo Local: √â uma boa pr√°tica projetar fun√ß√µes para serem o mais independentes poss√≠vel, evitando depender de vari√°veis globais. Isso melhora a modularidade e reduz efeitos colaterais indesejados.\nEvite o Uso de global: A palavra-chave global permite modificar uma vari√°vel global dentro de uma fun√ß√£o. Seu uso deve ser evitado ao m√°ximo, pois pode levar a um c√≥digo confuso e dif√≠cil de depurar. Se uma fun√ß√£o precisa alterar dados globais, √© prefer√≠vel que ela retorne os novos valores para que o c√≥digo chamador possa atualizar a vari√°vel global explicitamente.\nPassagem de Argumentos: Sempre que uma fun√ß√£o precisar de dados externos, passe-os como argumentos, em vez de depender de vari√°veis globais.\n\n\nPara que a fun√ß√£o realmente retorne o valor que foi obtido/calculado por ela, basta utilizar um comando interno do Python chamado return. Vamos a exemplos:\n\nSoma de dois termos:\n\n\n\nC√≥digo\ndef my_function_sum1(a, b):\n  summ = a + b\n  \n  return summ\n  \ndef my_function_sum2(a, b):\n  return a + b\n\n\na = my_function_sum1(1/2, 1/2)\nb = my_function_sum2(1/2, 1/2)\n\nprint(a == b)\n\n\nTrue\n\n\n\nSoma de n termos:\n\n\n\nC√≥digo\ndef my_function_sum(*numbers):\n  summ = 0\n  for num in numbers:\n    if type(num) == list:\n      for n in num:\n        if (type(n) != int) or (type(n) != float):\n          continue\n        \n        summ += n\n    else:\n        summ += num\n    \n  return summ\n  \nmy_function_sum([1, 2, \"a\", 3], 5, 10, 20, 32)\n\n\n67\n\n\nNote que, se eu quiser o resultados desta soma para us√°-lo em outra hora, basta atribuir isso a uma vari√°vel.\n\n\nC√≥digo\n# Guardando soma\nsumm = my_function_sum([1, 2, \"a\", 3], 5, 10, 20, 32)\n\n# Visualizando\nprint(summ)\n\n\n67\n\n\nC√≥digo\n# Verificando\nprint(summ == None) # A sa√≠da deve ser: False\n\n\nFalse\n\n\n\n\nFun√ß√µes An√¥nimas - lambda functions\nFun√ß√µes lambda s√£o pequenas fun√ß√µes an√¥nimas (sem nome) que s√£o definidas usando a palavra-chave lambda. Elas s√£o restritas a uma √∫nica express√£o e s√£o frequentemente usadas para tarefas curtas e simples onde uma fun√ß√£o completa seria excessiva.\n\nSintaxe: lambda argumentos: express√£o\n\n\n\nC√≥digo\n# Definindo fun√ß√£o an√¥nima\nsquare = lambda x: x ** 2\n\n# Fazendo uso da fun√ß√£o\nprint(square(2))\n\n\n4\n\n\nC√≥digo\n# Definindo fun√ß√£o an√¥nima\nlinear = lambda x, y: 2 * x + y\n\n# Fazendo uso da fun√ß√£o\nprint(linear(2, 3))\n\n\n7\n\n\nC√≥digo\n# Definindo fun√ß√£o an√¥nima\ntt = lambda x: x * 2 + x\n\n# Fazendo uso da fun√ß√£o\nprint(tt([1, 2, 3]))\n\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\nEssa maniera de se definir uma fun√ß√£o √© comumente usada em conjunto das fun√ß√µes sorted(), filter() e map().\n\n\nC√≥digo\nlist_of_numbers = [2.5, 1, 5, 9, 0.1, 2, 8, 3, 12]\n\n# Exemplo de uso com sorted()\nprint(sorted(list_of_numbers, key = lambda x: 1 / x ** 2))\n\n\n[12, 9, 8, 5, 3, 2.5, 2, 1, 0.1]\n\n\nC√≥digo\n# Exemplo de uso com filter()\nprint(list(filter(lambda x: x % 2 == 0, list_of_numbers)))\n\n\n[2, 8, 12]\n\n\nC√≥digo\n# Exemplo de um com map()\nprint(list(map(lambda x: x * 2, list_of_numbers)))\n\n\n[5.0, 2, 10, 18, 0.2, 4, 16, 6, 24]\n\n\n\n\n\n\n\n\n\n\n\n\n\nGuidorizzi, Hamilton Luiz. 2001. Um Curso de C√°lculo, Volume 1. 5¬™ ed. Rio de Janeiro: LTC.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Controle de Fluxo & Fun√ß√µes em Python</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Refer√™cias",
    "section": "",
    "text": "Guidorizzi, Hamilton Luiz. 2001. Um Curso de C√°lculo, Volume 1.\n5¬™ ed. Rio de Janeiro: LTC.",
    "crumbs": [
      "Refer√™cias"
    ]
  }
]