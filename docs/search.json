[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Python",
    "section": "",
    "text": "1 Introdução\nBem-vindo ao Curso de Python para Análise de Dados! Este curso foi cuidadosamente desenvolvido para introduzir você às ferramentas e técnicas fundamentais necessárias para trabalhar com dados de forma eficiente e profissional. Python é uma das linguagens mais utilizadas no mundo da ciência de dados, graças à sua simplicidade, flexibilidade e poderosas bibliotecas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#objetivo-do-curso",
    "href": "index.html#objetivo-do-curso",
    "title": "Curso de Python",
    "section": "1.1 Objetivo do Curso",
    "text": "1.1 Objetivo do Curso\nO objetivo principal deste curso é capacitar você a realizar análises de dados desde a coleta, manipulação e visualização até a exportação de relatórios. Ao final do curso, você será capaz de:\n\nManipular grandes conjuntos de dados com eficiência.\nCriar visualizações impactantes que auxiliam na tomada de decisões.\nAplicar técnicas exploratórias para compreender padrões e tendências nos dados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#público-alvo",
    "href": "index.html#público-alvo",
    "title": "Curso de Python",
    "section": "1.2 Público-Alvo",
    "text": "1.2 Público-Alvo\nEste curso é voltado para:\n\nIniciantes do curso que desejam iniciar seus estudos em Python para Análise de Dados\nEstudantes que procuram uma introdução sólida à ciência de dados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-do-curso",
    "href": "index.html#estrutura-do-curso",
    "title": "Curso de Python",
    "section": "1.3 Estrutura do Curso",
    "text": "1.3 Estrutura do Curso\nO curso está dividido em módulos que cobrem tópicos essenciais de forma progressiva:\n\nPython Básico: Aprenda os fundamentos da linguagem Python, incluindo sintaxe, estruturas de controle, manipulação de variáveis e funções.\nNumpy: Descubra como manipular arrays numéricos e realizar cálculos matemáticos com eficiência.\nPandas: Explore como carregar, manipular e analisar dados tabulares usando DataFrames e Series.\nMatplotlib e Seaborn: Domine as ferramentas de visualização de dados para criar gráficos informativos e visuais.\nRelatório de Análise de Dados: Combine todas as ferramentas aprendidas para realizar análises exploratórias completas e gerar relatórios que apresentam insights valiosos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#metodologia",
    "href": "index.html#metodologia",
    "title": "Curso de Python",
    "section": "1.4 Metodologia",
    "text": "1.4 Metodologia\nO curso combina teoria com prática, oferecendo:\n\nAulas explicativas: Conceitos apresentados de forma clara e objetiva.\nExemplos práticos: Demonstração de como aplicar as ferramentas e técnicas no mundo real.\nExercícios e projetos: Oportunidade de praticar e consolidar o aprendizado com desafios variados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#pré-requisitos",
    "href": "index.html#pré-requisitos",
    "title": "Curso de Python",
    "section": "1.5 Pré-requisitos",
    "text": "1.5 Pré-requisitos\n\nConhecimento básico em informática.\nNenhuma experiência prévia em programação é necessária, embora seja desejável.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#ferramentas-necessárias",
    "href": "index.html#ferramentas-necessárias",
    "title": "Curso de Python",
    "section": "1.6 Ferramentas Necessárias",
    "text": "1.6 Ferramentas Necessárias\n\nPython 3.7 ou superior.\nJupyter Notebook (recomendado), Programiz (recomendado apenas para coisas básicas), Google Colaboratory, Jupyter Notebook Online ou qualquer editor de código, como VSCode.\nInstalação das bibliotecas: numpy, pandas, matplotlib, seaborn.\n\n\nEsperamos que este curso seja uma jornada enriquecedora, ajudando você a adquirir habilidades práticas e teóricas para trabalhar com dados de forma confiante. Vamos começar!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "basicONE.html",
    "href": "basicONE.html",
    "title": "2  Primeiros Passos",
    "section": "",
    "text": "2.1 Introdução ao Python",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "basicONE.html#introdução-ao-python",
    "href": "basicONE.html#introdução-ao-python",
    "title": "2  Primeiros Passos",
    "section": "",
    "text": "2.1.1 O que é Python?\nPython é uma linguagem de programação poderosa e versátil. Em termos simples, isso significa que:\n\nEla segue regras específicas para organizar palavras e comandos (sintaxe);\nEsses comandos são interpretados pelo computador para realizar tarefas e resolver problemas.\n\nCom Python, escrevemos um código fonte que o computador interpreta e executa, realizando as tarefas que desejamos. Mas por que usar Python? Aqui estão algumas características que tornam Python uma escolha popular:\n\nInterpretada: O código é executado diretamente pelo interpretador, sem necessidade de compilação prévia.\nAlto nível: A linguagem abstrai detalhes técnicos do computador, permitindo que você se concentre na lógica do programa.\nPropósito geral: Pode ser usada em diversas áreas, como automação, análise de dados, inteligência artificial, desenvolvimento web e muito mais.\nTipagem dinâmica: O interpretador identifica automaticamente o tipo de dado de cada variável, simplificando o desenvolvimento.\n\nPor essas e várias outras características, Python é uma linguagem simples, elegante e altamente legível. Sua versatilidade a torna uma das linguagens mais populares do mundo, sendo utilizada por empresas como Google, NASA, Facebook, Amazon, Spotify e muitas outras para desenvolver soluções inovadoras.\n\n\n2.1.2 Instalação (Anaconda) e Primeiro Contato com o Jupyter Notebook\nPara começar a usar Python, recomendamos a instalação da Distribuição Anaconda, que inclui o Python e ferramentas úteis como o Jupyter Notebook, ideal para aprender e experimentar código.\n\nDownload do Anaconda: Clique aqui para baixar.\nVídeo de suporte: Assista a este tutorial de instalação no YouTube.\n\nSe tiver dúvidas durante a instalação, entre em contato comigo:\n\nEmail: breno.silva@icen.ufpa.br",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "basicONE.html#sintaxe-básica",
    "href": "basicONE.html#sintaxe-básica",
    "title": "2  Primeiros Passos",
    "section": "2.2 Sintaxe Básica",
    "text": "2.2 Sintaxe Básica\n\n2.2.1 Função print()\nVamos começar com o clássico Hello, World! em Python:\n\n\nCódigo\nprint(\"Hello, World!\")\n\n\nHello, World!\n\n\nEm programação, a palavra imprimir (ou print, em inglês) é usada para se referir à ação de exibir algo na tela.\nA função print() é uma das funções mais básicas e úteis do Python. Ela exibe na tela qualquer conteúdo que você passar entre os parênteses. Simples assim! :)\n\n2.2.1.1 Erros Comuns:\nAqui estão alguns erros comuns ao usar a função print() e como o Python responde a eles:\n\nUsar a letra P maiúscula ao invés de minúscula:\n\nPrint(\"Hello World!\")\nErro: NameError: name 'Print' is not defined.\n\nEsquecer de abrir e fechar aspas no texto que é passado para a função print():\n\nprint(Hello, World!)\nErro: SyntaxError: invalid syntax.\n\nEsquecer de abrir ou fechar as aspas:\n\nprint(\"Hello, World!)\nprint(Hello, World!\")\nErro: SyntaxError: unterminated string literal (detected at line 1)\n\nComeçar com aspas simples e terminar com aspas duplas ou vice-versa:\n\nprint('Hello, World!\")\nErro: SyntaxError: unterminated string literal (detected at line 1)\nCaso você precise usar aspas dentro do texto, siga estes exemplos:\n\n\nCódigo\nprint('Python é legal! Mas não o \"legal\" como dizem pra outras coisas')\n\n\nPython é legal! Mas não o \"legal\" como dizem pra outras coisas\n\n\nCódigo\nprint(\"Python é legal! Mas não o 'legal' como dizem pra outras coisas\")\n\n\nPython é legal! Mas não o 'legal' como dizem pra outras coisas\n\n\nPara imprimir um texto em várias linhas, use o caractere especial \\n, que indica uma quebra de linha. Por exemplo:\n\n\nCódigo\nprint(\"Veja esse texto. \\n Aspas duplas: \\\" \\n Aspas simples: '\")\n\n\nVeja esse texto. \n Aspas duplas: \" \n Aspas simples: '\n\n\n\n\n\n2.2.2 Operadores Matemáticos\nAssim como a matemática nos oferece uma variedade de operadores para realização de cálculos, o Python também faz uso desses operadores. Vamos explorar os principais:\n\nOperação de Soma (+) & Operação de Subtração (-):\n\n\n\nCódigo\n2 + 3\n\n\n5\n\n\n\n\nCódigo\n1.77 + 4.95\n\n\n6.720000000000001\n\n\n\n\nCódigo\n6 - 4\n\n\n2\n\n\n\n\nCódigo\n7 - 8\n\n\n-1\n\n\n\nOperação de Multiplicação (*) & Operação de Divisão (/):\n\n\n\nCódigo\n7 * 8\n\n\n56\n\n\n\n\nCódigo\n7.5 * 8.9\n\n\n66.75\n\n\n\n\nCódigo\n2 * 2 * 2\n\n\n8\n\n\n\n\nCódigo\n10 / 3\n\n\n3.3333333333333335\n\n\n\n\nCódigo\n666 / 137\n\n\n4.861313868613139\n\n\n\n\nCódigo\n50 / 0.75\n\n\n66.66666666666667\n\n\nAo fazer uma divisão por zero, é retornado o erro: ZeroDivisionError: division by zero. O Python também apresenta outras formas de dividir. Tem-se a chamada Divisão Inteira (//):\n\n\nCódigo\n10 // 3\n\n\n3\n\n\n\n\nCódigo\n666 // 137\n\n\n4\n\n\n\n\nCódigo\n50 // 0.75\n\n\n66.0\n\n\nNote que a divisão inteira retorna o quociente da divisão, descartando (truncando) a parte decimal. A outra divisão embutida no Python é aquela que retorna o Resto da Divisão (%):\n\n\nCódigo\n1 % 2\n\n\n1\n\n\n\n\nCódigo\n4 % 2\n\n\n0\n\n\n\n\nCódigo\n9 % 3\n\n\n0\n\n\nAgora que aprendemos os operadores aritméticos básicos, podemos avançar. Mas como calcular \\(2^{10}\\)? A abordagem mais intuitiva - e possível com o ensinado até aqui - seria multiplicar o número \\(2\\) por si mesmo dez vezes:\n\n\nCódigo\n2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\n\n\n1024\n\n\nNo entanto, essa abordagem não é a mais eficiente. Para facilitar cálculos de potência, o Python oferece um operador específico: o operador de Exponenciação (**).\n\n\nCódigo\n2 ** 10\n\n\n1024\n\n\n\n\nCódigo\n10 ** 3\n\n\n1000\n\n\n\n\nCódigo\n9 ** 0\n\n\n1\n\n\nSeguindo essa linha de raciocínio, para calcular a operação de raiz quadrada - lembrando que toda raiz na verdade, é um expoente, isto é, \\(\\sqrt{x} = x^{1/2}\\) - temos,\n\n\nCódigo\n81 ** 0.5\n\n\n9.0\n\n\nEntretanto, a forma mais adequada para realizar tal operação é é usar a função sqrt() da biblioteca math:\n\n\nCódigo\nimport math\nmath.sqrt(81)\n\n\n9.0\n\n\nNa primeira linha do exemplo, importamos o módulo math, biblioteca padrão do Python, e em seguida, utilizamos a função sqrt() para calcular \\(\\sqrt{81}\\). Lembre-se de executar import math antes de utilizar qualquer função ou constante desse módulo.\n\n\n2.2.3 Expressões Numéricas\nCom diversos operadores já apresentados, é possível combiná-los para resolver problemas mais complexos como expressões numéricas. Veja os exemplos:\n\n\nCódigo\n3 + 4 * 2\n\n\n11\n\n\n\n\nCódigo\n7 + 3 * 6 - 4 ** 2\n\n\n9\n\n\n\n\nCódigo\n(3 + 4) * 2\n\n\n14\n\n\n\n\nCódigo\n1 / (8 / 4) ** (5 - 2)\n\n\n0.125\n\n\nQuando uma expressão contém múltiplos operadores, a ordem de avaliação é determinada pelas regras de precedência. O Python segue as mesmas regras de precedência da matemática, frequentemente representadas pelo acrônimo PEMDAS:\n\nParênteses\nExponenciação\nMultiplicação e Divisão (mesma precedência)\nAdição e Subtração (mesma precedência)\n\n\n❗Nota: Ao trabalhar com números decimais em Python, pode-se observar um comportamento inesperado. Isso não é um erro no código ou na linguagem, mas uma consequência da forma como os computadores representam números de ponto flutuante.\nPor que isso acontece? A maioria dos computadores utiliza a representação binária (base 2) para armazenar números. O problema é que muitas frações decimais (base 10), como 0.1, não podem ser representadas exatamente em binário. Isso ocorre porque a representação binária tem um número finito de dígitos, assim como ocorre na representação decimal. Por exemplo, ao representar \\(1/3\\) em decimal, obtém-se uma repetição infinita: \\(0.3333 \\ldots\\) Da mesma forma, a conversão de 0.1 para binário gera uma fração periódica infinita.\nIEEE 754 e a precisão limitada: Os computadores modernos seguem o padrão IEEE 754 para representar números de ponto flutuante. Esse padrão define como os números são armazenados na memória, incluindo a precisão. Em Python, os números de ponto flutuante geralmente utilizam precisão dupla do IEEE 754, que oferece 53 bits de precisão. Quando um número como 0.1 é digitado, o computador encontra a fração binária mais próxima possível dentro desse limite de precisão. O resultado é um valor muito próximo de 0.1, mas não exatamente igual.\n\n\n\n2.2.4 Comparações Lógicas\nA Tabela 2.1 apresenta os operadores de comparação em Python e seus significados. Esses operadores são fundamentais para a construção de expressões lógicas e tomadas de decisão em programas. A tabela abaixo detalha cada operador:\n\n\n\n\nTabela 2.1: Operadores de Comparação e seus Significados\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n&lt;\nMenor que\n\n\n&gt;\nMaior que\n\n\n&lt;=\nMenor ou igual a\n\n\n&gt;=\nMaior ou igual a\n\n\n==\nIgual a\n\n\n!=\nDiferente de\n\n\n\n\n\n\n\n\nA seguir, são dados alguns exemplos.\n\n\nCódigo\n2 &lt; 10\n\n\nTrue\n\n\n\n\nCódigo\n2 &gt; 10\n\n\nFalse\n\n\n\n\nCódigo\nprint('Comparação Lógica - 10 menor que 10:', 10 &lt; 10)\n\n\nComparação Lógica - 10 menor que 10: False\n\n\nCódigo\nprint('Comparação Lógica - 10 maior que 10:', 10 &gt; 10)\n\n\nComparação Lógica - 10 maior que 10: False\n\n\nCódigo\nprint('Comparação Lógica - 10 menor ou igual a 10:', 10 &lt;= 10)\n\n\nComparação Lógica - 10 menor ou igual a 10: True\n\n\nCódigo\nprint('Comparação Lógica - 10 maior ou igual a 10:', 10 &gt;= 10)\n\n\nComparação Lógica - 10 maior ou igual a 10: True\n\n\nCódigo\nprint('Comparação Lógica - 10 igual a 10:', 10 == 10)\n\n\nComparação Lógica - 10 igual a 10: True\n\n\nCódigo\nprint('Comparação Lógica - 10 diferente de 10:', 10 != 10)\n\n\nComparação Lógica - 10 diferente de 10: False\n\n\nA Tabela 2.2 mostra conectores lógicos em Python, veja:\n\n\n\n\nTabela 2.2: Tabela de Operações e seus Significados\n\n\n\n\n\n\nOperação\nSignificado\n\n\n\n\nand\n1ª condição E 2ª condição\n\n\nor\n1ª condição OU 2ª condição\n\n\nnot\nNegação (Não)\n\n\nin\nEstá contido em\n\n\n\n\n\n\n\n\nVeja alguns exemplos dos conectores lógicos:\n\n\nCódigo\nprint((1 and 4) &lt; 3)\n\n\nFalse\n\n\nCódigo\nprint((1 or 4) &lt; 3)\n\n\nTrue\n\n\nCódigo\nprint((1 and 2 and 2.99) &lt; 3)\n\n\nTrue\n\n\nCódigo\nprint((1 or 2 or 2.99) &gt; 3)\n\n\nFalse\n\n\n\n\nCódigo\nprint((5 &gt;= 4.99) and (10 &lt;= 10.01))\n\n\nTrue\n\n\nCódigo\nprint((5 &gt;= 4.99) and (10 == 10.01))\n\n\nFalse\n\n\n\n\nCódigo\nprint((5 &gt;= 4.99) or (10 &lt;= 10.01))\n\n\nTrue\n\n\nCódigo\nprint((5 &gt;= 4.99) or (10 == 10.01))\n\n\nTrue\n\n\n\n\nCódigo\nprint(1 == 1)\n\n\nTrue\n\n\nCódigo\nprint(not 1 == 1)\n\n\nFalse\n\n\nCódigo\nprint(not not 1 == 1)\n\n\nTrue\n\n\nCódigo\nprint(not not not 1 == 1)\n\n\nFalse\n\n\n\n❗Nota: A ordem de prioridade dos operadores lógicos em Python segue regras específicas. Expressões booleanas referidas ao operador not possui maior precedência que and, que por sua vez tem maior precedência que or. Isso significa que not será avaliado antes de and, e and antes de or.\nObserve o exemplo abaixo, que ilustra essa hierarquia de avaliação:\n\n\n\nCódigo\nnot False and True or False\n\n\nTrue\n\n\n\nExplicação do código:\n\nO operador not é avaliado primeiro: not False resulta em True.\nEm seguida, and é avaliado: True and True resulta em True.\nPor fim, or é avaliado: True or False resulta em True.\n\n\n\n\n2.2.5 Variáveis e Atribuições\nUma variável é um nome que se refere a um valor (objetp). Já a atribuição é o processo de criar uma variável e associar um valor a ela. Veja alguns exemplos:\n\n\nCódigo\nnumero = 2 * 3\nnumero\n\n\n6\n\n\n\n\nCódigo\nfrase = \"Me dá um copo d'água.\"\nfrase\n\n\n\"Me dá um copo d'água.\"\n\n\n\n\nCódigo\npi = 3.141592\nprint(pi)\n\n\n3.141592\n\n\nCódigo\npi = math.pi\nprint(pi)\n\n\n3.141592653589793\n\n\nNo exemplo acima, foram realizadas três atribuições:\n\nA variável numero recebeu um valor inteiro.\nA variável frase armazenou uma string.\nA variável pi foi inicialmente atribuída a um valor de ponto flutuante e, em seguida, recebeu o valor mais preciso de \\(\\pi\\) disponível na biblioteca math.\n\n\n2.2.5.1 Nomes de Variáveis\nBons programadores escolhem nomes significativos para as suas variáveis, tal como fazem a documentação do propósito da mesma.É recomendável escolher nomes descritivos para variáveis, pois isso melhora a legibilidade do código e facilita sua manutenção.\nEm Python, os nomes de variáveis:\n\n✅Podem conter letras e números, mas não podem começar com números.\n✅Podem usar letras maiúsculas, embora a convenção seja utilizar apenas minúsculas.\n✅Não podem conter espaços nem caracteres especiais (exceto o underscore: _)\n\n\n\nCódigo\ncrieiumavariavelcomnomegiganteeestoucompreguiçadeescrevertudodenovo = 10\ncrieiumavariavelcomnomegiganteeestoucompreguiçadeescrevertudodenovo\n\n\n10\n\n\nTentar dar um nome ilegal a uma variável ocasionará erro de sintaxe:\n[Input]  : 123voa = 10\n[Output] : SyntaxError: invalid decimal literal\n[Input]  : ol@ = \"oi\"\n[Output] : SyntaxError: invalid syntax\n[Input]  : def = 2.7\n[Output] : SyntaxError: invalid syntax\nO nome 123voa é inválido porque começa com um número, enquanto ol@ contém um caractere especial (@). Já def não pode ser usado porque é uma palavra-chave da linguagem, ou seja, um termo reservado pelo Python para funções específicas.\nOutro erro comum ocorre ao tentar acessar uma variável que ainda não foi definida:\n[Input]  : nao_definida\n[Output] : NameError: name 'nao_definida' is not defined\n\n\n2.2.5.2 Atribuições com Expressões\nAlém de valores diretos, podemos atribuir expressões a variáveis:\n\n\nCódigo\nx = 3 * 5 - 2\nprint(x)\n\n\n13\n\n\nCódigo\ny = 3 * x + 10\nprint(y)\n\n\n49\n\n\nCódigo\nz = x + y\nprint(z)\n\n\n62\n\n\n\n\nCódigo\nn = 10\nn + 2  # Retorna 12, mas não altera 'n'\n\n\n12\n\n\n\n\nCódigo\n9 - n  # Retorna -1, mas não altera 'n'\n\n\n-1\n\n\nPara atualizar o valor de uma variável, podemos usar operadores de atribuição compostos:\n\n\nCódigo\nnum = 4\nnum += 3  # Equivalente a num = num + 3\nprint(num)\n\n\n7\n\n\nCódigo\nnum = 2\nnum *= 3  # Equivalente a num = num * 3\nprint(num)\n\n\n6\n\n\n\n\n2.2.5.3 Atribuição Múltipla\nImagine um problema que envolve duas variáveis a e b. O Python permite a atribuição múltipla, o que pode ser útil para trocar valores entre variáveis de forma eficiente.\n\n\nCódigo\na, b = 1, 200\nprint(a, b)  # Saída: 1 200\n\n\n1 200\n\n\nAgora, pense como poderiamos trocar os valores dessas variáveis. Pensou? Em algum momento deve ter passado pela sua cabeça a seguinte lógica:\n\n\nCódigo\na = b # Perde-se o valor original de a (1)\nprint(a)\n\n\n200\n\n\nCódigo\nb = a # Como perdeu-se a, `b vai continuar com seu valor original (200)\nprint(b)\n\n\n200\n\n\nEm outras linguagens, para trocar valores entre duas variáveis, seria necessário usar uma variável auxiliar:\n\n\nCódigo\na, b = 1, 200\nprint(a, b)  # Saída: 1 200\n\n\n1 200\n\n\nCódigo\naux = a\na = b\nb = aux\nprint(a, b)  # Agora a = 200 e b = 1\n\n\n200 1\n\n\nNo entanto, em Python, a troca pode ser feita de forma mais elegante usando atribuição múltipla:\n\n\nCódigo\na, b = 1, 200\nprint(a, b)  # Saída: 1 200\n\n\n1 200\n\n\nCódigo\na, b = b, a\nprint(a, b)  # Agora a = 200 e b = 1\n\n\n200 1\n\n\nEssa abordagem pode ser expandida para múltiplas variáveis:\n\n\nCódigo\na, b, c, d = 1, 2, 3, 4\nprint(a, b, c, d)\n\n\n1 2 3 4\n\n\nTambém podemos inverter os valores de várias variáveis de uma vez:\n\n\nCódigo\na, b, c, d = d, c, b, a\nprint(a, b, c, d)\n\n\n4 3 2 1\n\n\n\n\n\n2.2.6 Tipos de Objetos\nCriamos muitas variáveis até agora. Você se lembra do tipo de cada uma? Para verificar o tipo de um objeto ou variável, usamos a função type():\n\n\nCódigo\nx = 1\nprint(type(x))\n\n\n&lt;class 'int'&gt;\n\n\nCódigo\ny = 2.3\nprint(type(y))\n\n\n&lt;class 'float'&gt;\n\n\nCódigo\npalavra = \"Python\"\nprint(type(palavra))\n\n\n&lt;class 'str'&gt;\n\n\nCódigo\nlogic = True\nprint(type(logic))\n\n\n&lt;class 'bool'&gt;\n\n\nO Python possui alguns tipos básicos de objetos, entre eles:\n\nbool: Verdadeiro ou Falso (True ou False);\nint: Números Inteiros;\nfloat: Números Reais;\ncomplex: Números Complexos;\nstr: Textos ou conjunto de caracteres (strings);\ntuple: Listas imutáveis\nlist: Listas;\ndict: Dicionários.\n\nOs demais tipos de objetos serão abordados com mais detalhes posteriormente.\n\n\n2.2.7 Métodos e Atributos\nEm Python, os conceitos de métodos e atributos são fundamentais na programação orientada a objetos (POO). Eles definem as características e comportamentos dos objetos.\n\n2.2.7.1 Métodos\n\nDefinição:\n\nMétodos são funções definidas dentro de um objeto. Eles definem os comportamentos ou ações que um objeto pode realizar.\nPense neles como as “ações” que um objeto pode executar.\n\nExemplo:\n\nEm um objeto “carro”, métodos poderiam ser “ligar()”, “acelerar()” e “frear()”.\n\nAcesso:\n\nChamamos métodos usando a sintaxe objeto.método().\n\n\n\n\n2.2.7.2 Atributos\n\nDefinição:\n\nAtributos são variáveis que armazenam dados dentro de um objeto. Eles representam as características ou propriedades de um objeto.\nPense neles como as “informações” (sobre o objeto por isso características) que um objeto carrega consigo.\n\nExemplo:\n\nEm um objeto “carro”, atributos poderiam ser “cor”, “marca”, “modelo” e “ano”.\n\nAcesso:\n\nAcessamos atributos usando a sintaxe objeto.atributo.\n\n\n\n\n2.2.7.3 Relação entre Métodos e Atributos\nMétodos frequentemente manipulam os atributos de um objeto. Por exemplo, um método “acelerar()” pode modificar o atributo “velocidade” de um objeto carro.\nEm resumo:\n\nAtributos são as características que um objeto possui.\nMétodos são as ações que um objeto pode realizar.\n\nEssa distinção permite criar objetos que representam entidades do mundo real com suas próprias características e comportamentos.\n\n\n\n2.2.8 Buscando ajuda\nEstá com dúvida sobre algum comando ou função? Use a função help() e digite o que deseja buscar.\n\n\nCódigo\nhelp()\n\n\nWelcome to Python 3.12's help utility! If this is your first time using\nPython, you should definitely check out the tutorial at\nhttps://docs.python.org/3.12/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To get a list of available\nmodules, keywords, symbols, or topics, enter \"modules\", \"keywords\",\n\"symbols\", or \"topics\".\n\nEach module also comes with a one-line summary of what it does; to list\nthe modules whose name or summary contain a given string such as \"spam\",\nenter \"modules spam\".\n\nTo quit this help utility and return to the interpreter,\nenter \"q\" or \"quit\".\n\nhelp&gt; \nYou are now leaving help and returning to the Python interpreter.\nIf you want to ask for help on a particular object directly from the\ninterpreter, you can type \"help(object)\".  Executing \"help('string')\"\nhas the same effect as typing a particular string at the help&gt; prompt.\n\n\nPara obter ajuda sobre algo específico, basta passar o nome da função como argumento:\n\n\nCódigo\nhelp(print)\n\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\nCódigo\nimport math\nhelp(math.sqrt)\n\n\nHelp on built-in function sqrt in module math:\n\nsqrt(x, /)\n    Return the square root of x.\n\n\n\n\n2.2.9 Explorando as variáveis no código\nEm algum momento, você pode querer saber quais variáveis já foram declaradas ou verificar seus valores atuais. Podemos listar todas as variáveis declaradas no código usando o comando dir(). Veja um exemplo:\n\n\nCódigo\na = 1\nb = 2\ndir()\n\n\n['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'aux', 'b', 'c', 'crieiumavariavelcomnomegiganteeestoucompreguiçadeescrevertudodenovo', 'd', 'frase', 'logic', 'math', 'n', 'num', 'numero', 'os', 'palavra', 'pi', 'r', 'x', 'y', 'z']\n\n\nNote que as variáveis declaradas aparecem próximas ao final do resultado de dir(). Não se preocupe com os outros elementos exibidos — eles são criados e usados pelo próprio Python e não são relevantes no momento.\nOutra opção para visualizar as variáveis declaradas é utilizar os comandos globals() e locals(). Ambos mostram não apenas os nomes das variáveis, mas também seus valores atuais. A diferença entre eles está no escopo em que atuam, mas seus resultados são semelhantes:\n\n\nCódigo\nglobals()\n\n\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'os': &lt;module 'os' (frozen)&gt;, 'r': &lt;__main__.R object at 0x000001DDA88F0CB0&gt;, 'math': &lt;module 'math' (built-in)&gt;, 'numero': 6, 'frase': \"Me dá um copo d'água.\", 'pi': 3.141592653589793, 'crieiumavariavelcomnomegiganteeestoucompreguiçadeescrevertudodenovo': 10, 'x': 1, 'y': 2.3, 'z': 62, 'n': 10, 'num': 6, 'a': 1, 'b': 2, 'aux': 1, 'c': 2, 'd': 1, 'palavra': 'Python', 'logic': True}\n\n\n\n\nCódigo\nlocals()\n\n\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'os': &lt;module 'os' (frozen)&gt;, 'r': &lt;__main__.R object at 0x000001DDA88F0CB0&gt;, 'math': &lt;module 'math' (built-in)&gt;, 'numero': 6, 'frase': \"Me dá um copo d'água.\", 'pi': 3.141592653589793, 'crieiumavariavelcomnomegiganteeestoucompreguiçadeescrevertudodenovo': 10, 'x': 1, 'y': 2.3, 'z': 62, 'n': 10, 'num': 6, 'a': 1, 'b': 2, 'aux': 1, 'c': 2, 'd': 1, 'palavra': 'Python', 'logic': True}\n\n\nSe estiver usando o IPython, os comandos mágicos %who e %whos são ótimas alternativas, pois filtram as variáveis criadas internamente pelo Python, exibindo apenas aquelas que você declarou.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "basicONE.html#exercícios",
    "href": "basicONE.html#exercícios",
    "title": "2  Primeiros Passos",
    "section": "2.3 Exercícios",
    "text": "2.3 Exercícios\n1. Escreva um programa que imprima na tela a seguinte mensagem: Bem-vindo ao mundo Python!.\n2. Corrija os erros nos seguintes comandos print():\nprint(\"Python é incrível!)\nPrint('Aprendendo Python')\nprint(\"Python é legal! Mas não o 'legal como dizem pra outras coisas\")\n3. Utilize print() para exibir o seguinte texto em três linhas diferentes:\nAprender Python  \né muito  \ndivertido!\n4. Realize as operações matemáticas a seguir, guarde em uma variável e exiba os resultados. Além de determinar a ordem de execução conforme as regras de precedência matemática:\n\n\n\\[\\dfrac{100 − 413 \\cdot (20 − 5 \\times 4)}{5}\\]\n\n\n\\[\\dfrac{ \\left[(3^{4} + \\sqrt{144})(100 - 95,5) \\right] + 6 }{-80 + 2^{4}}\\]\n\n\n\\[3,9 \\cdot 10^{-2} + 5,2 \\cdot 10^{-1/3}\\]\n\n\n5. Os seguintes códigos contém erros. Identifique e corrija:\nprint('Vamos aprender Python!)\n10 + \"20\"\nx = 3\n10,35 x 0.01",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos</span>"
    ]
  },
  {
    "objectID": "basicTWO.html",
    "href": "basicTWO.html",
    "title": "3  Objetos no Python",
    "section": "",
    "text": "3.1 Introdução\nAo longo do curso, já mencionamos alguns tipos de objetos enquanto explorávamos conceitos básicos de Python. Você provavelmente já viu variáveis sendo criadas e usadas, e até notou que diferentes valores podem ter diferentes tipos. Agora, chegou o momento de entender melhor os objetos básicos do Python e como eles funcionam.\nNeste capítulo, vamos explorar os principais tipos de objetos que o Python nos oferece, como números, strings, listas e dicionários. Além disso, veremos como identificar o tipo de um objeto, buscar ajuda sobre funções e entender melhor as variáveis disponíveis no código.\nCom essa nova organização do curso, o conteúdo foi dividido em capítulos menores para facilitar o aprendizado. Isso evita que tudo seja ensinado de uma vez, tornando a experiência mais dinâmica e leve. Então, vamos começar nossa jornada pelos objetos do Python! 🚀",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "basicTWO.html#strings",
    "href": "basicTWO.html#strings",
    "title": "3  Objetos no Python",
    "section": "3.2 Strings",
    "text": "3.2 Strings\nTambém chamada de sequência de caracteres, textos ou dados alfanuméricos, uma string é um tipo de dado que armazena uma sequência de caracteres. Em Python, pode ser definida com aspas simples ('), duplas (\") ou triplas (''' ou \"\"\").\n\n\nCódigo\n\"Texto com acentos e cedilhas: hoje é dia de caça!\"\n\n\n'Texto com acentos e cedilhas: hoje é dia de caça!'\n\n\n\n\nCódigo\n# As strings aceitam aspas simples também\nnome = 'Silvio Santos'\nnome\n\n\n'Silvio Santos'\n\n\n\n3.2.1 Operações com Strings\nPodemos realizar diversas operações matemáticas e manipulações em strings.\n\n\nCódigo\n# Multiplicação repete a string\nnome * 3\n\n\n'Silvio SantosSilvio SantosSilvio Santos'\n\n\n[Input]:  nome * 3.14\n[Output]: TypeError: can't multiply sequence by non-int of type 'float'\n\n\nCódigo\n# Concatenação de strings\ncanto1 = 'vem aí, '\ncanto2 = 'lá '\nnome + ' ' + canto1 + canto2 * 6 + '!!'\n\n\n'Silvio Santos vem aí, lá lá lá lá lá lá !!'\n\n\n\n\n3.2.2 Strings Multilinhas\nPara definir strings que ocupam múltiplas linhas, utilize três aspas (''' ou \"\"\"):\n\n\nCódigo\nstr_grande = '''Aqui consigo inserir um textão com várias linhas.\nPosso iniciar em uma...\n... continuar em outra...\n... e seguir quantas precisar.'''\n\nstr_grande\n\n\n'Aqui consigo inserir um textão com várias linhas.\\nPosso iniciar em uma...\\n... continuar em outra...\\n... e seguir quantas precisar.'\n\n\n\n\nCódigo\nprint(str_grande)\n\n\nAqui consigo inserir um textão com várias linhas.\nPosso iniciar em uma...\n... continuar em outra...\n... e seguir quantas precisar.\n\n\nCaso seja necessário incluir aspas dentro da string, podemos alternar entre aspas simples e duplas:\n\n\nCódigo\nagua = \"Me dá um copo d'água\"\nagua\n\n\n\"Me dá um copo d'água\"\n\n\nTambém podemos usar todas as aspas ao mesmo tempo:\n\n\nCódigo\ntodas_as_aspas = \"\"\"Essa é uma string que tem:\n- aspas 'simples'\n- aspas \"duplas\"\n- aspas '''triplas'''\nLegal, né?\"\"\"\n                    \nprint(todas_as_aspas)\n\n\nEssa é uma string que tem:\n- aspas 'simples'\n- aspas \"duplas\"\n- aspas '''triplas'''\nLegal, né?\n\n\n\n\n3.2.3 Tamanho de uma String\nA função embutida len() nos permite obter o número de caracteres de uma string, incluindo espaços e pontuação:\n\n\nCódigo\nlen('Abracadabra')\n\n\n11\n\n\n\n\nCódigo\nfrase = 'Faz um pull request lá'\nlen(frase)\n\n\n22\n\n\n\n\nCódigo\npalavra = \"Python\"\nlen(palavra)\n\n\n6\n\n\n\n\n3.2.4 Manipulação de Strings\n\n3.2.4.1 Indexação\nCada caractere em uma string possui um índice, começando em 0 para o primeiro elemento e indo até len(string) - 1 para o último elemento ou -1.\n\nÍndices negativos percorrem de trás para frente\n\nPara um melhor entendimento inicial, considere a variável criada na subseção anterir:palavra. Partindo da definição acima, podemos afirmar que os índices da variável palavra segue o formato:\n\n\n\nP\ny\nt\nh\no\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n-6\n-5\n-4\n-3\n-2\n-1\n\n\n\nVejamos alguns exemplos:\n\n\nCódigo\n# Primeiro caractere\nprint(palavra[0])\n\n\nP\n\n\nCódigo\nprint(palavra[-6])\n\n\nP\n\n\n\n\nCódigo\n# Primeiro caractere\nprint(palavra[5])\n\n\nn\n\n\nCódigo\nprint(palavra[-1])\n\n\nn\n\n\n\n\n3.2.4.2 Fatiamento\nFatiamento (slincing) é a capacidade de extrair partes de uma string utilizando inicio:fim - 1:passo.\n\n\nCódigo\n# Guardando um objeto do tipo str na variável frase\nfrase = \"A programação em \" + palavra + \" é diferenciada!\"\nfrase\n\n\n'A programação em Python é diferenciada!'\n\n\n\n\nCódigo\n# Comprimento da variável frase\nnStr = len(frase)\nnStr\n\n\n39\n\n\n\n\nCódigo\n# Obtendo a frase completa usando fatiamento\nprint(frase[:nStr - 1])\n\n\nA programação em Python é diferenciada\n\n\nCódigo\nprint(frase[-nStr:])\n\n\nA programação em Python é diferenciada!\n\n\n\n\nCódigo\n# Obtendo a frase de dois em dois caractere\nprint(frase[:nStr - 1:2])\n\n\nApormçoe yhnédfrnid\n\n\nCódigo\nprint(frase[-nStr::2])\n\n\nApormçoe yhnédfrnid!\n\n\n\n\nCódigo\n# Obtendo apenas 'A programação'\nprint(frase[:14])\n\n\nA programação \n\n\nCódigo\nprint(frase[:-25])\n\n\nA programação \n\n\n\n\nCódigo\n# Obtendo o que há depois de 'A programação'\nprint(frase[14:])\n\n\nem Python é diferenciada!\n\n\nCódigo\nprint(frase[-25:])\n\n\nem Python é diferenciada!\n\n\n\n\nCódigo\n# Obtendo toda a frase de trás para frente\nprint(frase[::-1])\n\n\n!adaicnerefid é nohtyP me oãçamargorp A\n\n\n\nNota: Omitir o primeiro índice (start) ou o segundo índice (stop) significa, respectivamente, começar desde o começo ou terminar no fim.\n\nResumindo: para fazer uma fatia de nossa string, precisamos saber de onde começa, até onde vai e o tamanho do passo.\nfatiável[começo : fim : passo]\n\n3.2.4.2.1 Atenção para o uso de indexação e fatiamento\nAs fatias incluem o índice do primeiro elemento e não incluem o elemento do índice final. Por isso que frase[0:-1] perde o último elemento.\nCaso o fim da fatia seja antes do começo, obtemos um resultado vazio:\n\n\nCódigo\nfrase[59:105]\n\n\n''\n\n\nO que acontece com uma fatia que está fora da string?\n\n\nCódigo\nfrase[123:345]\n\n\n''\n\n\nE se o fim da fatia for superior ao comprimento da string? Sem problemas, o Python pecorrer a string até o onde der:\n\n\nCódigo\nfrase[8:123456789]\n\n\n'mação em Python é diferenciada!'\n\n\nMas um índice fora do intervalo em acesso direto gera erro:\n[Input]  : frase[123456789]\n[Output] : IndexError: string index out of range\nQuando usamos passos negativos, a fatia começa no fim e termina no começo e é percorrida ao contrário. Ou seja, invertemos a ordem. Mas tome cuidado:\n\n\nCódigo\n\"Python\"[2:6]\n\n\n'thon'\n\n\n\n\nCódigo\n\"Python\"[2:6:-1]\n\n\n''\n\n\n\n\nCódigo\n\"Python\"[6:2]\n\n\n''\n\n\n\n\nCódigo\n\"Python\"[6:2:-1]\n\n\n'noh'\n\n\n\n\"Python\"[6:2]: O índice de início (6) é maior que o índice de fim (2), e o passo é positivo (default). Nesse caso, o resultado é uma string vazia, pois o slicing avança para a direita, mas o fim está à esquerda.\n\"Python\"[2:6:-1]: O índice de início (2) é menor que o índice de fim (6), mas o passo é negativo (-1). O slicing tenta avançar para a esquerda, mas o fim está à direita. Novamente, o resultado é uma string vazia.\n\"Python\"[6:2:-1]: O índice de início (6) é maior que o índice de fim (2), e o passo é negativo (-1). O slicing avança para a esquerda, começando do índice 6 (‘n’) até o índice 2 (‘t’), excluindo-o. Isso resulta na string “noh”.\n\n\n\n\n\n3.2.5 Formatação de Strings\nPodemos formatar strings utilizando f-strings, .format() ou %:\n\n\nCódigo\nnome = \"Breno\"\nidade = 25\n\nprint(f\"Olá, meu nome é {nome} e tenho {idade} anos.\")  # f-strings\n\n\nOlá, meu nome é Breno e tenho 25 anos.\n\n\nCódigo\nprint(\"Olá, meu nome é {} e tenho {} anos.\".format(nome, idade))  # format()\n\n\nOlá, meu nome é Breno e tenho 25 anos.\n\n\nCódigo\nprint(\"Olá, meu nome é %s e tenho %d anos.\" % (nome, idade))  # Estilo antigo\n\n\nOlá, meu nome é Breno e tenho 25 anos.\n\n\nO autor recomenda usar a primeira opção.\n\n\n3.2.6 Métodos Úteis para Strings\n\n3.2.6.1 Método split()\n\n\nCódigo\n# E da variável todas_as_aspas?\ntodas_as_aspas\n\n\n'Essa é uma string que tem:\\n- aspas \\'simples\\'\\n- aspas \"duplas\"\\n- aspas \\'\\'\\'triplas\\'\\'\\'\\nLegal, né?'\n\n\n\n\nCódigo\n# Aplicando método splint sem argumento (default)\nprint(todas_as_aspas.split())\n\n\n['Essa', 'é', 'uma', 'string', 'que', 'tem:', '-', 'aspas', \"'simples'\", '-', 'aspas', '\"duplas\"', '-', 'aspas', \"'''triplas'''\", 'Legal,', 'né?']\n\n\nCódigo\n# Aplicando método splint com argumento\nprint(todas_as_aspas.split(\"\\n\"))\n\n\n['Essa é uma string que tem:', \"- aspas 'simples'\", '- aspas \"duplas\"', \"- aspas '''triplas'''\", 'Legal, né?']\n\n\n\n\nCódigo\n# Lembra da variável frase?\nprint(frase)\n\n\nA programação em Python é diferenciada!\n\n\nCódigo\n# Veja como ela fica depois do método split\nprint(frase.split())\n\n\n['A', 'programação', 'em', 'Python', 'é', 'diferenciada!']\n\n\n\n\n3.2.6.2 Outros métodos\n\n\nCódigo\ntexto = \" Python é legal! \"\nprint(texto.lower())     # Deixa tudo minúscula\n\n\n python é legal! \n\n\nCódigo\nprint(texto.upper())     # Deixa tudo maiúscula\n\n\n PYTHON É LEGAL! \n\n\nCódigo\nprint(texto.strip())     # Remove espaços extras\n\n\nPython é legal!\n\n\nCódigo\nprint(texto.replace(\"Python\", \"Programar\"))  # Troca 'Python' por 'Programar'\n\n\n Programar é legal! \n\n\nCódigo\nprint(texto.index(\"é\"))  # Retorna o índice da primeira ocorrência de 'é'\n\n\n8\n\n\nCódigo\nprint(texto.count(\"a\"))  # Conta quantas vezes 'a' aparece\n\n\n1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "basicTWO.html#listas",
    "href": "basicTWO.html#listas",
    "title": "3  Objetos no Python",
    "section": "3.3 Listas",
    "text": "3.3 Listas\nListas são uma das estruturas de dados mais usadas em Python. Elas permitem armazenar múltiplos valores em uma única variável e suportam diversos tipos de operações.\n\n3.3.1 Declaração de Listas\nUma lista em Python é definida utilizando colchetes [], e seus elementos são separados por vírgulas:\n\n\nCódigo\n# Lista de números\nnumeros = [1, 2, 3, 4, 5]\n\n# Lista de strings\nfrutas = [\"maça\", \"banana\", \"abacaxi\"]\n\n# Lista mista\ndados = [25, \"João\", True, 3.14]\n\n\nUma lista também pode ser vazia, algo que futaremente veremos que pode ser muito útil, por exemplo:\n\n\nCódigo\nvazia = []\nvazia\n\n\n[]\n\n\n\n\n3.3.2 Indexação e Fatiamento\nA ideia de índices e fatias de listas funciona de forma muito parecida com a que foi vista em strings.\n\n\nCódigo\nnumeros[0] # Primeiro elemento\n\n\n1\n\n\n\n\nCódigo\nnumeros[-1] # Último elemento\n\n\n5\n\n\nAssim como na indexação de strings, ao tentar acessar um índice inválido de uma lista é retornado um erro.\nAo ínves de simplesmente acessar um elemneto através de seu índice, podemos obter uma fatia, que pode ser muito mais interessante.\n\n\nCódigo\nnumeros[::2] # Do começo ao fim, de 2 em 2 elementos\n\n\n[1, 3, 5]\n\n\n\n\nCódigo\nnumeros[::-2] # Do fim ao começo, de 2 em 2 elementos\n\n\n[5, 3, 1]\n\n\n\n\nCódigo\nnumeros[:3]   # Três primeiros elementos\n\n\n[1, 2, 3]\n\n\n\n\nCódigo\nnumeros[3:]   # Elementos a partir do índice 3\n\n\n[4, 5]\n\n\n\n\nCódigo\nnumeros[::-1] # Lista invertida\n\n\n[5, 4, 3, 2, 1]\n\n\n\n\n3.3.3 Trabalhando com Listas\nImagine que se queira saber se um determinado elemento (objeto) está contido em determinada lista. Poderiamos ficar procurando elemento a elemento, vamos tentar essa abordagem. Verifique se o elemento 0.3146778807984779 está contido na lista abaixo:\n\n\nCódigo\nimport random as rd\n\nrd.seed(42)\n\nva = [rd.random() for _ in range(100)]\nva\n\n\n[0.6394267984578837, 0.025010755222666936, 0.27502931836911926, 0.22321073814882275, 0.7364712141640124, 0.6766994874229113, 0.8921795677048454, 0.08693883262941615, 0.4219218196852704, 0.029797219438070344, 0.21863797480360336, 0.5053552881033624, 0.026535969683863625, 0.1988376506866485, 0.6498844377795232, 0.5449414806032167, 0.2204406220406967, 0.5892656838759087, 0.8094304566778266, 0.006498759678061017, 0.8058192518328079, 0.6981393949882269, 0.3402505165179919, 0.15547949981178155, 0.9572130722067812, 0.33659454511262676, 0.09274584338014791, 0.09671637683346401, 0.8474943663474598, 0.6037260313668911, 0.8071282732743802, 0.7297317866938179, 0.5362280914547007, 0.9731157639793706, 0.3785343772083535, 0.552040631273227, 0.8294046642529949, 0.6185197523642461, 0.8617069003107772, 0.577352145256762, 0.7045718362149235, 0.045824383655662215, 0.22789827565154686, 0.28938796360210717, 0.0797919769236275, 0.23279088636103018, 0.10100142940972912, 0.2779736031100921, 0.6356844442644002, 0.36483217897008424, 0.37018096711688264, 0.2095070307714877, 0.26697782204911336, 0.936654587712494, 0.6480353852465935, 0.6091310056669882, 0.171138648198097, 0.7291267979503492, 0.1634024937619284, 0.3794554417576478, 0.9895233506365952, 0.6399997598540929, 0.5569497437746462, 0.6846142509898746, 0.8428519201898096, 0.7759999115462448, 0.22904807196410437, 0.03210024390403776, 0.3154530480590819, 0.26774087597570273, 0.21098284358632646, 0.9429097143350544, 0.8763676264726689, 0.3146778807984779, 0.65543866529488, 0.39563190106066426, 0.9145475897405435, 0.4588518525873988, 0.26488016649805246, 0.24662750769398345, 0.5613681341631508, 0.26274160852293527, 0.5845859902235405, 0.897822883602477, 0.39940050514039727, 0.21932075915728333, 0.9975376064951103, 0.5095262936764645, 0.09090941217379389, 0.04711637542473457, 0.10964913035065915, 0.62744604170309, 0.7920793643629641, 0.42215996679968404, 0.06352770615195713, 0.38161928650653676, 0.9961213802400968, 0.529114345099137, 0.9710783776136181, 0.8607797022344981]\n\n\nNote que não é viável essa abordagem. Para está finalidade devemos usar o operador lógico in. Veja o exemplo:\n\n\nCódigo\n0.3146778807984779 in va # 'elemento' está contido em 'lista'\n\n\nTrue\n\n\nLembra do operador not? Podemos combiná-lo com o in para verificar se um elemento ‘não está’ contido em uma determina lista. Sendo o contrário (negação) da afirmação acima.\n\n\nCódigo\n0.3146778807984779 not in va # 'elemento' não está contido em 'lista'\n\n\nFalse\n\n\nVeja um exemplo de como o in funciona em uma outra situação.\n\n\nCódigo\nlista_mista = ['duas palavras', 42, True, ['batman', 'robin'], -0.84, 'hipófise']\n42 in lista_mista\n\n\nTrue\n\n\n\n\nCódigo\n'batman' in lista_mista\n\n\nFalse\n\n\n\n\nCódigo\n'batman' in lista_mista[3] # Note que o elemento com índice 3 também é uma lista\n\n\nTrue\n\n\nConsegue me dizer quantos elementos têm na lista va? Fique tranquilo! Não precisa contar, pode ser usado a função len do Python para responder essa pergunta.\n\n\nCódigo\nlen(va)\n\n\n100\n\n\n\n\nCódigo\nlen(lista_mista[3])\n\n\n2\n\n\n\n\n3.3.4 Adicionar e Remover elementos de uma Lista\nPodemos adicionar elementos de diversas formas:\n\n\nCódigo\n# Adiciona um único elemento ao final da lista\nnumeros.append(6)\nnumeros\n\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nCódigo\n# Adiciona vários elementos ao final da lista\nnumeros.extend([7, 8, 9])\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nCódigo\n# Adiciona um elemento em uma posição específica\nnumeros.insert(2, 15)  # Insere o número 15 na posição 2 (3º elemento)\nnumeros\n\n\n[1, 2, 15, 3, 4, 5, 6, 7, 8, 9]\n\n\nPodemos remover/excluir elementos de uma lista das seguintes formas:\n\n\nCódigo\n# Remove a primeira ocorrência de um valor específico\nnumeros.remove(15)  # Remove o número 15\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nCódigo\n# Exclui o último elemento da lista\ndel numeros[-1]\nnumeros\n\n\n[1, 2, 3, 4, 5, 6, 7, 8]\n\n\nE se, por exemplo, eu precisar começar a lista do zero? Pode-se remover todos os elementos de uma lista, usando o método clear():\n\n\nCódigo\nva.clear()\nprint(\"Lista de números aleatórios:\")\n\n\nLista de números aleatórios:\n\n\nCódigo\nprint(va)\n\n\n[]\n\n\nCódigo\nva = [rd.random() for _ in range(100)]\nprint(\"Lista de números aleatórios:\")\n\n\nLista de números aleatórios:\n\n\nCódigo\nprint(va)\n\n\n[0.011481021942819636, 0.7207218193601946, 0.6817103690265748, 0.5369703304087952, 0.2668251899525428, 0.6409617985798081, 0.11155217359587644, 0.434765250669105, 0.45372370632920644, 0.9538159275210801, 0.8758529403781941, 0.26338905075109076, 0.5005861130502983, 0.17865188053013137, 0.9126278393448205, 0.8705185698367669, 0.2984447914486329, 0.6389494948660052, 0.6089702114381723, 0.1528392685496348, 0.7625108000751513, 0.5393790301196257, 0.7786264786305582, 0.5303536721951775, 0.0005718961279435053, 0.3241560570046731, 0.019476742385832302, 0.9290986162646171, 0.8787218778231842, 0.8316655293611794, 0.30751412540266143, 0.05792516649418755, 0.8780095992040405, 0.9469494452979941, 0.08565345206787878, 0.4859904633166138, 0.06921251846838361, 0.7606021652572316, 0.7658344293069878, 0.1283914644997628, 0.4752823780987313, 0.5498035934949439, 0.2650566289400591, 0.8724330410852574, 0.4231379402008869, 0.21179820544208205, 0.5392960887794583, 0.7299310690899762, 0.2011510633896959, 0.31171629130089495, 0.9951493566608947, 0.6498780576394535, 0.43810008391450406, 0.5175758410355906, 0.12100419586826572, 0.22469733703155736, 0.33808556214745533, 0.5883087184572333, 0.230114732596577, 0.22021738445155947, 0.07099308600903254, 0.6311029572700989, 0.22894178381115438, 0.905420013006128, 0.8596354002537465, 0.07085734988865344, 0.23800463436899522, 0.6689777782962806, 0.2142368073704386, 0.132311848725025, 0.935514240580671, 0.5710430933252845, 0.47267102631179414, 0.7846194242907534, 0.8074969977666434, 0.1904099143618777, 0.09693081422882333, 0.4310511824063775, 0.4235786230199208, 0.467024668036675, 0.7290758494598506, 0.6733645472933015, 0.9841652113659661, 0.09841787115195888, 0.4026212821022688, 0.33930260539496315, 0.8616725363527911, 0.24865633392028563, 0.1902089084408115, 0.4486135478331319, 0.4218816398344042, 0.27854514466694047, 0.2498064478821005, 0.9232655992760128, 0.44313074505345695, 0.8613491047618306, 0.5503253124498481, 0.05058832952488124, 0.9992824684127266, 0.8360275850799519]\n\n\n\n\n3.3.5 Modificando elementos\nComo as listas são mutáveis, podemos alterar seus valores diretamente:\n\n\nCódigo\nprint(f\"Antes da modificação: \\n {frutas}\")\n\n\nAntes da modificação: \n ['maça', 'banana', 'abacaxi']\n\n\nCódigo\n# Alterando 'banana' por 'melancia'\nfrutas[1] = \"melancia\"\n\n# Visualizando\nprint(f\"Depois da modificação: \\n {frutas}\")\n\n\nDepois da modificação: \n ['maça', 'melancia', 'abacaxi']\n\n\nOutra forma de se fazer a modificação é:\n\n\nCódigo\n# Obtendo a posição (índice) da fruta (string) 'melancia'\nid = frutas.index(\"melancia\")\n\n# Alterando 'melancia' por 'banana'\nfrutas[id] = \"melancia\"\n\n# Visualizando\nprint(frutas)\n\n\n['maça', 'melancia', 'abacaxi']\n\n\n\n\n3.3.6 Ordenação de Listas\nPor vários motivos, pode ser útil ter em mãos uma lista ordenada. Como fazer isso? Veja os exemplos:\n\n\nCódigo\ndesordenada = ['b', 'z', 'k', 'a', 'h']\nprint(f\"Lista desordenada: \\n {desordenada}\")\n\n\nLista desordenada: \n ['b', 'z', 'k', 'a', 'h']\n\n\nCódigo\n# Ordenando\ndesordenada.sort()\nprint(f\"Lista ordenada: \\n {desordenada}\")\n\n\nLista ordenada: \n ['a', 'b', 'h', 'k', 'z']\n\n\nVoltemos a lista va:\n\n\nCódigo\n# Modificando va um pouco\nva_modified = [round(va[i] * 100) for i in range(len(va))]\nprint(va_modified)\n\n\n[1, 72, 68, 54, 27, 64, 11, 43, 45, 95, 88, 26, 50, 18, 91, 87, 30, 64, 61, 15, 76, 54, 78, 53, 0, 32, 2, 93, 88, 83, 31, 6, 88, 95, 9, 49, 7, 76, 77, 13, 48, 55, 27, 87, 42, 21, 54, 73, 20, 31, 100, 65, 44, 52, 12, 22, 34, 59, 23, 22, 7, 63, 23, 91, 86, 7, 24, 67, 21, 13, 94, 57, 47, 78, 81, 19, 10, 43, 42, 47, 73, 67, 98, 10, 40, 34, 86, 25, 19, 45, 42, 28, 25, 92, 44, 86, 55, 5, 100, 84]\n\n\nCódigo\nprint()\n\n\nCódigo\n# Ordenado de forma crescente\nva_modified.sort()\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\nCódigo\n# Ordenado de forma decrescente\nva_modified.sort(reverse=True)\nprint(va_modified)\n\n\n[100, 100, 98, 95, 95, 94, 93, 92, 91, 91, 88, 88, 88, 87, 87, 86, 86, 86, 84, 83, 81, 78, 78, 77, 76, 76, 73, 73, 72, 68, 67, 67, 65, 64, 64, 63, 61, 59, 57, 55, 55, 54, 54, 54, 53, 52, 50, 49, 48, 47, 47, 45, 45, 44, 44, 43, 43, 42, 42, 42, 40, 34, 34, 32, 31, 31, 30, 28, 27, 27, 26, 25, 25, 24, 23, 23, 22, 22, 21, 21, 20, 19, 19, 18, 15, 13, 13, 12, 11, 10, 10, 9, 7, 7, 7, 6, 5, 2, 1, 0]\n\n\nAlém do método sort, tem a função nativa do Python. Função sorted():\n\n\nCódigo\n# Ordenado de forma crescente novamente\nva_modified = sorted(va_modified)\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\n\n\n3.3.7 Cópia de Listas\nCópia ou cópias de listas se torna algo de grande valor quando se quer fazer alguma manipulação, porém não se quer alterar as informações originais. Para isso, deve-se usar o método copy():\n\n\nCódigo\n# Criando listas\nl1 = [[1, 2, 3], [\"x\", \"y\", \"z\"], [True, False]]\nl2 = l1.copy() # l2 é a cópia de l1\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\n# Adicioando um elemento novo somente a l2\nl2.append([1/4, 1/2, 3/4, 1])\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\nAgora, observe o que acontece se não fizer uso do copy():\n\n\nCódigo\n# Criando listas\nl1 = [[1, 2, 3], [\"x\", \"y\", \"z\"], [True, False]]\nl2 = l1 # l2 'igual' a l1\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False]]\n\n\nCódigo\n# Adicioando um elemento novo somente a l2\nl2.append([1/4, 1/2, 3/4, 1])\n\n# Visualizando\nprint(l1)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\nCódigo\nprint(l2)\n\n\n[[1, 2, 3], ['x', 'y', 'z'], [True, False], [0.25, 0.5, 0.75, 1]]\n\n\n\n\n3.3.8 Operando Listas\nFazendo uso ao conhecimento adquirido de strings. Temos os operadores + e *, que funcionam de forma muito similar e obdecem as mesmas regras.\nO operador + concatena (semelhante ao método extend()) listas:\n\n\nCódigo\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nc\n\n\n[1, 2, 3, 4, 5, 6]\n\n\nO operador * repete a lista dado um número de vezes:\n\n\nCódigo\na * 2\n\n\n[1, 2, 3, 1, 2, 3]\n\n\n\n\nCódigo\nd = c + a + b + 2 * c\nd\n\n\n[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]\n\n\nO Python fornece várias outras operações úteis para listas, calculadas com funções do módulo básico do Python. Entretanto, tais funções só se aplicam a listas numéricas:\n\n\nCódigo\nprint(f\"Soma da lista 'd': {sum(d)}\")\n\n\nSoma da lista 'd': 84\n\n\nCódigo\nprint(f\"Maior valor da lista 'd': {max(d)}\")\n\n\nMaior valor da lista 'd': 6\n\n\nCódigo\nprint(f\"Menor valor da lista 'd': {min(d)}\")\n\n\nMenor valor da lista 'd': 1\n\n\nAgora, imagine que seja necessário saber quantas vezes um determinado elemento se repete dentro de uma lista. Tal ação pode ser feita pelo método count():\n\n\nCódigo\n# Lembra dessa lista\nprint(va_modified)\n\n\n[0, 1, 2, 5, 6, 7, 7, 7, 9, 10, 10, 11, 12, 13, 13, 15, 18, 19, 19, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 30, 31, 31, 32, 34, 34, 40, 42, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 49, 50, 52, 53, 54, 54, 54, 55, 55, 57, 59, 61, 63, 64, 64, 65, 67, 67, 68, 72, 73, 73, 76, 76, 77, 78, 78, 81, 83, 84, 86, 86, 86, 87, 87, 88, 88, 88, 91, 91, 92, 93, 94, 95, 95, 98, 100, 100]\n\n\nCódigo\n# Quanta vezes o número 100 aparece?\nprint(va_modified.count(100))\n\n\n2\n\n\n\n\n3.3.9 Uso da Função range() em Listas\nEm Python, além de funções como print(), len(), sum(), max() e min(), temos a função range(), que também faz parte do módulo básico. Essa função é extremamente útil para criar sequências numéricas, especialmente listas. Imagine que você precise criar uma lista com os números de 1 a 200. Como fazer isso de forma eficiente?\nUma abordagem seria escrever todos os números manualmente:\nlista_grande = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ..., 200]\nNo entanto, essa não é a forma mais prática. É aí que entra a função range(). Com ela, podemos gerar essa lista de forma muito mais simples:\n\n\nCódigo\nlist(range(1, 201))  # Note que o limite superior é 201\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]\n\n\nO range() também oferece flexibilidade para gerar sequências com intervalos específicos. Por exemplo, para obter os números de 0 a 29, pulando de 5 em 5:\n\n\nCódigo\nlist(range(0, 30, 5))\n\n\n[0, 5, 10, 15, 20, 25]\n\n\nAlém disso, o range() também oferece algumas coisas interessantes. Por exemplo, imprimir os números espaçados de 5 em 5, entre 0 e 30:\n\n\nCódigo\nlist(range(0, 30, 5))\n\n\n[0, 5, 10, 15, 20, 25]\n\n\nA sintaxe geral do range() é: range(start, stop, step), onde:\n\nstart: O valor inicial da sequência (inclusivo).\nstop: O valor final da sequência (exclusivo).\nstep: O intervalo entre os valores.\n\nPor que precisamos converter range() para list?\n\n\nCódigo\nprint(range(200))\n\n\nrange(0, 200)\n\n\nCódigo\nprint(type(range(200)))\n\n\n&lt;class 'range'&gt;\n\n\nIsso acontece porque range() retorna um objeto do tipo range, que representa uma sequência numérica, mas não é uma lista em si. Para visualizar os números, precisamos convertê-lo explicitamente para uma lista:\n\n\nCódigo\nrange_lista = list(range(200))\nprint(range_lista)\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "basicTWO.html#dicionários",
    "href": "basicTWO.html#dicionários",
    "title": "3  Objetos no Python",
    "section": "3.4 Dicionários",
    "text": "3.4 Dicionários\nDicionários em Python são estruturas de dados poderosas que armazenam informações no formato chave-valor. Diferentemente das listas, que são indexadas por números, os dicionários usam chaves imutáveis (strings, números, tuplas, etc.) para acessar seus valores.\nUm dicionário é uma coleção de pares chave-valor, onde cada chave é única e está associada a um valor: {chave: valor}.\n\nChaves Únicas: Uma característica fundamental dos dicionários é que cada chave deve ser única. Tentar inserir chaves duplicadas resultará na substituição do valor anterior.\n\n\n3.4.1 Declaração de Dicionários\nEm Python, dicionários podem ser criados de diversas maneiras, oferecendo flexibilidade para diferentes situações.\n\nCriação Direta com Chaves e Valores:\n\n\n\nCódigo\n# Dicionário com informações de uma receita\nreceita = {\n    \"farinha\": \"2 xícaras\",\n    \"ovos\": 3,\n    \"leite condensado\": \"1 lata\"\n}\n\n# Dicionário com números de telefone\ntelefones = {\"ana\": 123456, \"yudi\": 40028922, \"julia\": 4124492}\n\n\nNeste exemplo, \"ana\" é uma chave que está associada ao valor 123456. Cada par chave-valor é separado por vírgula.\n\n\nCódigo\nprint(receita)\n\n\n{'farinha': '2 xícaras', 'ovos': 3, 'leite condensado': '1 lata'}\n\n\nCódigo\nprint(telefones)\n\n\n{'ana': 123456, 'yudi': 40028922, 'julia': 4124492}\n\n\n\nCriação de um Dicionário Vazio:\n\nVocê pode criar um dicionário vazio usando apenas chaves {}:\n\n\nCódigo\ncontatos = {}\ncontatos\n\n\n{}\n\n\n\nCriação com a Função dict():\n\nA função dict() permite criar dicionários de forma mais explícita, especialmente quando as chaves são strings simples:\n\n\nCódigo\npessoa = dict(nome=\"Carlos\", idade=30, cidade=\"São Paulo\")\npessoa\n\n\n{'nome': 'Carlos', 'idade': 30, 'cidade': 'São Paulo'}\n\n\n\nCom uma lista de listas:\n\n\n\nCódigo\n# Definindo três listas diferentes\nl1 = [\"brigadeiro\", \"leite condesado, achocolatado\"]\nl2 = [\"omelete\", \"ovos, azeite, condimentos a gosto\"]\nl3 = [\"ovo frito\", \"ovo, óleo, condimentos a gosto\"]\n\n# Criando uma lista de listas\nlr = [l1, l2, l3]\n\n# Visualizando resultado\nlr\n\n\n[['brigadeiro', 'leite condesado, achocolatado'], ['omelete', 'ovos, azeite, condimentos a gosto'], ['ovo frito', 'ovo, óleo, condimentos a gosto']]\n\n\n\n\nCódigo\n# Transformando lista de listas em um dicionário\nreceitas = dict(lr)\n\n# Visualizando o resultado\nreceitas\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, óleo, condimentos a gosto'}\n\n\n\n\n3.4.2 Chaves\nPodemos acessar os valores de um dicionário através de suas chaves:\n\n\nCódigo\n# Definindo um dicionário para capitais de estados brasileiros\ncapitais = {\"SP\": \"São Paulo\", \"AC\": \"Rio Branco\", \"TO\": \"Palmas\",\n            \"RJ\": \"Rio de Janeiro\", \"SE\": \"Aracaju\", \"MG\": \"Belo Horizonte\"}\n\n# Acessando o valor correspondente a chave \"MG\"\ncapitais[\"MG\"]\n\n\n'Belo Horizonte'\n\n\nCaso a chave não exista, podemos evitar erros usando o método get():\n\n\nCódigo\ncapitais.get(\"PA\")\n\n\n\n\nCódigo\ncapitais.get(\"PA\", \"Não tem!\")\n\n\n'Não tem!'\n\n\nNote que o método get() funciona de forma similar ao código dicionário[chave], entretanto, caso a chave não exista garantimos que o código não gere erro diferente do que aconteceria caso fosse usado dicionário[chave].\nRepare, também, que a chave \"PA\" não foi adicionada ao dicionário.\n\n\nCódigo\ncapitais\n\n\n{'SP': 'São Paulo', 'AC': 'Rio Branco', 'TO': 'Palmas', 'RJ': 'Rio de Janeiro', 'SE': 'Aracaju', 'MG': 'Belo Horizonte'}\n\n\nAgora, se o objetivo não for saber o valor associado a determinada chave, mas sim saber se a chave existe, isso pode ser feito usando o método keys e o operador lógico in:\n\n\nCódigo\n# Chaves do Dicionário\nprint(capitais.keys())\n\n\ndict_keys(['SP', 'AC', 'TO', 'RJ', 'SE', 'MG'])\n\n\nCódigo\n# Verificando\nprint(f'A chave \"PA\" está no dicionário capitais? {\"PA\" in capitais.keys()}')\n\n\nA chave \"PA\" está no dicionário capitais? False\n\n\nNote que os valores de um dicionário pode ser qualquer tipo de objeto. No entanto, foi usado, até então, para exemplos, apenas strings. Porém, pode-se colocar todo tipo de coisa dentro dos dicionários, incluindo listas e até mesmo outros dicionários:\n\n\nCódigo\nnumeros = {\"primos\": [2, 3, 5], \"pares\": [0, 2, 4], \"ímpares\": [1, 3, 5]}\nprint(numeros)\n\n\n{'primos': [2, 3, 5], 'pares': [0, 2, 4], 'ímpares': [1, 3, 5]}\n\n\n\n\nCódigo\ndocente = {\n  \"Nome\": \"Prof Dr Vinícius Duarte Lima\", \n  \"Formação\": {\"Graduação\": \"Eng Elétrica\", \"Mestrado\": \"Eng Elétrica\", \"Doutorado\": \"Eng Elétrica\"},\n  \"Idade\": 45,\n}\n\nprint(docente)\n\n\n{'Nome': 'Prof Dr Vinícius Duarte Lima', 'Formação': {'Graduação': 'Eng Elétrica', 'Mestrado': 'Eng Elétrica', 'Doutorado': 'Eng Elétrica'}, 'Idade': 45}\n\n\nMesmo que os pares chave: valor estejam organizados na ordem que foram colocados, não podemos acessá-los por índices como faríamos em listas:\n[Input]  : numeros[2]\n[Output] : KeyError: 2\nAssim como os valores não precisam ser do tipo string, o mesmo vale para as chaves:\n\n\nCódigo\nnumeros_por_extenso = {2: \"dois\", 1: \"um\", 3: \"três\", 0: \"zero\"}\nnumeros_por_extenso[0]\n\n\n'zero'\n\n\n\n\nCódigo\nnumeros_por_extenso[2]\n\n\n'dois'\n\n\n\nNota: Listas e outros dicionários não podem ser usados como chaves por serem de tipos mutáveis.\n\n\n\n3.4.3 Adicionando, Alterando e Removendo Elementos\nPara exemplificar os comandos desta seção, considere o dicionário abaixo.\n\n\nCódigo\n# Informações de Cleiton\npessoa = {\"nome\": \"Cleiton\", \"idade\": 34, \"família\": {\"mãe\": \"Maria\", \"pai\": \"Enzo\"}}\n\n# Visualizando\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'família': {'mãe': 'Maria', 'pai': 'Enzo'}}\n\n\nPara adicionar o item \"masculino\" a chave \"genêro\" podemos usar os seguintes comandos:\n\n\nCódigo\n# Adicionando elemento\npessoa[\"genêro\"] = \"romântico\"\n\n# Visualizando\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'família': {'mãe': 'Maria', 'pai': 'Enzo'}, 'genêro': 'romântico'}\n\n\nDe forma equivalente, temos:\n\n\nCódigo\n# Dicionário de meses do ano\nmeses = {1: \"Janeiro\", 2: \"Fevereiro\", 3: \"Março\"}\n\n# Adicionando o mês de \"Abril\" na chave 4\nmeses[4] = \"Setembro\"\n\n# Visualizando\nmeses\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Março', 4: 'Setembro'}\n\n\nAs vezes, podem haver inconsistências nos dados, logo, se torna necessário corrigir tais inconsistências. Isso pode ser feito de forma muito simples, veja:\n\n\nCódigo\n# Executando alterações\npessoa[\"genêro\"] = \"masculino\"\nmeses[4] = \"Abril\"\n\n# Visualizando\nprint(pessoa)\n\n\n{'nome': 'Cleiton', 'idade': 34, 'família': {'mãe': 'Maria', 'pai': 'Enzo'}, 'genêro': 'masculino'}\n\n\nCódigo\nprint(meses)\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Março', 4: 'Abril'}\n\n\nUm dúvida que talvez possa surgir é como fazer alteração em listas que estão contidas em dicionários. Na verdade, isso é feito de forma bastante objetiva, veja:\n\n\nCódigo\n# Novo dicionário\nlixo = {\"plástico\": [\"garrafa\", \"copinho\", \"canudo\"], \n        \"papel\": [\"folha amassada\", \"guardanapo\"], \n        \"orgânico\": [\"batata\", \"resto do bandeco\", \"casca de banana\"]}\n\n# Visualizando\nprint(lixo)\n\n\n{'plástico': ['garrafa', 'copinho', 'canudo'], 'papel': ['folha amassada', 'guardanapo'], 'orgânico': ['batata', 'resto do bandeco', 'casca de banana']}\n\n\nCódigo\n# Obtendo lista de interesse para alteração\nlista_de_interesse = lixo[\"plástico\"]\n\n# Verificando em qual posição está o elemneto que deve ser alterado\nid = lista_de_interesse.index(\"garrafa\")\n\n# Fazendo a alteração diretamente no dicionário\nlixo['plástico'][id] = \"sacola\"\n\n# Visualizando dicionário alterado\nlixo\n\n\n{'plástico': ['sacola', 'copinho', 'canudo'], 'papel': ['folha amassada', 'guardanapo'], 'orgânico': ['batata', 'resto do bandeco', 'casca de banana']}\n\n\nNote que poderiamos ser mais direto, pois as listas em questão têm comprimentos pequenos. Porém, tal código já pode ser implementado para listas de grande comprimento.\nPorém, ao lidarmos com dicionários, talvez precisemos excluir algum elemento. Serão apresentadas duas formas de fazer isso.\n\nUsando o método pop():\n\n\n\nCódigo\npessoa.pop(\"família\")\n\n\n{'mãe': 'Maria', 'pai': 'Enzo'}\n\n\nRepare que dicionário.pop(chave) excluí o elemento e retorna os itens da chave excluída. Para visualizarmos o resultado basta chamar o dicionário.\n\n\nCódigo\npessoa\n\n\n{'nome': 'Cleiton', 'idade': 34, 'genêro': 'masculino'}\n\n\n\nUsando o comando del do Python Básico:\n\n\n\nCódigo\ndel meses[4]\n\n\nDiferente do método pop(), o comando del não retorna nada. Porém, para visualizar o resultado, precisamos chamar o objeto.\n\n\nCódigo\nmeses\n\n\n{1: 'Janeiro', 2: 'Fevereiro', 3: 'Março'}\n\n\nPara excluir todos os elementos de um dicionário, temos o método clear():\n\n\nCódigo\n# Apagando todos os elementos do dicionário\nlixo.clear()\n\n# Visualizando\nlixo\n\n\n{}\n\n\n\n\n3.4.4 Função list() e Função len() para Dicionários\nA função list() converte um dicionário em uma lista contendo apenas suas chaves:\n\n\nCódigo\ninstitutos_uspsc = {\n    \"IFSC\": \"Instituto de Física de São Carlos\",\n    \"ICMC\": \"Instituto de Ciências Matemáticas e de Computação\",\n    \"EESC\": \"Escola de Engenharia de São Carlos\",\n    \"IAU\": \"Instituto de Arquitetura e Urbanismo\",\n    \"IQSC\": \"Instituto de Química de São Carlos\"\n}\n\n# Convertendo dicionário em lista de chaves\nlista_chaves = list(institutos_uspsc)\nprint(lista_chaves)\n\n\n['IFSC', 'ICMC', 'EESC', 'IAU', 'IQSC']\n\n\nA função len() retorna o número de itens em um objeto. Para dicionários, ela conta o número de pares chave-valor:\n\n\nCódigo\n# Contando itens no dicionário\nquantidade_institutos = len(institutos_uspsc)\nprint(quantidade_institutos)\n\n\n5\n\n\nCódigo\n# Equivalente a contar as chaves convertidas em lista\nprint(len(list(institutos_uspsc)))\n\n\n5\n\n\n\n\n3.4.5 Outros comandos para dicionários\nVejamos agora os métodos items() e values(). Considere o seguinte dicionário:\n\n\nCódigo\npessoa = {\"nome\": \"Enzo\", \"RA\": 242334, \"curso\": \"fiscomp\"}\n\n\n\nitems() - Retorna uma visão dos pares chave-valor:\n\n\n\nCódigo\npares = pessoa.items()\nprint(list(pares))\n\n\n[('nome', 'Enzo'), ('RA', 242334), ('curso', 'fiscomp')]\n\n\n\nvalues() - Retorna uma visão dos valores armazenados:\n\n\n\nCódigo\nvalores = list(pessoa.values())\nprint(valores)\n\n\n['Enzo', 242334, 'fiscomp']\n\n\nObservação importante: A função list() aplicada diretamente a um dicionário (list(pessoa)) retorna apenas as chaves, equivalente a list(pessoa.keys()).\nDicionários em Python (versões 3.7+) mantêm a ordem de inserção, mas a igualdade entre dicionários considera apenas os pares chave-valor, não a ordem:\n\n\nCódigo\nnumerinhos = {\"um\": 1, \"dois\": 2, \"três\": 3}\nnumeritos = {\"três\": 3, \"dois\": 2, \"um\": 1}\n\nprint(numerinhos == numeritos)\n\n\nTrue\n\n\nCódigo\nprint(numerinhos)  # Mostra na ordem de inserção\n\n\n{'um': 1, 'dois': 2, 'três': 3}\n\n\nCódigo\nprint(numeritos)   # Mostra na ordem de inserção diferente\n\n\n{'três': 3, 'dois': 2, 'um': 1}\n\n\nOutro comando que pode ser usado para adicionar elementos em um dicionário pode ser o método update().\n\n\nCódigo\n# Lembra do dicionários receitas?\nprint(receitas)\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, óleo, condimentos a gosto'}\n\n\nCódigo\n# Nova receita\noutros_elementos = {\"mingau\": \"massa, leite, açúcar\"}\n\n# Adicionando a nova receita\nreceitas.update(outros_elementos)\n\n# Visualizando\nprint(receitas)\n\n\n{'brigadeiro': 'leite condesado, achocolatado', 'omelete': 'ovos, azeite, condimentos a gosto', 'ovo frito': 'ovo, óleo, condimentos a gosto', 'mingau': 'massa, leite, açúcar'}\n\n\n\nResumão:\n\n\nOs métodos items() e values() (e keys()) retornam objetos de visualização que refletem automaticamente as alterações no dicionário original;\nA partir do Python 3.7, a ordem de inserção é preservada como característica da implementação, tornando-se parte da especificação na versão 3.8;\nUso do método update para integralização de dicionários.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos no Python</span>"
    ]
  },
  {
    "objectID": "basicTHREE.html",
    "href": "basicTHREE.html",
    "title": "4  Controle de Fluxo",
    "section": "",
    "text": "4.1 Introdução\nEm programação, o controle de fluxo determina a ordem em que as instruções são executadas em um programa. Em Python, isso permite criar programas que tomam decisões e repetem ações com base em condições específicas, tornando seu código mais dinâmico e adaptável.\nNeste capítulo, exploraremos as principais estruturas de controle de fluxo:\nPor que o controle de fluxo é importante?\nImagine um programa que:\nSem controle de fluxo, nossos programas seriam lineares e limitados. Com ele, ganhamos flexibilidade e poder para resolver problemas complexos.\nDominar o controle de fluxo é essencial para qualquer pessoa que esteja aprendendo programação, pois ele está presente em praticamente todo código real. Vamos começar a explorar cada conceito com exemplos práticos e exercícios!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo</span>"
    ]
  },
  {
    "objectID": "basicTHREE.html#introdução",
    "href": "basicTHREE.html#introdução",
    "title": "4  Controle de Fluxo",
    "section": "",
    "text": "Condicionais (if, elif, else): Permitem executar blocos de código diferentes dependendo se uma condição é verdadeira ou falsa.\nLaços (for, while): Permitem repetir um bloco de código várias vezes, seja por um número específico de vezes ou enquanto uma condição for verdadeira.\nTratamento de exceções (try, except, finally): Permitem lidar com erros e situações inesperadas sem interromper o programa.\nPalavras-chave (break, continue, pass): Permitem controlar o fluxo de execução dentro de laços.\n\n\n\n\nDecide se um usuário tem acesso a um sistema (if).\nRepete uma ação até que um download seja concluído (while).\nPercorre uma lista de produtos para calcular descontos (for).\nPrevine erros se um arquivo não for encontrado (try/except).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo</span>"
    ]
  },
  {
    "objectID": "basicTHREE.html#estruturas-de-decisão",
    "href": "basicTHREE.html#estruturas-de-decisão",
    "title": "4  Controle de Fluxo",
    "section": "4.2 Estruturas de Decisão",
    "text": "4.2 Estruturas de Decisão\nAs estruturas de decisão em Python são usadas para controlar o fluxo do programa, ou seja, para decidir qual bloco de código será executado dependendo de uma ou mais condições. Pense como um semáforo: dependendo da cor, uma ação diferente deve ser tomada — o mesmo acontece em um programa.\n\nExemplo do mundo real:\n\nSe estiver nublado:\n    Levarei guarda-chuva\nSenão:\n    Não levarei\n\nNota: Em Python, a indentação (recuo de quatro espaços ou um tab) é obrigatória para definir os blocos de código. Isso significa que o que estiver indentado será considerado parte da condição.\n\n\n4.2.1 Estrutura if e else\nVamos começar com o básico: if (se) e else (senão).\n\n\nCódigo\na = 7\n\nif a &gt; 3:\n    print(\"A variável 'a' é maior que 3\")\nelse:\n    print(\"A variável 'a' é menor ou igual a 3\")\n\n\nA variável 'a' é maior que 3\n\n\n\n\n4.2.2 Estrutura if, elif e else\nSe quisermos testar mais de uma condição, usamos o elif (abreviação de else if). Assim, podemos checar várias possibilidades antes de cair no else.\n\n\nCódigo\nvalor = 3\n\nif valor == 1:\n    print(\"Valor é 1\")\nelif valor == 2:\n    print(\"Valor é 2\")\nelif valor == 3:\n    print(\"Valor é 3\")\nelse:\n    print(\"Valor não corresponde a nenhuma das opções anteriores\")\n\n\nValor é 3\n\n\n\nO Python executa apenas o primeiro bloco de código cuja condição for verdadeira. Os demais são ignorados.\n\n\n\n4.2.3 Comparando if + elif vs vários if isolados\nÉ importante entender a diferença entre usar elif e vários if consecutivos.\n\n\nCódigo\na = 1\n\nif a == 1:\n    print(\"Caiu no 1º if\")\nelif a &gt;= 1:\n    print(\"Caiu no elif\")\nelse:\n    print(\"Caiu no else\")\n\n\nCaiu no 1º if\n\n\nNesse exemplo, apenas o primeiro bloco (if a == 1) será executado.\nAgora, veja o que acontece se usamos dois if separados:\n\n\nCódigo\na = 1\n\nif a == 1:\n    print(\"Caiu no 1º if\")\n\n\nCaiu no 1º if\n\n\nCódigo\nif a &gt;= 1:\n    print(\"Caiu no 2º if\")\nelse:\n    print(\"Caiu no else\")\n\n\nCaiu no 2º if\n\n\nAqui, ambos os blocos if serão avaliados independentemente. Isso pode ser útil em algumas situações, mas exige atenção!\nLembre das Tabela 2.1 (operadores lógicos) e Tabela 2.2 (conectores lógicos).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo</span>"
    ]
  },
  {
    "objectID": "basicTHREE.html#estruturas-de-repetição",
    "href": "basicTHREE.html#estruturas-de-repetição",
    "title": "4  Controle de Fluxo",
    "section": "4.3 Estruturas de Repetição",
    "text": "4.3 Estruturas de Repetição",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Controle de Fluxo</span>"
    ]
  },
  {
    "objectID": "Modules.html",
    "href": "Modules.html",
    "title": "5  Módulos",
    "section": "",
    "text": "5.1 Numpy\nCódigo\nimport numpy as np",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "Modules.html#scipy",
    "href": "Modules.html#scipy",
    "title": "5  Módulos",
    "section": "5.2 Scipy",
    "text": "5.2 Scipy\n\n\nCódigo\nfrom scipy import stats",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "Modules.html#pandas",
    "href": "Modules.html#pandas",
    "title": "5  Módulos",
    "section": "5.3 Pandas",
    "text": "5.3 Pandas\n\n\nCódigo\nimport pandas as pd",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "Modules.html#matplotlib",
    "href": "Modules.html#matplotlib",
    "title": "5  Módulos",
    "section": "5.4 Matplotlib",
    "text": "5.4 Matplotlib\n\n\nCódigo\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "Modules.html#seaborn",
    "href": "Modules.html#seaborn",
    "title": "5  Módulos",
    "section": "5.5 Seaborn",
    "text": "5.5 Seaborn\n\n\nCódigo\nimport seaborn as sns",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Módulos</span>"
    ]
  }
]