```{r include=FALSE, echo=FALSE}
library(reticulate)
use_python("C:/Users/user/anaconda3/python.exe", required = TRUE)
```

```{=html}
<style>
  body{text-align: justify}
</style>
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::

# Objetos no Python

## Introdu√ß√£o

Ao longo do curso, j√° mencionamos alguns tipos de objetos enquanto explor√°vamos conceitos b√°sicos de Python. Voc√™ provavelmente j√° viu vari√°veis sendo criadas e usadas, e at√© notou que diferentes valores podem ter diferentes tipos. Agora, chegou o momento de entender melhor os objetos b√°sicos do Python e como eles funcionam.

Neste cap√≠tulo, vamos explorar os principais tipos de objetos que o Python nos oferece, como n√∫meros, strings, listas e dicion√°rios. Al√©m disso, veremos como identificar o tipo de um objeto, buscar ajuda sobre fun√ß√µes e entender melhor as vari√°veis dispon√≠veis no c√≥digo.

Com essa nova organiza√ß√£o do curso, o conte√∫do foi dividido em cap√≠tulos menores para facilitar o aprendizado. Isso evita que tudo seja ensinado de uma vez, tornando a experi√™ncia mais din√¢mica e leve. Ent√£o, vamos come√ßar nossa jornada pelos objetos do Python! üöÄ

## Strings

Tamb√©m chamada de sequ√™ncia de caracteres, textos ou dados alfanum√©ricos, uma *string* √© um tipo de dado que armazena uma *sequ√™ncia de caracteres*. Em Python, pode ser definida com aspas simples (`'`), duplas (`"`) ou triplas (`'''` ou `"""`).

```{python}
"Texto com acentos e cedilhas: hoje √© dia de ca√ßa!"
```

```{python}
# As strings aceitam aspas simples tamb√©m
nome = 'Silvio Santos'
nome
```

### Opera√ß√µes com Strings

Podemos realizar diversas opera√ß√µes matem√°ticas e manipula√ß√µes em strings.

```{python}
# Multiplica√ß√£o repete a string
nome * 3
```
```
[Input]:  nome * 3.14
[Output]: TypeError: can't multiply sequence by non-int of type 'float'
```
```{python}
# Concatena√ß√£o de strings
canto1 = 'vem a√≠, '
canto2 = 'l√° '
nome + ' ' + canto1 + canto2 * 6 + '!!'
```

### Strings Multilinhas

Para definir strings que ocupam m√∫ltiplas linhas, utilize tr√™s aspas (`'''` ou `"""`):

```{python}
str_grande = '''Aqui consigo inserir um text√£o com v√°rias linhas.
Posso iniciar em uma...
... continuar em outra...
... e seguir quantas precisar.'''

str_grande
```

```{python}
print(str_grande)
```

Caso seja necess√°rio incluir aspas dentro da string, podemos alternar entre aspas simples e duplas:

```{python}
agua = "Me d√° um copo d'√°gua"
agua
```

Tamb√©m podemos usar todas as aspas ao mesmo tempo:

```{python}
todas_as_aspas = """Essa √© uma string que tem:
- aspas 'simples'
- aspas "duplas"
- aspas '''triplas'''
Legal, n√©?"""
                    
print(todas_as_aspas)
```

### Tamanho de uma String

A fun√ß√£o embutida `len()` nos permite obter o n√∫mero de caracteres de uma string, incluindo espa√ßos e pontua√ß√£o:

```{python}
len('Abracadabra')
```

```{python}
frase = 'Faz um pull request l√°'
len(frase)
```

```{python}
palavra = "Python"
len(palavra)
```


### Manipula√ß√£o de Strings

#### Indexa√ß√£o

Cada caractere em uma string possui um √≠ndice, come√ßando em `0` para o primeiro elemento e indo at√© `len(string) - 1` para o √∫ltimo elemento ou `-1`.

> *√çndices negativos percorrem de tr√°s para frente*

Para um melhor entendimento inicial, considere a vari√°vel criada na subse√ß√£o anterir:`palavra`. Partindo da defini√ß√£o acima, podemos afirmar que os √≠ndices da vari√°vel `palavra` segue o formato:

| P   | y   | t   | h   | o   | n   |
|-----|-----|-----|-----|-----|-----|
| 0   | 1   | 2   | 3   | 4   | 5   |
| -6  | -5  | -4  | -3  | -2  | -1  |

Vejamos alguns exemplos:

```{python}
# Primeiro caractere
print(palavra[0])
print(palavra[-6])
```
```{python}
# Primeiro caractere
print(palavra[5])
print(palavra[-1])
```

#### Fatiamento

Fatiamento (*slincing*) √© a capacidade de extrair partes de uma string utilizando `inicio:fim - 1:passo`.

```{python}
# Guardando um objeto do tipo str na vari√°vel frase
frase = "A programa√ß√£o em " + palavra + " √© diferenciada!"
frase
```

```{python}
# Comprimento da vari√°vel frase
nStr = len(frase)
nStr
```
```{python}
# Obtendo a frase completa usando fatiamento
print(frase[:nStr - 1])
print(frase[-nStr:])
```
```{python}
# Obtendo a frase de dois em dois caractere
print(frase[:nStr - 1:2])
print(frase[-nStr::2])
```
```{python}
# Obtendo apenas 'A programa√ß√£o'
print(frase[:14])
print(frase[:-25])
```

```{python}
# Obtendo o que h√° depois de 'A programa√ß√£o'
print(frase[14:])
print(frase[-25:])
```

```{python}
# Obtendo toda a frase de tr√°s para frente
print(frase[::-1])
```
> **Nota:** Omitir o primeiro √≠ndice (`start`) ou o segundo √≠ndice (`stop`) significa, respectivamente, come√ßar desde o come√ßo ou terminar no fim.

Resumindo: para fazer uma fatia de nossa string, precisamos saber de onde come√ßa, at√© onde vai e o tamanho do passo.

```         
fati√°vel[come√ßo : fim : passo]
```

##### Aten√ß√£o para o uso de indexa√ß√£o e fatiamento

As fatias incluem o √≠ndice do primeiro elemento e n√£o incluem o elemento do √≠ndice final. Por isso que `frase[0:-1]` perde o √∫ltimo elemento.

Caso o **fim** da fatia seja antes do come√ßo, obtemos um resultado vazio:

```{python}
frase[59:105]
```

O que acontece com uma fatia que est√° fora da string?

```{python}
frase[123:345]
```

E se o **fim** da fatia for superior ao comprimento da string? Sem problemas, o Python pecorrer a string at√© o onde der:

```{python}
frase[8:123456789]
```

Mas um √≠ndice fora do intervalo em acesso direto gera erro:

```         
[Input]  : frase[123456789]
[Output] : IndexError: string index out of range
```

Quando usamos passos negativos, a fatia come√ßa no **fim** e termina no **come√ßo** e √© percorrida ao contr√°rio. Ou seja, invertemos a ordem. Mas tome cuidado:

```{python}
"Python"[2:6]
```

```{python}
"Python"[2:6:-1]
```

```{python}
"Python"[6:2]
```

```{python}
"Python"[6:2:-1]
```

- `"Python"[6:2]`: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© positivo (default). Nesse caso, o resultado √© uma string vazia, pois o slicing avan√ßa para a direita, mas o fim est√° √† esquerda.
- `"Python"[2:6:-1]`: O √≠ndice de in√≠cio (2) √© menor que o √≠ndice de fim (6), mas o passo √© negativo (-1). O slicing tenta avan√ßar para a esquerda, mas o fim est√° √† direita. Novamente, o resultado √© uma string vazia.
- `"Python"[6:2:-1]`: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© negativo (-1). O slicing avan√ßa para a esquerda, come√ßando do √≠ndice 6 ('n') at√© o √≠ndice 2 ('t'), excluindo-o. Isso resulta na string "noh".

### Formata√ß√£o de Strings

Podemos formatar strings utilizando `f-strings`, `.format()` ou `%`:

```{python}
nome = "Breno"
idade = 21

print(f"Ol√°, meu nome √© {nome} e tenho {idade} anos.")           # f-strings
print("Ol√°, meu nome √© {} e tenho {} anos.".format(nome, idade)) # format()
print("Ol√°, meu nome √© %s e tenho %d anos." % (nome, idade))     # Estilo antigo
```
O autor recomenda usar a primeira op√ß√£o.

### M√©todos √öteis para Strings

Ao definirmos o objeto `string` em Python, s√£o definidas tamb√©m algumas a√ß√µes que este objeto pode executar.

```{python}
# Defini-se um string qualquer
frase = " Python √© legal! "

# Visualizar vari√°vel
frase
```

1. M√©todo `str.lower()`: Deixa qualquer caractere em min√∫sculo.

```{python}
frase.lower()
```

2. M√©todo `str.upper()`: Deixa qualquer caractere em mai√∫sculo.

```{python}
frase.upper()
```
    
3. M√©todo `str.strip()`: Remove os espa√ßos extras.

```{python}
frase.strip()
```
    
4. M√©todo `str.title()`: Primeiro caractere de cada palavra em letra mai√∫scula.

```{python}
frase.strip().title()
```
    
5. M√©todo `str.replace()`: Troca um determinado caractere (1¬∫ argumento) por um outro determinado caractere (2¬∫ argumento).

```{python}
frase.replace("Python", "Programar")
```

6. M√©todo `str.index()`: Retorna o √≠ndice de determinado caractere contido na string.

```{python}
frase.index("√©")
```
    
7. M√©todo `str.count()`: Quantifica o n√∫mero de apari√ß√µes de determinado caractere na string.

```{python}
frase.count("a")
```
    
8. M√©todo `str.split()`: Cria uma lista a partir de fatias da string com base em um caractere.

```{python}
# M√©todo split sem argumento (default)
print(frase.split())

# M√©todo split com argumento
print(frase.split("√©"))
```

## Listas

Listas s√£o uma das estruturas de dados mais usadas em Python. Elas permitem armazenar m√∫ltiplos valores em uma √∫nica vari√°vel e suportam diversos tipos de opera√ß√µes.

### Declara√ß√£o de Listas

Uma lista em Python √© definida utilizando colchetes `[]`, e seus elementos s√£o separados por v√≠rgulas:

```{python}
# Lista de n√∫meros
numeros = [1, 2, 3, 4, 5]

# Lista de strings
frutas = ["ma√ßa", "banana", "abacaxi"]

# Lista mista
dados = [25, "Jo√£o", True, 3.14]
```

Uma lista tamb√©m pode ser vazia, algo que futaremente veremos que pode ser muito √∫til, por exemplo:

```{python}
vazia = []
vazia
```

### Indexa√ß√£o e Fatiamento

A ideia de √≠ndices e fatias de listas funciona de forma muito parecida com a que foi vista em strings.

```{python}
numeros[0] # Primeiro elemento
```

```{python}
numeros[-1] # √öltimo elemento
```

Assim como na indexa√ß√£o de strings, ao tentar acessar um √≠ndice inv√°lido de uma lista √© retornado um erro.

Ao √≠nves de simplesmente acessar um elemneto atrav√©s de seu √≠ndice, podemos obter uma fatia, que pode ser muito mais interessante.

```{python}
numeros[::2] # Do come√ßo ao fim, de 2 em 2 elementos
```

```{python}
numeros[::-2] # Do fim ao come√ßo, de 2 em 2 elementos
```

```{python}
numeros[:3]   # Tr√™s primeiros elementos
```

```{python}
numeros[3:]   # Elementos a partir do √≠ndice 3
```

```{python}
numeros[::-1] # Lista invertida
```

### Trabalhando com Listas

Imagine que se queira saber se um determinado elemento (objeto) est√° contido em determinada lista. Poderiamos ficar procurando elemento a elemento, vamos tentar essa abordagem. Verifique se o elemento `0.3146778807984779` est√° contido na lista abaixo:

```{python}
import random as rd

rd.seed(42)

va = [rd.random() for _ in range(100)]
va
```
Note que n√£o √© vi√°vel essa abordagem. Para est√° finalidade devemos usar o operador l√≥gico `in`. Veja o exemplo:

```{python}
0.3146778807984779 in va # 'elemento' est√° contido em 'lista'
```

Lembra do operador `not`? Podemos combin√°-lo com o `in` para verificar se um elemento 'n√£o est√°' contido em uma determina lista. Sendo o contr√°rio (nega√ß√£o) da afirma√ß√£o acima.

```{python}
0.3146778807984779 not in va # 'elemento' n√£o est√° contido em 'lista'
```

Veja um exemplo de como o `in` funciona em uma outra situa√ß√£o.

```{python}
lista_mista = ['duas palavras', 42, True, ['batman', 'robin'], -0.84, 'hip√≥fise']
42 in lista_mista
```

```{python}
'batman' in lista_mista
```

```{python}
'batman' in lista_mista[3] # Note que o elemento com √≠ndice 3 tamb√©m √© uma lista
```

Consegue me dizer quantos elementos t√™m na lista `va`? Fique tranquilo! N√£o precisa contar, pode ser usado a fun√ß√£o `len` do Python para responder essa pergunta.

```{python}
len(va)
```

```{python}
len(lista_mista[3])
```

### Adicionar e Remover elementos de uma Lista

Podemos adicionar elementos de diversas formas:

```{python}
# Adiciona um √∫nico elemento ao final da lista
numeros.append(6)
numeros
```

```{python}
# Adiciona v√°rios elementos ao final da lista
numeros.extend([7, 8, 9])
numeros
```

```{python}
# Adiciona um elemento em uma posi√ß√£o espec√≠fica
numeros.insert(2, 15)  # Insere o n√∫mero 15 na posi√ß√£o 2 (3¬∫ elemento)
numeros
```

Podemos remover/excluir elementos de uma lista das seguintes formas:

```{python}
# Remove a primeira ocorr√™ncia de um valor espec√≠fico
numeros.remove(15)  # Remove o n√∫mero 15
numeros
```

```{python}
# Exclui o √∫ltimo elemento da lista
del numeros[-1]
numeros
```
E se, por exemplo, eu precisar come√ßar a lista do zero? Pode-se remover todos os elementos de uma lista, usando o m√©todo `clear()`:

```{python}
va.clear()
print("Lista de n√∫meros aleat√≥rios:")
print(va)

va = [rd.random() for _ in range(100)]
print("Lista de n√∫meros aleat√≥rios:")
print(va)
```

### Modificando elementos

Como as listas s√£o mut√°veis, podemos alterar seus valores diretamente:

```{python}
print(f"Antes da modifica√ß√£o: \n {frutas}")

# Alterando 'banana' por 'melancia'
frutas[1] = "melancia"

# Visualizando
print(f"Depois da modifica√ß√£o: \n {frutas}")
```

Outra forma de se fazer a modifica√ß√£o √©:

```{python}
# Obtendo a posi√ß√£o (√≠ndice) da fruta (string) 'melancia'
id = frutas.index("melancia")

# Alterando 'melancia' por 'banana'
frutas[id] = "banana"

# Visualizando
print(frutas)
```

### Ordena√ß√£o de Listas

Por v√°rios motivos, pode ser √∫til ter em m√£os uma lista ordenada. Como fazer isso? Veja os exemplos:

```{python}
desordenada = ['b', 'z', 'k', 'a', 'h']
print(f"Lista desordenada: \n {desordenada}")

# Ordenando
desordenada.sort()
print(f"Lista ordenada: \n {desordenada}")
```
Voltemos a lista `va`:

```{python}
# Modificando va um pouco
va_modified = [round(va[i] * 100) for i in range(len(va))]
print(va_modified)

# Ordenado de forma crescente
va_modified.sort()
print(va_modified)

# Ordenado de forma decrescente
va_modified.sort(reverse=True)
print(va_modified)
```

Al√©m do m√©todo `sort`, tem a fun√ß√£o nativa do Python. Fun√ß√£o `sorted()`: 

```{python}
# Ordenado de forma crescente novamente
va_modified = sorted(va_modified)
print(va_modified)
```

### C√≥pia de Listas

C√≥pia ou c√≥pias de listas se torna algo de grande valor quando se quer fazer alguma manipula√ß√£o, por√©m n√£o se quer alterar as informa√ß√µes originais. Para isso, deve-se usar o m√©todo `copy()`:

```{python}
# Criando listas
l1 = [[1, 2, 3], ["x", "y", "z"], [True, False]]
l2 = l1.copy() # l2 √© a c√≥pia de l1

# Visualizando
print(l1)
print(l2)

# Adicioando um elemento novo somente a l2
l2.append([1/4, 1/2, 3/4, 1])

# Visualizando
print(l1)
print(l2)
```

Agora, observe o que acontece se n√£o fizer uso do `copy()`:

```{python}
# Criando listas
l1 = [[1, 2, 3], ["x", "y", "z"], [True, False]]
l2 = l1 # l2 'igual' a l1

# Visualizando
print(l1)
print(l2)

# Adicioando um elemento novo somente a l2
l2.append([1/4, 1/2, 3/4, 1])

# Visualizando
print(l1)
print(l2)
```

### Operando Listas

Fazendo uso ao conhecimento adquirido de strings. Temos os operadores `+` e `*`, que funcionam de forma muito similar e obdecem as mesmas regras.

O operador `+` concatena (semelhante ao m√©todo `extend()`) listas:

```{python}
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
c
```

O operador `*` repete a lista dado um n√∫mero de vezes:

```{python}
a * 2
```

```{python}
d = c + a + b + 2 * c
d
```

O Python fornece v√°rias outras opera√ß√µes √∫teis para listas, calculadas com fun√ß√µes do m√≥dulo b√°sico do Python. Entretanto, tais fun√ß√µes s√≥ se aplicam a listas num√©ricas:

```{python}
print(f"Soma da lista 'd': {sum(d)}")
print(f"Maior valor da lista 'd': {max(d)}")
print(f"Menor valor da lista 'd': {min(d)}")
```
Agora, imagine que seja necess√°rio saber quantas vezes um determinado elemento se repete dentro de uma lista. Tal a√ß√£o pode ser feita pelo m√©todo `count()`:

```{python}
# Lembra dessa lista
print(va_modified)

# Quanta vezes o n√∫mero 100 aparece?
print(va_modified.count(100))
```

### Uso da Fun√ß√£o `range()` em Listas

Em Python, al√©m de fun√ß√µes como print(), len(), sum(), max() e min(), temos a fun√ß√£o range(), que tamb√©m faz parte do m√≥dulo b√°sico. Essa fun√ß√£o √© extremamente √∫til para criar sequ√™ncias num√©ricas, especialmente listas. Imagine que voc√™ precise criar uma lista com os n√∫meros de 1 a 200. Como fazer isso de forma eficiente?

Uma abordagem seria escrever todos os n√∫meros manualmente:

```         
lista_grande = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ..., 200]
```

No entanto, essa n√£o √© a forma mais pr√°tica. √â a√≠ que entra a fun√ß√£o `range()`. Com ela, podemos gerar essa lista de forma muito mais simples:

```{python}
list(range(1, 201))  # Note que o limite superior √© 201
```

O `range()` tamb√©m oferece flexibilidade para gerar sequ√™ncias com intervalos espec√≠ficos. Por exemplo, para obter os n√∫meros de 0 a 29, pulando de 5 em 5:

```{python}
list(range(0, 30, 5))
```

Al√©m disso, o `range()` tamb√©m oferece algumas coisas interessantes. Por exemplo, imprimir os n√∫meros espa√ßados de 5 em 5, entre 0 e 30:

```{python}
list(range(0, 30, 5))
```

A sintaxe geral do `range()` √©: `range(start, stop, step)`, onde:

- `start`: O valor inicial da sequ√™ncia (inclusivo).
- `stop`: O valor final da sequ√™ncia (exclusivo).
- `step`: O intervalo entre os valores.

Por que precisamos converter `range()` para `list`?

```{python}
print(range(200))
print(type(range(200)))
```

Isso acontece porque `range(`) retorna um objeto do tipo `range`, que representa uma sequ√™ncia num√©rica, mas n√£o √© uma lista em si. Para visualizar os n√∫meros, precisamos convert√™-lo explicitamente para uma lista:

```{python}
range_lista = list(range(200))
print(range_lista)
```

## Dicion√°rios

Dicion√°rios em Python s√£o estruturas de dados poderosas que armazenam informa√ß√µes no formato chave-valor. Diferentemente das listas, que s√£o indexadas por n√∫meros, os dicion√°rios usam chaves imut√°veis (strings, n√∫meros, tuplas, etc.) para acessar seus valores.

Um dicion√°rio √© uma cole√ß√£o de pares chave-valor, onde cada chave √© √∫nica e est√° associada a um valor: `{chave: valor}`.

- **Chaves √önicas:** Uma caracter√≠stica fundamental dos dicion√°rios √© que cada chave deve ser √∫nica. Tentar inserir chaves duplicadas resultar√° na substitui√ß√£o do valor anterior.

### Declara√ß√£o de Dicion√°rios

Em Python, dicion√°rios podem ser criados de diversas maneiras, oferecendo flexibilidade para diferentes situa√ß√µes.

1. **Cria√ß√£o Direta com Chaves e Valores:**

```{python}
# Dicion√°rio com informa√ß√µes de uma receita
receita = {
    "farinha": "2 x√≠caras",
    "ovos": 3,
    "leite condensado": "1 lata"
}

# Dicion√°rio com n√∫meros de telefone
telefones = {"ana": 123456, "yudi": 40028922, "julia": 4124492}
```

Neste exemplo, `"ana"` √© uma chave que est√° associada ao valor `123456`. Cada par chave-valor √© separado por v√≠rgula.

```{python}
print(receita)
print(telefones)
```

2. **Cria√ß√£o de um Dicion√°rio Vazio:**

Voc√™ pode criar um dicion√°rio vazio usando apenas chaves {}:

```{python}
contatos = {}
contatos
```

3. **Cria√ß√£o com a Fun√ß√£o dict():**

A fun√ß√£o `dict()` permite criar dicion√°rios de forma mais expl√≠cita, especialmente quando as chaves s√£o strings simples:

```{python}
pessoa = dict(nome="Carlos", idade=30, cidade="S√£o Paulo")
pessoa
```

4. **Com uma lista de listas:**

```{python}
# Definindo tr√™s listas diferentes
l1 = ["brigadeiro", "leite condesado, achocolatado"]
l2 = ["omelete", "ovos, azeite, condimentos a gosto"]
l3 = ["ovo frito", "ovo, √≥leo, condimentos a gosto"]

# Criando uma lista de listas
lr = [l1, l2, l3]

# Visualizando resultado
lr
```

```{python}
# Transformando lista de listas em um dicion√°rio
receitas = dict(lr)

# Visualizando o resultado
receitas
```

### Chaves

Podemos acessar os valores de um dicion√°rio atrav√©s de suas chaves:

```{python}
# Definindo um dicion√°rio para capitais de estados brasileiros
capitais = {"SP": "S√£o Paulo", "AC": "Rio Branco", "TO": "Palmas",
            "RJ": "Rio de Janeiro", "SE": "Aracaju", "MG": "Belo Horizonte"}

# Acessando o valor correspondente a chave "MG"
capitais["MG"]
```

Caso a chave n√£o exista, podemos evitar erros usando o m√©todo `get()`:

```{python}
capitais.get("PA")
```

```{python}
capitais.get("PA", "N√£o tem!")
```

Note que o m√©todo `get()` funciona de forma similar ao c√≥digo `dicion√°rio[chave]`, entretanto, caso a chave n√£o exista garantimos que o c√≥digo n√£o gere erro diferente do que aconteceria caso fosse usado `dicion√°rio[chave]`.

Repare, tamb√©m, que a chave `"PA"` n√£o foi adicionada ao dicion√°rio. 

```{python}
capitais
```
Agora, se o objetivo n√£o for saber o valor associado a determinada chave, mas sim saber se a chave existe, isso pode ser feito usando o m√©todo `keys` e o operador l√≥gico `in`:

```{python}
# Chaves do Dicion√°rio
print(capitais.keys())

# Verificando
print(f'A chave "PA" est√° no dicion√°rio capitais? {"PA" in capitais.keys()}')
```

Note que os valores de um dicion√°rio pode ser qualquer tipo de objeto. No entanto, foi usado, at√© ent√£o, para exemplos, apenas `strings`. Por√©m, pode-se colocar todo tipo de coisa dentro dos dicion√°rios, incluindo listas e at√© mesmo outros dicion√°rios:

```{python}
numeros = {"primos": [2, 3, 5], "pares": [0, 2, 4], "√≠mpares": [1, 3, 5]}
print(numeros)
```

```{python}
docente = {
  "Nome": "Prof Dr Vin√≠cius Duarte Lima", 
  "Forma√ß√£o": {"Gradua√ß√£o": "Eng El√©trica", "Mestrado": "Eng El√©trica", "Doutorado": "Eng El√©trica"},
  "Idade": 45,
}

print(docente)
```

Mesmo que os pares `chave: valor` estejam organizados na ordem que foram colocados, n√£o podemos acess√°-los por √≠ndices como far√≠amos em listas:

```         
[Input]  : numeros[2]
[Output] : KeyError: 2
```

Assim como os valores n√£o precisam ser do tipo string, o mesmo vale para as chaves:

```{python}
numeros_por_extenso = {2: "dois", 1: "um", 3: "tr√™s", 0: "zero"}
numeros_por_extenso[0]
```

```{python}
numeros_por_extenso[2]
```

> **Nota:** Listas e outros dicion√°rios n√£o podem ser usados como chaves por serem de tipos mut√°veis.

### Adicionando, Alterando e Removendo Elementos

Para exemplificar os comandos desta se√ß√£o, considere o dicion√°rio abaixo.

```{python}
# Informa√ß√µes de Cleiton
pessoa = {"nome": "Cleiton", "idade": 34, "fam√≠lia": {"m√£e": "Maria", "pai": "Enzo"}}

# Visualizando
pessoa
```

Para adicionar o item `"masculino"` a chave `"gen√™ro"` podemos usar os seguintes comandos:

```{python}
# Adicionando elemento
pessoa["gen√™ro"] = "rom√¢ntico"

# Visualizando
pessoa
```

De forma equivalente, temos:

```{python}
# Dicion√°rio de meses do ano
meses = {1: "Janeiro", 2: "Fevereiro", 3: "Mar√ßo"}

# Adicionando o m√™s de "Abril" na chave 4
meses[4] = "Setembro"

# Visualizando
meses
```
As vezes, podem haver inconsist√™ncias nos dados, logo, se torna necess√°rio corrigir tais inconsist√™ncias. Isso pode ser feito de forma muito simples, veja:

```{python}
# Executando altera√ß√µes
pessoa["gen√™ro"] = "masculino"
meses[4] = "Abril"

# Visualizando
print(pessoa)
print(meses)
```

Um d√∫vida que talvez possa surgir √© como fazer altera√ß√£o em listas que est√£o contidas em dicion√°rios. Na verdade, isso √© feito de forma bastante objetiva, veja:

```{python}
# Novo dicion√°rio
lixo = {"pl√°stico": ["garrafa", "copinho", "canudo"], 
        "papel": ["folha amassada", "guardanapo"], 
        "org√¢nico": ["batata", "resto do bandeco", "casca de banana"]}

# Visualizando
print(lixo)

# Obtendo lista de interesse para altera√ß√£o
lista_de_interesse = lixo["pl√°stico"]

# Verificando em qual posi√ß√£o est√° o elemneto que deve ser alterado
id = lista_de_interesse.index("garrafa")

# Fazendo a altera√ß√£o diretamente no dicion√°rio
lixo['pl√°stico'][id] = "sacola"

# Visualizando dicion√°rio alterado
lixo
```

Note que poderiamos ser mais direto, pois as listas em quest√£o t√™m comprimentos pequenos. Por√©m, tal c√≥digo j√° pode ser implementado para listas de grande comprimento.

Por√©m, ao lidarmos com dicion√°rios, talvez precisemos excluir algum elemento. Ser√£o apresentadas duas formas de fazer isso.

1. Usando o m√©todo `pop()`:
```{python}
pessoa.pop("fam√≠lia")
```
Repare que `dicion√°rio.pop(chave)` exclu√≠ o elemento e retorna os itens da chave exclu√≠da. Para visualizarmos o resultado basta chamar o dicion√°rio.
```{python}
pessoa
```

2. Usando o comando `del` do Python B√°sico:
```{python}
del meses[4]
```
Diferente do m√©todo `pop()`, o comando `del` n√£o retorna nada. Por√©m, para visualizar o resultado, precisamos chamar o objeto.
```{python}
meses
```
Para excluir todos os elementos de um dicion√°rio, temos o m√©todo `clear()`:

```{python}
# Apagando todos os elementos do dicion√°rio
lixo.clear()

# Visualizando
lixo
```

### Fun√ß√£o `list()` e Fun√ß√£o `len()` para Dicion√°rios

A fun√ß√£o `list()` converte um dicion√°rio em uma lista contendo apenas suas chaves:

```{python}
institutos_uspsc = {
    "IFSC": "Instituto de F√≠sica de S√£o Carlos",
    "ICMC": "Instituto de Ci√™ncias Matem√°ticas e de Computa√ß√£o",
    "EESC": "Escola de Engenharia de S√£o Carlos",
    "IAU": "Instituto de Arquitetura e Urbanismo",
    "IQSC": "Instituto de Qu√≠mica de S√£o Carlos"
}

# Convertendo dicion√°rio em lista de chaves
lista_chaves = list(institutos_uspsc)
print(lista_chaves)
```

A fun√ß√£o `len()` retorna o n√∫mero de itens em um objeto. Para dicion√°rios, ela conta o n√∫mero de pares chave-valor:

```{python}
# Contando itens no dicion√°rio
quantidade_institutos = len(institutos_uspsc)
print(quantidade_institutos)

# Equivalente a contar as chaves convertidas em lista
print(len(list(institutos_uspsc)))
```

### Outros comandos para dicion√°rios

Vejamos agora os m√©todos `items()` e `values()`. Considere o seguinte dicion√°rio:

```{python}
pessoa = {"nome": "Enzo", "RA": 242334, "curso": "fiscomp"}
```

1. `items()` - Retorna uma vis√£o dos pares chave-valor:
```{python}
pares = pessoa.items()
print(list(pares))
```

2. `values()` - Retorna uma vis√£o dos valores armazenados:

```{python}
valores = list(pessoa.values())
print(valores)
```

**Observa√ß√£o importante:** A fun√ß√£o `list()` aplicada diretamente a um dicion√°rio (`list(pessoa)`) retorna apenas as chaves, equivalente a `list(pessoa.keys())`.

Dicion√°rios em Python (vers√µes 3.7+) mant√™m a ordem de inser√ß√£o, mas a igualdade entre dicion√°rios considera apenas os pares chave-valor, n√£o a ordem:

```{python}
numerinhos = {"um": 1, "dois": 2, "tr√™s": 3}
numeritos = {"tr√™s": 3, "dois": 2, "um": 1}

print(numerinhos == numeritos)
print(numerinhos)  # Mostra na ordem de inser√ß√£o
print(numeritos)   # Mostra na ordem de inser√ß√£o diferente
```

Outro comando que pode ser usado para adicionar elementos em um dicion√°rio pode ser o m√©todo `update()`.

```{python}
# Lembra do dicion√°rios receitas?
print(receitas)

# Nova receita
outros_elementos = {"mingau": "massa, leite, a√ß√∫car"}

# Adicionando a nova receita
receitas.update(outros_elementos)

# Visualizando
print(receitas)
```

- **Resum√£o:**

1. Os m√©todos `items()` e `values()` (e `keys()`) retornam objetos de visualiza√ß√£o que refletem automaticamente as altera√ß√µes no dicion√°rio original;

2. A partir do Python 3.7, a ordem de inser√ß√£o √© preservada como caracter√≠stica da implementa√ß√£o, tornando-se parte da especifica√ß√£o na vers√£o 3.8;

3. Uso do m√©todo `update` para integraliza√ß√£o de dicion√°rios.

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::