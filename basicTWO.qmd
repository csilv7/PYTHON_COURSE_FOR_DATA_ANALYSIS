```{r include=FALSE, echo=FALSE}
library(reticulate)

reticulate::use_python("C:/Users/user/anaconda3/python.exe", required = TRUE)
```

```{=html}
<style>
  body{text-align: justify}
</style>
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::

# Objetos no Python

## Introdu√ß√£o

Ao longo do curso, j√° mencionamos alguns tipos de objetos enquanto explor√°vamos conceitos b√°sicos de Python. Voc√™ provavelmente j√° viu vari√°veis sendo criadas e usadas, e at√© notou que diferentes valores podem ter diferentes tipos. Agora, chegou o momento de entender melhor os objetos b√°sicos do Python e como eles funcionam.

Neste cap√≠tulo, vamos explorar os principais tipos de objetos que o Python nos oferece, como n√∫meros, strings, listas e dicion√°rios. Al√©m disso, veremos como identificar o tipo de um objeto, buscar ajuda sobre fun√ß√µes e entender melhor as vari√°veis dispon√≠veis no c√≥digo.

Com essa nova organiza√ß√£o do curso, o conte√∫do foi dividido em cap√≠tulos menores para facilitar o aprendizado. Isso evita que tudo seja ensinado de uma vez, tornando a experi√™ncia mais din√¢mica e leve. Ent√£o, vamos come√ßar nossa jornada pelos objetos do Python! üöÄ

## Strings

Tamb√©m chamada de sequ√™ncia de caracteres, textos ou dados alfanum√©ricos, uma *string* √© um tipo de dado que armazena uma *sequ√™ncia de caracteres*. Em Python, pode ser definida com aspas simples (`'`), duplas (`"`) ou triplas (`'''` ou `"""`).

```{python}
"Texto com acentos e cedilhas: hoje √© dia de ca√ßa!"
```

```{python}
# As strings aceitam aspas simples tamb√©m
nome = 'Silvio Santos'
nome
```

### Opera√ß√µes com Strings

Podemos realizar diversas opera√ß√µes matem√°ticas e manipula√ß√µes em strings.

```{python}
# Multiplica√ß√£o repete a string
nome * 3
```
```
[Input]:  nome * 3.14
[Output]: TypeError: can't multiply sequence by non-int of type 'float'
```
```{python}
# Concatena√ß√£o de strings
canto1 = 'vem a√≠, '
canto2 = 'l√° '
nome + ' ' + canto1 + canto2 * 6 + '!!'
```

### Strings Multilinhas

Para definir strings que ocupam m√∫ltiplas linhas, utilize tr√™s aspas (`'''` ou `"""`):

```{python}
str_grande = '''Aqui consigo inserir um text√£o com v√°rias linhas.
Posso iniciar em uma...
... continuar em outra...
... e seguir quantas precisar.'''

str_grande
```

```{python}
print(str_grande)
```

Caso seja necess√°rio incluir aspas dentro da string, podemos alternar entre aspas simples e duplas:

```{python}
agua = "Me d√° um copo d'√°gua"
agua
```

Tamb√©m podemos usar todas as aspas ao mesmo tempo:

```{python}
todas_as_aspas = """Essa √© uma string que tem:
- aspas 'simples'
- aspas "duplas"
- aspas '''triplas'''
Legal, n√©?"""
                    
print(todas_as_aspas)
```

### Tamanho de uma String

A fun√ß√£o embutida `len()` nos permite obter o n√∫mero de caracteres de uma string, incluindo espa√ßos e pontua√ß√£o:

```{python}
len('Abracadabra')
```

```{python}
frase = 'Faz um pull request l√°'
len(frase)
```

```{python}
palavra = "Python"
len(palavra)
```


### Manipula√ß√£o de Strings

#### Indexa√ß√£o

Cada caractere em uma string possui um √≠ndice, come√ßando em `0` para o primeiro elemento e indo at√© `len(string) - 1` para o √∫ltimo elemento ou `-1`.

> *√çndices negativos percorrem de tr√°s para frente*

Para um melhor entendimento inicial, considere a vari√°vel criada na subse√ß√£o anterir:`palavra`. Partindo da defini√ß√£o acima, podemos afirmar que os √≠ndices da vari√°vel `palavra` segue o formato:

| P   | y   | t   | h   | o   | n   |
|-----|-----|-----|-----|-----|-----|
| 0   | 1   | 2   | 3   | 4   | 5   |
| -6  | -5  | -4  | -3  | -2  | -1  |

Vejamos alguns exemplos:

```{python}
# Primeiro caractere
print(palavra[0])
print(palavra[-6])
```
```{python}
# Primeiro caractere
print(palavra[5])
print(palavra[-1])
```

#### Fatiamento

Fatiamento (*slincing*) √© a capacidade de extrair partes de uma string utilizando `inicio:fim - 1:passo`.

```{python}
# Guardando um objeto do tipo str na vari√°vel frase
frase = "A programa√ß√£o em " + palavra + " √© diferenciada!"
frase
```

```{python}
# Comprimento da vari√°vel frase
nStr = len(frase)
nStr
```
```{python}
# Obtendo a frase completa usando fatiamento
print(frase[:nStr - 1])
print(frase[-nStr:])
```
```{python}
# Obtendo a frase de dois em dois caractere
print(frase[:nStr - 1:2])
print(frase[-nStr::2])
```
```{python}
# Obtendo apenas 'A programa√ß√£o'
print(frase[:14])
print(frase[:-25])
```

```{python}
# Obtendo o que h√° depois de 'A programa√ß√£o'
print(frase[14:])
print(frase[-25:])
```

```{python}
# Obtendo toda a frase de tr√°s para frente
print(frase[::-1])
```
> **Nota:** Omitir o primeiro √≠ndice (`start`) ou o segundo √≠ndice (`stop`) significa, respectivamente, come√ßar desde o come√ßo ou terminar no fim.

Resumindo: para fazer uma fatia de nossa string, precisamos saber de onde come√ßa, at√© onde vai e o tamanho do passo.

```         
fati√°vel[come√ßo : fim : passo]
```

##### Aten√ß√£o para o uso de indexa√ß√£o e fatiamento

As fatias incluem o √≠ndice do primeiro elemento e n√£o incluem o elemento do √≠ndice final. Por isso que `frase[0:-1]` perde o √∫ltimo elemento.

Caso o **fim** da fatia seja antes do come√ßo, obtemos um resultado vazio:

```{python}
frase[59:105]
```

O que acontece com uma fatia que est√° fora da string?

```{python}
frase[123:345]
```

E se o **fim** da fatia for superior ao comprimento da string? Sem problemas, o Python pecorrer a string at√© o onde der:

```{python}
frase[8:123456789]
```

Mas um √≠ndice fora do intervalo em acesso direto gera erro:

```         
[Input]  : frase[123456789]
[Output] : IndexError: string index out of range
```

Quando usamos passos negativos, a fatia come√ßa no **fim** e termina no **come√ßo** e √© percorrida ao contr√°rio. Ou seja, invertemos a ordem. Mas tome cuidado:

```{python}
"Python"[2:6]
```

```{python}
"Python"[2:6:-1]
```

```{python}
"Python"[6:2]
```

```{python}
"Python"[6:2:-1]
```

- `"Python"[6:2]`: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© positivo (default). Nesse caso, o resultado √© uma string vazia, pois o slicing avan√ßa para a direita, mas o fim est√° √† esquerda.
- `"Python"[2:6:-1]`: O √≠ndice de in√≠cio (2) √© menor que o √≠ndice de fim (6), mas o passo √© negativo (-1). O slicing tenta avan√ßar para a esquerda, mas o fim est√° √† direita. Novamente, o resultado √© uma string vazia.
- `"Python"[6:2:-1]`: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© negativo (-1). O slicing avan√ßa para a esquerda, come√ßando do √≠ndice 6 ('n') at√© o √≠ndice 2 ('t'), excluindo-o. Isso resulta na string "noh".

### Formata√ß√£o de Strings

Podemos formatar strings utilizando `f-strings`, `.format()` ou `%`:

```{python}
nome = "Breno"
idade = 25

print(f"Ol√°, meu nome √© {nome} e tenho {idade} anos.")  # f-strings
print("Ol√°, meu nome √© {} e tenho {} anos.".format(nome, idade))  # format()
print("Ol√°, meu nome √© %s e tenho %d anos." % (nome, idade))  # Estilo antigo
```
O autor recomenda usar a primeira op√ß√£o.

### M√©todos √öteis para Strings

#### M√©todo `split()`

```{python}
# E da vari√°vel todas_as_aspas?
todas_as_aspas
```

```{python}

# Aplicando m√©todo splint sem argumento (default)
print(todas_as_aspas.split())

# Aplicando m√©todo splint com argumento
print(todas_as_aspas.split("\n"))
```

```{python}
# Lembra da vari√°vel frase?
print(frase)

# Veja como ela fica depois do m√©todo split
print(frase.split())
```

#### Outros m√©todos

```{python}
texto = " Python √©  legal! "
print(texto.lower())     # Deixa tudo min√∫scula
print(texto.upper())     # Deixa tudo mai√∫scula
print(texto.strip())     # Remove espa√ßos extras
print(texto.replace("Python", "Programar"))  # Troca 'Python' por 'Programar'
print(texto.index("√©"))  # Retorna o √≠ndice da primeira ocorr√™ncia de '√©'
print(texto.count("a"))  # Conta quantas vezes 'a' aparece
```
## Listas

Listas s√£o uma das estruturas de dados mais usadas em Python. Elas permitem armazenar m√∫ltiplos valores em uma √∫nica vari√°vel e suportam diversos tipos de opera√ß√µes.

### Declara√ß√£o de Listas

Uma lista em Python √© definida utilizando colchetes `[]`, e seus elementos s√£o separados por v√≠rgulas:

```{python}
# Lista de n√∫meros
numeros = [1, 2, 3, 4, 5]

# Lista de strings
frutas = ["ma√ßa", "banana", "abacaxi"]

# Lista mista
dados = [25, "Jo√£o", True, 3.14]
```

Uma lista tamb√©m pode ser vazia, algo que futaremente veremos que pode ser muito √∫til, por exemplo:

```{python}
vazia = []
vazia
```

### Indexa√ß√£o e Fatiamento

A ideia de √≠ndices e fatias de listas funciona de forma muito parecida com a que foi vista em strings.

```{python}
numeros[0] # Primeiro elemento
```

```{python}
numeros[-1] # √öltimo elemento
```

Assim como na indexa√ß√£o de strings, ao tentar acessar um √≠ndice inv√°lido de uma lista √© retornado um erro.

Ao √≠nves de simplesmente acessar um elemneto atrav√©s de seu √≠ndice, podemos obter uma fatia, que pode ser muito mais interessante.

```{python}
numeros[::2] # Do come√ßo ao fim, de 2 em 2 elementos
```

```{python}
numeros[::-2] # Do fim ao come√ßo, de 2 em 2 elementos
```

```{python}
numeros[:3]   # Tr√™s primeiros elementos
```

```{python}
numeros[3:]   # Elementos a partir do √≠ndice 3
```

```{python}
numeros[::-1] # Lista invertida
```

### Trabalhando com Listas

Imagine que se queira saber se um determinado elemento (objeto) est√° contido em determinada lista. Poderiamos ficar procurando elemento a elemento, vamos tentar essa abordagem. Verifique se o elemento `0.3146778807984779` est√° contido na lista abaixo:

```{python}
import random as rd

rd.seed(42)

va = [rd.random() for _ in range(100)]
va
```
Note que n√£o √© vi√°vel essa abordagem. Para est√° finalidade devemos usar o operador l√≥gico `in`. Veja o exemplo:

```{python}
0.3146778807984779 in va # 'elemento' est√° contido em 'lista'
```

Lembra do operador `not`? Podemos combin√°-lo com o `in` para verificar se um elemento 'n√£o est√°' contido em uma determina lista. Sendo o contr√°rio (nega√ß√£o) da afirma√ß√£o acima.

```{python}
0.3146778807984779 not in va # 'elemento' n√£o est√° contido em 'lista'
```

Veja um exemplo de como o `in` funciona em uma outra situa√ß√£o.

```{python}
lista_mista = ['duas palavras', 42, True, ['batman', 'robin'], -0.84, 'hip√≥fise']
42 in lista_mista
```

```{python}
'batman' in lista_mista
```

```{python}
'batman' in lista_mista[3] # Note que o elemento com √≠ndice 3 tamb√©m √© uma lista
```

Consegue me dizer quantos elementos t√™m na lista `va`? Fique tranquilo! N√£o precisa contar, pode ser usado a fun√ß√£o `len` do Python para responder essa pergunta.

```{python}
len(va)
```

```{python}
len(lista_mista[3])
```

### Adicionar e Remover elementos de uma Lista

Podemos adicionar elementos de diversas formas:

```{python}
# Adiciona um √∫nico elemento ao final da lista
numeros.append(6)
numeros
```

```{python}
# Adiciona v√°rios elementos ao final da lista
numeros.extend([7, 8, 9])
numeros
```

```{python}
# Adiciona um elemento em uma posi√ß√£o espec√≠fica
numeros.insert(2, 15)  # Insere o n√∫mero 15 na posi√ß√£o 2 (3¬∫ elemento)
numeros
```

Podemos remover/excluir elementos de uma lista das seguintes formas:

```{python}
# Remove a primeira ocorr√™ncia de um valor espec√≠fico
numeros.remove(15)  # Remove o n√∫mero 15
numeros
```

```{python}
# Exclui o √∫ltimo elemento da lista
del numeros[-1]
numeros
```

E se, por exemplo, eu precisar come√ßar a lista do zero? Pode-se remover todos os elementos de uma lista, usando o m√©todo `clear()`:

```{python}
va.clear()
print("Lista de n√∫meros aleat√≥rios:")
print(va)

va = [rd.random() for _ in range(100)]
print("Lista de n√∫meros aleat√≥rios:")
print(va)
```

### Modificando elementos

Como as listas s√£o mut√°veis, podemos alterar seus valores diretamente:

```{python}
print(f"Antes da modifica√ß√£o: \n {frutas}")

# Alterando 'banana' por 'melancia'
frutas[1] = "melancia"

# Visualizando
print(f"Depois da modifica√ß√£o: \n {frutas}")
```

Outra forma de se fazer a modifica√ß√£o √©:

```{python}
# Obtendo a posi√ß√£o (√≠ndice) da fruta (string) 'melancia'
id = frutas.index("melancia")

# Alterando 'melancia' por 'banana'
frutas[id] = "melancia"

# Visualizando
print(frutas)
```

### Ordena√ß√£o de Listas

Por v√°rios motivos, pode ser √∫til ter em m√£os uma lista ordenada. Como fazer isso? Veja os exemplos:

```{python}
desordenada = ['b', 'z', 'k', 'a', 'h']
print(f"Lista desordenada: \n {desordenada}")

# Ordenando
desordenada.sort()
print(f"Lista ordenada: \n {desordenada}")
```
Voltemos a lista `va`:

```{python}
# Modificando va um pouco
va_modified = [round(va[i] * 100) for i in range(len(va))]
print(va_modified)
print()

# Ordenado de forma crescente
va_modified.sort()
print(va_modified)
print()

# Ordenado de forma decrescente
va_modified.sort(reverse=True)
print(va_modified)
```

Al√©m do m√©todo `sort`, tem a fun√ß√£o nativa do Python. Fun√ß√£o `sorted()`: 

```{python}
# Ordenado de forma crescente novamente
va_modified = sorted(va_modified)
print(va_modified)
```

### C√≥pia de Listas

C√≥pia ou c√≥pias de listas se torna algo de grande valor quando se quer fazer alguma manipula√ß√£o, por√©m n√£o se quer alterar as informa√ß√µes originais. Para isso, deve-se usar o m√©todo `copy()`:

```{python}
# Criando listas
l1 = [[1, 2, 3], ["x", "y", "z"], [True, False]]
l2 = l1.copy() # l2 √© a c√≥pia de l1

# Visualizando
print(l1)
print(l2)

print()

# Adicioando um elemento novo somente a l2
l2.append([1/4, 1/2, 3/4, 1])

# Visualizando
print(l1)
print(l2)
```

Agora, observe o que acontece se n√£o fizer uso do `copy()`:

```{python}
# Criando listas
l1 = [[1, 2, 3], ["x", "y", "z"], [True, False]]
l2 = l1 # l2 'igual' a l1

# Visualizando
print(l1)
print(l2)

print()

# Adicioando um elemento novo somente a l2
l2.append([1/4, 1/2, 3/4, 1])

# Visualizando
print(l1)
print(l2)
```

### Operando Listas

Fazendo uso ao conhecimento adquirido de strings. Temos os operadores `+` e `*`, que funcionam de forma muito similar e obdecem as mesmas regras.

O operador `+` concatena (semelhante ao m√©todo `extend()`) listas:

```{python}
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
c
```

O operador `*` repete a lista dado um n√∫mero de vezes:

```{python}
a * 2
```

```{python}
d = c + a + b + 2 * c
d
```

O Python fornece v√°rias outras opera√ß√µes √∫teis para listas, calculadas com fun√ß√µes do m√≥dulo b√°sico do Python. Entretanto, tais fun√ß√µes s√≥ se aplicam a listas num√©ricas:

```{python}
print(f"Soma da lista 'd': {sum(d)}")
print(f"Maior valor da lista 'd': {max(d)}")
print(f"Menor valor da lista 'd': {min(d)}")
```
Agora, imagine que seja necess√°rio saber quantas vezes um determinado elemento se repete dentro de uma lista. Tal a√ß√£o pode ser feita pelo m√©todo `count()`:

```{python}
# Lembra dessa lista
print(va_modified)

# Quanta vezes o n√∫mero 100 aparece?
print(va_modified.count(100))
```

### Uso da Fun√ß√£o `range()` em Listas

Em Python, al√©m de fun√ß√µes como print(), len(), sum(), max() e min(), temos a fun√ß√£o range(), que tamb√©m faz parte do m√≥dulo b√°sico. Essa fun√ß√£o √© extremamente √∫til para criar sequ√™ncias num√©ricas, especialmente listas. Imagine que voc√™ precise criar uma lista com os n√∫meros de 1 a 200. Como fazer isso de forma eficiente?

Uma abordagem seria escrever todos os n√∫meros manualmente:

```         
lista_grande = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ..., 200]
```

No entanto, essa n√£o √© a forma mais pr√°tica. √â a√≠ que entra a fun√ß√£o `range()`. Com ela, podemos gerar essa lista de forma muito mais simples:

```{python}
list(range(1, 201))  # Note que o limite superior √© 201
```

O `range()` tamb√©m oferece flexibilidade para gerar sequ√™ncias com intervalos espec√≠ficos. Por exemplo, para obter os n√∫meros de 0 a 29, pulando de 5 em 5:

```{python}
list(range(0, 30, 5))
```

Al√©m disso, o `range()` tamb√©m oferece algumas coisas interessantes. Por exemplo, imprimir os n√∫meros espa√ßados de 5 em 5, entre 0 e 30:

```{python}
list(range(0, 30, 5))
```

A sintaxe geral do `range()` √©: `range(start, stop, step)`, onde:

- `start`: O valor inicial da sequ√™ncia (inclusivo).
- `stop`: O valor final da sequ√™ncia (exclusivo).
- `step`: O intervalo entre os valores.

Por que precisamos converter `range()` para `list`?

```{python}
print(range(200))
print(type(range(200)))
```

Isso acontece porque `range(`) retorna um objeto do tipo `range`, que representa uma sequ√™ncia num√©rica, mas n√£o √© uma lista em si. Para visualizar os n√∫meros, precisamos convert√™-lo explicitamente para uma lista:

```{python}
range_lista = list(range(200))
print(range_lista)
```

## Dicion√°rios

Dicion√°rios em Python s√£o estruturas de dados poderosas que armazenam informa√ß√µes no formato chave-valor. Diferentemente das listas, que s√£o indexadas por n√∫meros, os dicion√°rios usam chaves imut√°veis (strings, n√∫meros, tuplas, etc.) para acessar seus valores.

Um dicion√°rio √© uma cole√ß√£o de pares chave-valor, onde cada chave √© √∫nica e est√° associada a um valor: `{chave: valor}`.

- **Chaves √önicas:** Uma caracter√≠stica fundamental dos dicion√°rios √© que cada chave deve ser √∫nica. Tentar inserir chaves duplicadas resultar√° na substitui√ß√£o do valor anterior.

### Declara√ß√£o de Dicion√°rios

Em Python, dicion√°rios podem ser criados de diversas maneiras, oferecendo flexibilidade para diferentes situa√ß√µes.

1. **Cria√ß√£o Direta com Chaves e Valores:**

```{python}
# Dicion√°rio com informa√ß√µes de uma receita
receita = {
    "farinha": "2 x√≠caras",
    "ovos": 3,
    "leite condensado": "1 lata"
}

# Dicion√°rio com n√∫meros de telefone
telefones = {"ana": 123456, "yudi": 40028922, "julia": 4124492}
```

Neste exemplo, `"ana"` √© uma chave que est√° associada ao valor `123456`. Cada par chave-valor √© separado por v√≠rgula.

```{python}
print(receita)
print()
print(telefones)
```

2. **Cria√ß√£o de um Dicion√°rio Vazio:**

Voc√™ pode criar um dicion√°rio vazio usando apenas chaves {}:

```{python}
contatos = {}
contatos
```

3. **Cria√ß√£o com a Fun√ß√£o dict():**

A fun√ß√£o `dict()` permite criar dicion√°rios de forma mais expl√≠cita, especialmente quando as chaves s√£o strings simples:

```{python}
pessoa = dict(nome="Carlos", idade=30, cidade="S√£o Paulo")
pessoa
```

4. **Com uma lista de listas:**

```{python}
# Definindo tr√™s listas diferentes
l1 = ["brigadeiro", "leite condesado, achocolatado"]
l2 = ["omelete", "ovos, azeite, condimentos a gosto"]
l3 = ["ovo frito", "ovo, √≥leo, condimentos a gosto"]

# Criando uma lista de listas
lr = [l1, l2, l3]

# Visualizando resultado
lr
```

```{python}
# Transformando lista de listas em um dicion√°rio
receitas = dict(lr)

# Visualizando o resultado
receitas
```

### Chaves

Podemos acessar os valores de um dicion√°rio atrav√©s de suas chaves:

```{python}
# Definindo um dicion√°rio para capitais de estados brasileiros
capitais = {"SP": "S√£o Paulo", "AC": "Rio Branco", "TO": "Palmas",
            "RJ": "Rio de Janeiro", "SE": "Aracaju", "MG": "Belo Horizonte"}

# Acessando o valor correspondente a chave "MG"
capitais["MG"]
```

Caso a chave n√£o exista, podemos evitar erros usando o m√©todo `get()`:

```{python}
capitais.get("PA")
```

```{python}
capitais.get("PA", "N√£o tem!")
```

Note que o m√©todo `get()` funciona de forma similar ao c√≥digo `dicion√°rio[chave]`, entretanto, caso a chave n√£o exista garantimos que o c√≥digo n√£o gere erro diferente do que aconteceria fosse usado `dicion√°rio[chave]`.

Repare, tamb√©m, que a chave `"PA"` n√£o foi adicionada ao dicion√°rio. 

```{python}
capitais
```
Agora, se o objetivo n√£o for saber o valor associado a determinada chave, mas sim saber se a chave existe, isso pode ser feito usando o m√©todo `keys` e o operador l√≥gico `in`:

```{python}
# Chaves do Dicion√°rio
print(capitais.keys())

# Verificando
print(f'A chave "PA" est√° no dicion√°rio capitais? {"PA" in capitais.keys()}')
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::