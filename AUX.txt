```{r include=FALSE, echo=FALSE}
library(reticulate)
use_python("C:/Users/user/anaconda3/python.exe", required = TRUE)
```

```{=html}
<style>
  body{text-align: justify}
</style>
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::

# Primeiros Passos

## Introdu√ß√£o ao Python

Neste primeiro cap√≠tulo, daremos os passos iniciais no mundo da programa√ß√£o com Python. Vamos entender o que √© essa linguagem, por que ela se tornou t√£o popular (especialmente para an√°lise de dados) e como preparar nosso ambiente para come√ßar a codificar.

### O Que Torna Python Especial?

Python √© frequentemente descrita como uma linguagem de programa√ß√£o **poderosa**, **vers√°til** e, acima de tudo, **leg√≠vel**. Mas o que isso significa na pr√°tica?

1.  **Linguagem Interpretada:** Diferente de linguagens compiladas (como C++ ou Java), onde o c√≥digo fonte √© traduzido para c√≥digo de m√°quina antes da execu√ß√£o, o c√≥digo Python √© executado linha por linha por um programa chamado **interpretador**. Isso facilita o desenvolvimento e o teste, pois voc√™ pode executar pequenos trechos de c√≥digo rapidamente.
2.  **Alto N√≠vel:** Python abstrai muitos detalhes complexos do hardware do computador (como gerenciamento de mem√≥ria). Isso permite que voc√™ se concentre na l√≥gica do problema que est√° tentando resolver, em vez de se preocupar com detalhes de baixo n√≠vel.
3.  **Tipagem Din√¢mica:** Voc√™ n√£o precisa declarar explicitamente o tipo de uma vari√°vel (inteiro, texto, etc.) antes de us√°-la. O Python infere o tipo automaticamente durante a execu√ß√£o. Isso torna o c√≥digo mais conciso, mas exige aten√ß√£o para evitar erros relacionados a tipos inesperados.
4.  **Prop√≥sito Geral:** Python n√£o se limita a uma √∫nica √°rea. √â usada em desenvolvimento web, automa√ß√£o de tarefas, intelig√™ncia artificial, computa√ß√£o cient√≠fica e, claro, **an√°lise e ci√™ncia de dados**.
5.  **Sintaxe Clara e Leg√≠vel:** A sintaxe do Python foi projetada para ser pr√≥xima da linguagem humana, utilizando indenta√ß√£o (espa√ßos no in√≠cio da linha) para definir blocos de c√≥digo, o que for√ßa a escrita de um c√≥digo visualmente organizado.

Essas caracter√≠sticas, combinadas com um vasto ecossistema de bibliotecas (conjuntos de c√≥digo pr√©-escrito para tarefas espec√≠ficas), fazem do Python uma ferramenta excepcional para an√°lise de dados, adotada por gigantes como Google, NASA, Facebook (Meta), Amazon e Spotify.

### Configurando o Ambiente: Anaconda e Jupyter Notebook

Para come√ßar nossa jornada, precisamos instalar o Python e as ferramentas necess√°rias. A maneira mais recomendada para iniciantes em an√°lise de dados √© usar a **Distribui√ß√£o Anaconda**.

**O que √© Anaconda?** √â um pacote que inclui:

*   O interpretador Python.
*   Um gerenciador de pacotes (bibliotecas) chamado `conda`.
*   Diversas bibliotecas cient√≠ficas e de an√°lise de dados pr√©-instaladas (como NumPy, Pandas, Matplotlib).
*   Ferramentas √∫teis, como o **Jupyter Notebook** e o **JupyterLab**.

**O que √© Jupyter Notebook?** √â uma aplica√ß√£o web interativa que permite criar e compartilhar documentos (chamados *notebooks*) que cont√™m c√≥digo execut√°vel (como Python), texto formatado (Markdown), equa√ß√µes, visualiza√ß√µes e muito mais. √â um ambiente ideal para aprendizado, experimenta√ß√£o e apresenta√ß√£o de an√°lises de dados.

**Passos para Instala√ß√£o:**

1.  **Download:** Acesse o site oficial do Anaconda: [https://www.anaconda.com/download](https://www.anaconda.com/download)
2.  **Escolha seu Sistema Operacional:** Baixe o instalador apropriado para Windows, macOS ou Linux.
3.  **Instala√ß√£o:** Execute o instalador e siga as instru√ß√µes. Geralmente, as op√ß√µes padr√£o s√£o adequadas para iniciantes.
4.  **V√≠deo de Apoio:** Se precisar de ajuda visual, este [tutorial de instala√ß√£o no YouTube](https://youtu.be/_eK0z5QbpKA?si=iqLmmQcuDoQqZ-b) pode ser √∫til.

::: {.callout-tip title="D√∫vidas na Instala√ß√£o?"}
Se encontrar problemas, n√£o hesite em procurar tutoriais mais espec√≠ficos para sua vers√£o do sistema operacional ou entrar em contato:

*   **Email do Instrutor:** breno.silva@icen.ufpa.br
:::

Ap√≥s a instala√ß√£o, voc√™ poder√° iniciar o Jupyter Notebook (geralmente atrav√©s do Anaconda Navigator ou pelo terminal/prompt de comando digitando `jupyter notebook`).

## Sintaxe B√°sica: A Gram√°tica do Python

Toda linguagem tem suas regras. Em Python, a sintaxe define como escrevemos comandos v√°lidos que o interpretador possa entender. Vamos come√ßar com o b√°sico.

### Exibindo Informa√ß√µes: A Fun√ß√£o `print()`

A primeira fun√ß√£o que a maioria dos programadores aprende √© a `print()`. Sua finalidade √© exibir informa√ß√µes (texto, n√∫meros, resultados de c√°lculos) na tela (console ou sa√≠da do notebook).

O famoso "Hello, World!":

```python
print("Hello, World!")
```

**Como funciona?**

*   `print` √© o nome da fun√ß√£o.
*   Os par√™nteses `()` s√£o usados para chamar a fun√ß√£o e passar informa√ß√µes para ela.
*   O que est√° dentro dos par√™nteses √© chamado de **argumento**. Neste caso, o argumento √© o texto (string) `"Hello, World!"`.
*   Strings em Python s√£o definidas usando aspas simples (`'...'`) ou duplas (`"..."`).

#### Erros Comuns com `print()`

√â normal cometer erros ao aprender. Vejamos alguns deslizes comuns com `print()`:

1.  **Nome Incorreto (Case-Sensitive):** Python diferencia mai√∫sculas de min√∫sculas.

    ```python
    # Exemplo de C√≥digo Incorreto
    Print("Ol√°")
    ```
    *Erro Gerado:* `NameError: name 'Print' is not defined` (O Python n√£o reconhece 'Print' com 'P' mai√∫sculo).

2.  **Faltando Aspas:** Textos (strings) precisam estar entre aspas.

    ```python
    # Exemplo de C√≥digo Incorreto
    print(Ol√°)
    ```
    *Erro Gerado:* `SyntaxError: invalid syntax` (O Python n√£o entende 'Ol√°' como um comando ou vari√°vel v√°lida sem aspas).

3.  **Aspas Incompletas:** Abrir aspas e n√£o fechar (ou vice-versa).

    ```python
    # Exemplo de C√≥digo Incorreto
    # print("Ol√°)
    ```
    *Erro Gerado:* `SyntaxError: unterminated string literal` (A string n√£o foi finalizada corretamente).

4.  **Misturar Tipos de Aspas:** Come√ßar com simples e terminar com duplas (ou vice-versa).

    ```python
    # Exemplo de C√≥digo Incorreto
    # print('Ol√°")
    ```
    *Erro Gerado:* `SyntaxError: unterminated string literal`.

::: {.callout-important title="Aten√ß√£o √† Sintaxe!"}
Erros de sintaxe s√£o como erros de gram√°tica. O interpretador Python precisa que as regras sejam seguidas para entender suas instru√ß√µes. Prestar aten√ß√£o aos detalhes (mai√∫sculas/min√∫sculas, par√™nteses, aspas) √© fundamental.
:::

**Usando Aspas Dentro de Strings:**

Se precisar incluir aspas no seu texto, alterne os tipos de aspas:

```python
print('Ele disse: "Python √© incr√≠vel!"')
print("O livro se chama 'O Guia do Mochileiro das Gal√°xias'.")
```

**Quebras de Linha:**

Para inserir uma quebra de linha dentro de uma string, use o caractere especial `\n` (barra invertida seguida de 'n'):

```python
print("Linha 1\nLinha 2\nLinha 3")
```

### Operadores Matem√°ticos: Calculando com Python

Python pode ser usado como uma calculadora poderosa. Ele suporta os operadores matem√°ticos b√°sicos e alguns mais avan√ßados. Observe a @tbl-operMath.

```{r, echo=FALSE}
#| label: tbl-operMath
#| tbl-cap: "Operadores Matem√°ticos."

library(knitr)

# Dados da Tabela
tbl <- data.frame(
  Operador = c("`+`", "`-`", "`*`", "`/`", "`//`", "`%`", "`**`"),
  Desc = c("Adi√ß√£o", "Subtra√ß√£o", "Multiplica√ß√£o", "Divis√£o (`float`)", "Divis√£o (`int`)",
           "M√≥dulo (Resto)", "Exponencia√ß√£o"),
  Ex = c("`5 + 3`", "`5 - 3`", "`5 * 3`", "`10 / 3`", "`10 // 3`", "`10 % 3`", "`2 ** 3`"),
  Result = c("`8`", "`2`", "`15`", "`3.3333`", "`3`", "`1`", "`8`")
)

# Gerando Tabela
kable(
  x = tbl,
  align = "c",
  col.names = c("Operador", "Descri√ß√£o", "Exemplo", "Resultado")
)
```

**Exemplos:**

```{python}
# Adi√ß√£o e Subtra√ß√£o
print(10 + 5)  
print(10 - 5.5)

# Multiplica√ß√£o e Divis√£o
print(4 * 7)
print(15 / 4)   # Divis√£o resulta em float

# Divis√£o Inteira (descarta a parte decimal)
print(15 // 4)  

# M√≥dulo (resto da divis√£o inteira)
print(15 % 4)   # 15 dividido por 4 √© 3, com resto 3

# Exponencia√ß√£o (pot√™ncia)
print(3 ** 4)   # 3 elevado √† 4¬™ pot√™ncia
```

::: {.callout-danger title="Divis√£o por Zero"}
Assim como na matem√°tica, tentar dividir por zero em Python gera um erro:

```python
10 / 0
```
*Erro Gerado:* `ZeroDivisionError: division by zero`
:::

**Calculando Raiz Quadrada:**

Podemos usar exponencia√ß√£o com expoente fracion√°rio:

```{python}
print(81 ** 0.5) # Raiz quadrada de 81
```

No entanto, a forma mais comum e recomendada √© usar a fun√ß√£o `sqrt()` da biblioteca (m√≥dulo) `math`:

```{python}
import math # Importa a biblioteca math

print(math.sqrt(81))
```

::: {.callout-note title="Importando M√≥dulos"}
O comando `import math` torna todas as fun√ß√µes e constantes definidas no m√≥dulo `math` dispon√≠veis para uso no seu c√≥digo. Veremos mais sobre m√≥dulos e bibliotecas posteriormente.
:::

### Express√µes Num√©ricas e Preced√™ncia

Podemos combinar m√∫ltiplos operadores em uma √∫nica express√£o:

```{python}
3 + 4 * 2 - 5 / 2 ** 2
```

Qual a ordem de execu√ß√£o? Python segue a ordem de preced√™ncia padr√£o da matem√°tica, conhecida como **PEMDAS**:

1.  **P**ar√™nteses `()` - Opera√ß√µes dentro de par√™nteses s√£o executadas primeiro.
2.  **E**xponencia√ß√£o `**`
3.  **M**ultiplica√ß√£o `*`, **D**ivis√£o `/`, Divis√£o Inteira `//`, M√≥dulo `%` (executados da esquerda para a direita se tiverem a mesma preced√™ncia).
4.  **A**di√ß√£o `+`, **S**ubtra√ß√£o `-` (executados da esquerda para a direita se tiverem a mesma preced√™ncia).

No exemplo `3 + 4 * 2 - 5 / 2 ** 2`:

1.  `2 ** 2` √© `4`
2.  `4 * 2` √© `8`
3.  `5 / 4` √© `1.25`
4.  `3 + 8` √© `11`
5.  `11 - 1.25` √© `9.75`

Use par√™nteses para controlar a ordem quando necess√°rio:

```{python}
(3 + 4) * (2 - 5) / (2 ** 2)
# (7) * (-3) / (4) = -21 / 4 = -5.25
```

#### Uma Nota Sobre N√∫meros Decimais (Ponto Flutuante)

Voc√™ pode notar resultados ligeiramente inesperados ao trabalhar com n√∫meros decimais (chamados *floats* em Python):

```{python}
print(0.1 + 0.2)
```

Por que `0.30000000000000004` e n√£o `0.3`? A maioria dos computadores utiliza a representa√ß√£o bin√°ria (base 2) para armazenar n√∫meros. O problema √© que muitas fra√ß√µes decimais (base 10), como `0.1`, n√£o podem ser representadas exatamente em bin√°rio. Isso ocorre porque a representa√ß√£o bin√°ria tem um n√∫mero finito de d√≠gitos, assim como ocorre na representa√ß√£o decimal. Por exemplo, ao representar $1/3$ em decimal, obt√©m-se uma repeti√ß√£o infinita: $0.3333 \ldots$ Da mesma forma, a convers√£o de `0.1` para bin√°rio gera uma fra√ß√£o peri√≥dica infinita.

Os computadores modernos seguem o padr√£o IEEE 754 para representar n√∫meros de ponto flutuante. Esse padr√£o define como os n√∫meros s√£o armazenados na mem√≥ria, incluindo a precis√£o. Em Python, os n√∫meros de ponto flutuante geralmente utilizam precis√£o dupla do IEEE 754, que oferece 53 bits de precis√£o. Quando um n√∫mero como 0.1 √© digitado, o computador encontra a fra√ß√£o bin√°ria mais pr√≥xima poss√≠vel dentro desse limite de precis√£o. O resultado √© um valor muito pr√≥ximo de 0.1, mas n√£o exatamente igual.

::: {.callout-tip title="Lidando com Imprecis√µes de Float"}
Para a maioria das aplica√ß√µes em an√°lise de dados, essa pequena imprecis√£o n√£o √© um problema. Ao exibir resultados, voc√™ pode arredondar os n√∫meros usando a fun√ß√£o `round()`:

```{python}
print(round(0.1 + 0.2, 2)) # Arredonda para 2 casas decimais
```

Para c√°lculos financeiros ou cient√≠ficos que exigem alta precis√£o, Python oferece m√≥dulos como `Decimal`.
:::

### Compara√ß√µes e Operadores L√≥gicos

Frequentemente, precisamos comparar valores em nossos programas. Python oferece operadores de compara√ß√£o que retornam um valor **booleano**: `True` (Verdadeiro) ou `False` (Falso).

```{r, echo=FALSE}
#| label: tbl-operComp
#| tbl-cap: "Operadores de Compara√ß√£o."

library(knitr)

# Dados da Tabela
tbl <- data.frame(
  Operador = c("`<`", "`>`", "`<=`", "`>=`", "`==`", "`!=`"),
  Desc = c("Menor que", "Maior que", "Menor ou igual a", "Maior ou igual a", "Igual a", "Diferente de"),
  Ex = c("`5 < 10`", "`5 > 10`", "`10 <= 10`", "`10 >= 10`", "`5 == 5`", "`5 != 10`"),
  Result = c("`True`", "`False`", "`True`", "`True`", "`True`", "`True`")
)

# Gerando Tabela
kable(
  x = tbl,
  align = "c",
  col.names = c("Operador", "Descri√ß√£o", "Exemplo", "Resultado")
)

```

**Exemplos:**

```{python}
# Idade M√≠nima igual a 18
# Idade do Usu√°rio igual a 25

print("Usu√°rio √© maior de idade?", 25 >= 18)
print("As idades s√£o iguais?", 25 >= 18)
print("As idades s√£o diferentes?", 25 >= 18)
```

**Operadores L√≥gicos:**

Podemos combinar m√∫ltiplas compara√ß√µes usando operadores l√≥gicos:

```{r, echo=FALSE}
#| label: tbl-operLog
#| tbl-cap: "Operadores L√≥gicos."

library(knitr)

# Dados da Tabela
tbl <- data.frame(
  Operador = c("`and`", "`or`", "`not`"),
  Desc = c("**Ambas** as condi√ß√µes forem `True`",
           "**Pelo menos uma** das condi√ß√µes for `True`",
           "A condi√ß√£o seguinte for `False` (inverte o valor l√≥gico)"),
  Ex = c("`(5 < 10) and (10 > 3)`", "`(5 > 10) or (10 == 10)`", "`not (5 == 10)`"),
  Result = c("`True`", "`True`", "`True`")
)

# Gerando Tabela
kable(
  x = tbl,
  align = "c",
  col.names = c("Operador", "Resultado √© `True` se", "Exemplo", "Resultado")
)
```


**Exemplos:**

```{python}
# Tem Ingresso igual a True
# √â maior de idade igual a False

# Pode entrar na festa? (Precisa ter ingresso E ser maior de idade)
print("Pode entrar na festa?", True and False)

# Pode receber desconto? (Precisa ter ingresso OU ser maior de idade - exemplo hipot√©tico)
print("Pode receber desconto?", True or False)

# N√£o tem ingresso?
print("N√£o tem ingresso?", not True)
```

```{python}
print((1 and 4) < 3)
print((1 or 4) < 3)
print((1 and 2 and 2.99) < 3)
print((1 or 2 or 2.99) > 3)
```

```{python}
print((5 >= 4.99) and (10 <= 10.01))
print((5 >= 4.99) and (10 == 10.01))
```

```{python}
print((5 >= 4.99) or (10 <= 10.01))
print((5 >= 4.99) or (10 == 10.01))
```

```{python}
print(1 == 1)
print(not 1 == 1)
print(not not 1 == 1)
print(not not not 1 == 1)
```

**Preced√™ncia dos Operadores L√≥gicos:**

Assim como os operadores matem√°ticos, os l√≥gicos tamb√©m t√™m uma ordem de avalia√ß√£o:

1.  `not` √© avaliado primeiro.
2.  `and` √© avaliado em seguida.
3.  `or` √© avaliado por √∫ltimo.

Exemplo:

```{python}
print(not False and True or False)
# 1. not False -> True
# 2. True and True -> True
# 3. True or False -> True
```

Use par√™nteses `()` para garantir a ordem desejada quando a express√£o for complexa.

### Vari√°veis: Armazenando Informa√ß√µes

Uma **vari√°vel** funciona como um r√≥tulo ou um nome que damos a um local na mem√≥ria do computador onde um valor (um objeto) est√° armazenado. Isso nos permite referenciar e reutilizar valores facilmente.

O processo de criar uma vari√°vel e associar um valor a ela √© chamado de **atribui√ß√£o**, e usamos o sinal de igual (`=`) para isso.

```{python}
# Atribui√ß√£o
quantidade_alunos = 19
preco_produto = 34.99
mensagem_boas_vindas = "Ol√°, estudante!"
curso_ativo = True

# Usando as vari√°veis
print(quantidade_alunos)
print(mensagem_boas_vindas)
```

#### Regras e Conven√ß√µes para Nomes de Vari√°veis

Escolher nomes significativos torna o c√≥digo muito mais f√°cil de entender.

*   **Regras (Obrigat√≥rias):**
    *   Nomes devem come√ßar com uma letra (a-z, A-Z) ou underscore (`_`).
    *   O restante do nome pode conter letras, n√∫meros (0-9) e underscores.
    *   Nomes s√£o *case-sensitive* (`idade` √© diferente de `Idade`).
    *   N√£o podem ser iguais a **palavras-chave** reservadas do Python (como `if`, `else`, `for`, `while`, `def`, `class`, `import`, `True`, `False`, `None`, etc.).
*   **Conven√ß√µes (Boas Pr√°ticas - PEP 8):**
    *   Use nomes em min√∫sculas.
    *   Separe palavras com underscores (estilo `snake_case`). Ex: `taxa_juros`, `nome_cliente`.
    *   Escolha nomes descritivos que indiquem o prop√≥sito da vari√°vel.

*   **Exemplos V√°lidos:** `idade`, `nome_completo`, `total_vendas`, `_variavel_privada` (conven√ß√£o)

*   **Exemplos Inv√°lidos:**

    ```python
    # Errado: come√ßa com n√∫mero
    1_lugar = "Ouro"
    
    # Errado: cont√©m caractere especial (@)
    email@cliente = "teste@exemplo.com"
    
    # Errado: usa palavra-chave (def)
    def = "defini√ß√£o"
    ```

    Tentar usar um nome inv√°lido ou uma palavra-chave resultar√° em `SyntaxError`.
    Tentar usar uma vari√°vel que n√£o foi definida (atribu√≠da) ainda resultar√° em `NameError`.

#### Atribui√ß√£o com Express√µes e Atualiza√ß√£o

Podemos atribuir o resultado de uma express√£o a uma vari√°vel:

```{python}
preco_unitario = 50
quantidade = 5
desconto = 0.10

valor_bruto = preco_unitario * quantidade
valor_desconto = valor_bruto * desconto
valor_final = valor_bruto - valor_desconto

print("Valor final:", valor_final)
```

Para atualizar o valor de uma vari√°vel existente, podemos usar a pr√≥pria vari√°vel na express√£o √† direita do `=`:

```{python}
contador = 0
print("Contador inicial:", contador)

contador = contador + 1 # Incrementa o valor
print("Contador ap√≥s incremento:", contador)
```

Python oferece **operadores de atribui√ß√£o compostos** como atalhos:

*   `+=` (Adi√ß√£o): `x += 1` √© o mesmo que `x = x + 1`
*   `-=` (Subtra√ß√£o): `x -= 5` √© o mesmo que `x = x - 5`
*   `*=` (Multiplica√ß√£o): `x *= 2` √© o mesmo que `x = x * 2`
*   `/=` (Divis√£o): `x /= 4` √© o mesmo que `x = x / 4`
*   `//=` , `%=` , `**=` (an√°logos para divis√£o inteira, m√≥dulo e exponencia√ß√£o)

```{python}
num = 10
num += 3  # num agora √© 13
print(num)

num *= 2  # num agora √© 26
print(num)
```

#### Atribui√ß√£o M√∫ltipla

Python permite atribuir valores a m√∫ltiplas vari√°veis na mesma linha:

```{python}
x, y, z = 10, 20, "teste"
print(x)
print(y)
print(z)
```

N√£o parece algo t√£o interessante, n√£o √©? Vamos a um exemplo. Imagine um problema que envolve duas vari√°veis `a` e `b`. O Python permite a **atribui√ß√£o m√∫ltipla**, o que pode ser √∫til para trocar valores entre vari√°veis de forma eficiente.

```{python}
a, b = 1, 200
print(a, b)  # Sa√≠da: 1 200
```

Agora, pense como poderiamos trocar os valores dessas vari√°veis. Pensou? Em algum momento deve ter passado pela sua cabe√ßa a seguinte l√≥gica:

```{python}
a = b # Perde-se o valor original de a (1)
print(a)


b = a # Como perdeu-se a, `b vai continuar com seu valor original (200)
print(b)
```

Em outras linguagens, para trocar valores entre duas vari√°veis, seria necess√°rio usar uma vari√°vel auxiliar:

```{python}
a, b = 1, 200
print(a, b)  # Sa√≠da: 1 200

aux = a
a = b
b = aux
print(a, b)  # Agora a = 200 e b = 1
```

No entanto, em Python, a troca pode ser feita de forma mais elegante usando atribui√ß√£o m√∫ltipla:

```{python}
a, b = 1, 200
print(a, b)  # Sa√≠da: 1 200

a, b = b, a
print(a, b)  # Agora a = 200 e b = 1
```

Note que essa abordagem pode ser expandida para m√∫ltiplas vari√°veis.

### Tipos de Objetos Fundamentais

J√° vimos alguns tipos de dados (valores) que podemos armazenar em vari√°veis. Cada valor em Python √© um **objeto**, e cada objeto pertence a um **tipo** (ou **classe**). O tipo define quais opera√ß√µes podem ser realizadas com aquele objeto.

Podemos verificar o tipo de um objeto usando a fun√ß√£o `type()`:

```{python}
numero_inteiro = 100
numero_decimal = 3.14159
texto = "An√°lise de Dados"
logico = False

print(type(numero_inteiro))
print(type(numero_decimal))
print(type(texto))
print(type(logico))
```

**Principais Tipos Primitivos:**

*   **`int` (Inteiro):** N√∫meros inteiros, positivos ou negativos, sem parte decimal (ex: `-10`, `0`, `42`).
*   **`float` (Ponto Flutuante):** N√∫meros reais, que possuem uma parte decimal (ex: `-3.14`, `0.0`, `99.99`).
*   **`str` (String):** Sequ√™ncias de caracteres (texto), delimitadas por aspas simples ou duplas (ex: `'Python'`, `"Ol√°, mundo!"`).
*   **`bool` (Booleano):** Representa valores l√≥gicos de Verdadeiro (`True`) ou Falso (`False`).
*   **`NoneType` (None):** Um tipo especial que tem apenas um valor: `None`. Usado para representar a aus√™ncia de valor.

Al√©m desses, Python possui tipos de dados mais complexos para agrupar informa√ß√µes, que veremos em detalhes mais adiante:

*   **`list` (Lista):** Cole√ß√£o ordenada e *mut√°vel* de itens.
*   **`tuple` (Tupla):** Cole√ß√£o ordenada e *imut√°vel* de itens.
*   **`dict` (Dicion√°rio):** Cole√ß√£o n√£o ordenada de pares chave-valor.
*   **`set` (Conjunto):** Cole√ß√£o n√£o ordenada de itens √∫nicos.

### M√©todos e Atributos

Em Python, os conceitos de m√©todos e atributos s√£o fundamentais na programa√ß√£o orientada a objetos (POO). Eles definem as caracter√≠sticas e comportamentos dos objetos.

#### M√©todos

- **Defini√ß√£o:**
    * M√©todos s√£o fun√ß√µes definidas dentro de um objeto. Eles definem os comportamentos ou a√ß√µes que um objeto pode realizar.
    * Pense neles como as "a√ß√µes" que um objeto pode executar.
- **Exemplo:**
    * Em um objeto `carro`, m√©todos poderiam ser `ligar()`, `acelerar()` e `frear()`.
- **Acesso:**
    * Chamamos m√©todos usando a sintaxe `objeto.m√©todo()`.

#### Atributos

- **Defini√ß√£o:**
    * Atributos s√£o vari√°veis que armazenam dados dentro de um objeto. Eles representam as caracter√≠sticas ou propriedades de um objeto.
    * Pense neles como as "informa√ß√µes" (sobre o objeto por isso caracter√≠sticas) que um objeto carrega consigo.
- **Exemplo:**
    * Em um objeto `carro`, atributos poderiam ser `cor`, `marca`, `modelo` e `ano`.
- **Acesso:**
    * Acessamos atributos usando a sintaxe `objeto.atributo`.

#### Rela√ß√£o entre M√©todos e Atributos

M√©todos frequentemente manipulam os atributos de um objeto. Por exemplo, um m√©todo `acelerar()` pode modificar o atributo `velocidade` de um objeto `carro`.

**Em resumo:**

* Atributos s√£o as caracter√≠sticas que um objeto possui.
* M√©todos s√£o as a√ß√µes que um objeto pode realizar.

Essa distin√ß√£o permite criar objetos que representam entidades do mundo real com suas pr√≥prias caracter√≠sticas e comportamentos.

### Obtendo Ajuda e Explorando

Python oferece ferramentas para ajudar voc√™ a aprender e explorar:

*   **`help()`:** Fornece documenta√ß√£o sobre fun√ß√µes, m√≥dulos ou tipos.

    ```python
    # help(print) # Descomente para ver a ajuda da fun√ß√£o print
    # help(str)   # Descomente para ver a ajuda sobre o tipo string
    # help(math)  # Descomente para ver a ajuda sobre o m√≥dulo math (precisa importar antes)
    ```
*   **`dir()`:** Lista os nomes (atributos e m√©todos) definidos por um objeto ou m√≥dulo.

    ```python
    # print(dir(str)) # Lista m√©todos e atributos de strings
    # print(dir(math)) # Lista fun√ß√µes e constantes do m√≥dulo math
    ```
*   **`type()`:** Como j√° vimos, retorna o tipo de um objeto.

No ambiente Jupyter Notebook, voc√™ tamb√©m pode usar:

*   `?` ap√≥s um nome de fun√ß√£o/objeto para ver sua documenta√ß√£o (ex: `print?` ou `frase.upper?`).
*   `??` ap√≥s um nome de fun√ß√£o/objeto para tentar ver o c√≥digo fonte (se dispon√≠vel).
*   Completar com `Tab`: Digite o in√≠cio de um nome de vari√°vel ou m√©todo e pressione `Tab` para ver sugest√µes.

---

Este cap√≠tulo cobriu os fundamentos essenciais para come√ßar a programar em Python. Nos pr√≥ximos cap√≠tulos, construiremos sobre essa base para explorar estruturas de dados mais complexas e as ferramentas espec√≠ficas para an√°lise de dados.

---

## Exerc√≠cios

**1. Escreva um programa que imprima na tela a seguinte mensagem: `Bem-vindo ao mundo Python!`.**

**2. Corrija os erros nos seguintes comandos `print()`:**

```
print("Python √© incr√≠vel!)
Print('Aprendendo Python')
print("Python √© legal! Mas n√£o o 'legal como dizem pra outras coisas")
```

**3. Utilize `print()` para exibir o seguinte texto em tr√™s linhas diferentes:**

```
Aprender Python  
√© muito  
divertido!
```

**4. Realize as opera√ß√µes matem√°ticas a seguir, guarde em uma vari√°vel e exiba os resultados. Al√©m de determinar a ordem de execu√ß√£o conforme as regras de preced√™ncia matem√°tica:**

- a)  $$\dfrac{100 ‚àí 413 \cdot (20 ‚àí 5 \times 4)}{5}$$
- b)  $$\dfrac{ \left[(3^{4} + \sqrt{144})(100 - 95,5) \right] + 6 }{-80 + 2^{4}}$$
- c)  $$3,9 \cdot 10^{-2} + 5,2 \cdot 10^{-1/3}$$

**5. Os seguintes c√≥digos cont√©m erros. Identifique e corrija:**

```
print('Vamos aprender Python!)
```
```
10 + "20"
```
```
x = 3
10,35 x 0.01
```

```{r include=FALSE, echo=FALSE}
library(reticulate)
use_python("C:/Users/user/anaconda3/python.exe", required = TRUE)
```

```{=html}
<style>
  body{text-align: justify}
</style>
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::

# Objetos no Python

## Introdu√ß√£o

Ao longo do curso, j√° mencionamos alguns tipos de objetos enquanto explor√°vamos conceitos b√°sicos de Python. Voc√™ provavelmente j√° viu vari√°veis sendo criadas e usadas, e at√© notou que diferentes valores podem ter diferentes tipos. Agora, chegou o momento de entender melhor os objetos b√°sicos do Python e como eles funcionam.

Neste cap√≠tulo, vamos explorar os principais tipos de objetos que o Python nos oferece, como n√∫meros, strings, listas e dicion√°rios. Al√©m disso, veremos como identificar o tipo de um objeto, buscar ajuda sobre fun√ß√µes e entender melhor as vari√°veis dispon√≠veis no c√≥digo.

Com essa nova organiza√ß√£o do curso, o conte√∫do foi dividido em cap√≠tulos menores para facilitar o aprendizado. Isso evita que tudo seja ensinado de uma vez, tornando a experi√™ncia mais din√¢mica e leve. Ent√£o, vamos come√ßar nossa jornada pelos objetos do Python! üöÄ

## Strings

Tamb√©m chamada de sequ√™ncia de caracteres, textos ou dados alfanum√©ricos, uma *string* √© um tipo de dado que armazena uma *sequ√™ncia de caracteres*. Em Python, pode ser definida com aspas simples (`'`), duplas (`"`) ou triplas (`'''` ou `"""`).

```{python}
"Texto com acentos e cedilhas: hoje √© dia de ca√ßa!"
```

```{python}
# As strings aceitam aspas simples tamb√©m
nome = 'Silvio Santos'
nome
```

### Opera√ß√µes com Strings

Podemos realizar diversas opera√ß√µes matem√°ticas e manipula√ß√µes em strings.

```{python}
# Multiplica√ß√£o repete a string
nome * 3
```
```
[Input]:  nome * 3.14
[Output]: TypeError: can't multiply sequence by non-int of type 'float'
```
```{python}
# Concatena√ß√£o de strings
canto1 = 'vem a√≠, '
canto2 = 'l√° '
nome + ' ' + canto1 + canto2 * 6 + '!!'
```

### Strings Multilinhas

Para definir strings que ocupam m√∫ltiplas linhas, utilize tr√™s aspas (`'''` ou `"""`):

```{python}
str_grande = '''Aqui consigo inserir um text√£o com v√°rias linhas.
Posso iniciar em uma...
... continuar em outra...
... e seguir quantas precisar.'''

str_grande
```

```{python}
print(str_grande)
```

Caso seja necess√°rio incluir aspas dentro da string, podemos alternar entre aspas simples e duplas:

```{python}
agua = "Me d√° um copo d'√°gua"
agua
```

Tamb√©m podemos usar todas as aspas ao mesmo tempo:

```{python}
todas_as_aspas = """Essa √© uma string que tem:
- aspas 'simples'
- aspas "duplas"
- aspas '''triplas'''
Legal, n√©?"""
                    
print(todas_as_aspas)
```

### Tamanho de uma String

A fun√ß√£o embutida `len()` nos permite obter o n√∫mero de caracteres de uma string, incluindo espa√ßos e pontua√ß√£o:

```{python}
len('Abracadabra')
```

```{python}
frase = 'Faz um pull request l√°'
len(frase)
```

```{python}
palavra = "Python"
len(palavra)
```


### Manipula√ß√£o de Strings

#### Indexa√ß√£o

Cada caractere em uma string possui um √≠ndice, come√ßando em `0` para o primeiro elemento e indo at√© `len(string) - 1` para o √∫ltimo elemento ou `-1`.

> *√çndices negativos percorrem de tr√°s para frente*

Para um melhor entendimento inicial, considere a vari√°vel criada na subse√ß√£o anterir:`palavra`. Partindo da defini√ß√£o acima, podemos afirmar que os √≠ndices da vari√°vel `palavra` segue o formato:

| P   | y   | t   | h   | o   | n   |
|-----|-----|-----|-----|-----|-----|
| 0   | 1   | 2   | 3   | 4   | 5   |
| -6  | -5  | -4  | -3  | -2  | -1  |

Vejamos alguns exemplos:

```{python}
# Primeiro caractere
print(palavra[0])
print(palavra[-6])
```
```{python}
# Primeiro caractere
print(palavra[5])
print(palavra[-1])
```

#### Fatiamento

Fatiamento (*slincing*) √© a capacidade de extrair partes de uma string utilizando `inicio:fim - 1:passo`.

```{python}
# Guardando um objeto do tipo str na vari√°vel frase
frase = "A programa√ß√£o em " + palavra + " √© diferenciada!"
frase
```

```{python}
# Comprimento da vari√°vel frase
nStr = len(frase)
nStr
```
```{python}
# Obtendo a frase completa usando fatiamento
print(frase[:nStr - 1])
print(frase[-nStr:])
```
```{python}
# Obtendo a frase de dois em dois caractere
print(frase[:nStr - 1:2])
print(frase[-nStr::2])
```
```{python}
# Obtendo apenas 'A programa√ß√£o'
print(frase[:14])
print(frase[:-25])
```

```{python}
# Obtendo o que h√° depois de 'A programa√ß√£o'
print(frase[14:])
print(frase[-25:])
```

```{python}
# Obtendo toda a frase de tr√°s para frente
print(frase[::-1])
```
> **Nota:** Omitir o primeiro √≠ndice (`start`) ou o segundo √≠ndice (`stop`) significa, respectivamente, come√ßar desde o come√ßo ou terminar no fim.

Resumindo: para fazer uma fatia de nossa string, precisamos saber de onde come√ßa, at√© onde vai e o tamanho do passo.

```         
fati√°vel[come√ßo : fim : passo]
```

##### Aten√ß√£o para o uso de indexa√ß√£o e fatiamento

As fatias incluem o √≠ndice do primeiro elemento e n√£o incluem o elemento do √≠ndice final. Por isso que `frase[0:-1]` perde o √∫ltimo elemento.

Caso o **fim** da fatia seja antes do come√ßo, obtemos um resultado vazio:

```{python}
frase[59:105]
```

O que acontece com uma fatia que est√° fora da string?

```{python}
frase[123:345]
```

E se o **fim** da fatia for superior ao comprimento da string? Sem problemas, o Python pecorrer a string at√© o onde der:

```{python}
frase[8:123456789]
```

Mas um √≠ndice fora do intervalo em acesso direto gera erro:

```         
[Input]  : frase[123456789]
[Output] : IndexError: string index out of range
```

Quando usamos passos negativos, a fatia come√ßa no **fim** e termina no **come√ßo** e √© percorrida ao contr√°rio. Ou seja, invertemos a ordem. Mas tome cuidado:

```{python}
"Python"[2:6]
```

```{python}
"Python"[2:6:-1]
```

```{python}
"Python"[6:2]
```

```{python}
"Python"[6:2:-1]
```

- `"Python"[6:2]`: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© positivo (default). Nesse caso, o resultado √© uma string vazia, pois o slicing avan√ßa para a direita, mas o fim est√° √† esquerda.
- `"Python"[2:6:-1]`: O √≠ndice de in√≠cio (2) √© menor que o √≠ndice de fim (6), mas o passo √© negativo (-1). O slicing tenta avan√ßar para a esquerda, mas o fim est√° √† direita. Novamente, o resultado √© uma string vazia.
- `"Python"[6:2:-1]`: O √≠ndice de in√≠cio (6) √© maior que o √≠ndice de fim (2), e o passo √© negativo (-1). O slicing avan√ßa para a esquerda, come√ßando do √≠ndice 6 ('n') at√© o √≠ndice 2 ('t'), excluindo-o. Isso resulta na string "noh".

### Formata√ß√£o de Strings

Podemos formatar strings utilizando `f-strings`, `.format()` ou `%`:

```{python}
nome = "Breno"
idade = 21

print(f"Ol√°, meu nome √© {nome} e tenho {idade} anos.")           # f-strings
print("Ol√°, meu nome √© {} e tenho {} anos.".format(nome, idade)) # format()
print("Ol√°, meu nome √© %s e tenho %d anos." % (nome, idade))     # Estilo antigo
```
O autor recomenda usar a primeira op√ß√£o.

### M√©todos √öteis para Strings

Ao definirmos o objeto `string` em Python, s√£o definidas tamb√©m algumas a√ß√µes que este objeto pode executar.

```{python}
# Defini-se um string qualquer
frase = " Python √© legal! "

# Visualizar vari√°vel
frase
```

1. M√©todo `str.lower()`: Deixa qualquer caractere em min√∫sculo.

```{python}
frase.lower()
```

2. M√©todo `str.upper()`: Deixa qualquer caractere em mai√∫sculo.

```{python}
frase.upper()
```
    
3. M√©todo `str.strip()`: Remove os espa√ßos extras.

```{python}
frase.strip()
```
    
4. M√©todo `str.title()`: Primeiro caractere de cada palavra em letra mai√∫scula.

```{python}
frase.strip().title()
```
    
5. M√©todo `str.replace()`: Troca um determinado caractere (1¬∫ argumento) por um outro determinado caractere (2¬∫ argumento).

```{python}
frase.replace("Python", "Programar")
```

6. M√©todo `str.index()`: Retorna o √≠ndice de determinado caractere contido na string.

```{python}
frase.index("√©")
```
    
7. M√©todo `str.count()`: Quantifica o n√∫mero de apari√ß√µes de determinado caractere na string.

```{python}
frase.count("a")
```
    
8. M√©todo `str.split()`: Cria uma lista a partir de fatias da string com base em um caractere.

```{python}
# M√©todo split sem argumento (default)
print(frase.split())

# M√©todo split com argumento
print(frase.split("√©"))
```

## Listas

Listas s√£o uma das estruturas de dados mais usadas em Python. Elas permitem armazenar m√∫ltiplos valores em uma √∫nica vari√°vel e suportam diversos tipos de opera√ß√µes.

### Declara√ß√£o de Listas

Uma lista em Python √© definida utilizando colchetes `[]`, e seus elementos s√£o separados por v√≠rgulas:

```{python}
# Lista de n√∫meros
numeros = [1, 2, 3, 4, 5]

# Lista de strings
frutas = ["ma√ßa", "banana", "abacaxi"]

# Lista mista
dados = [25, "Jo√£o", True, 3.14]
```

Uma lista tamb√©m pode ser vazia, algo que futaremente veremos que pode ser muito √∫til, por exemplo:

```{python}
vazia = []
vazia
```

### Indexa√ß√£o e Fatiamento

A ideia de √≠ndices e fatias de listas funciona de forma muito parecida com a que foi vista em strings.

```{python}
numeros[0] # Primeiro elemento
```

```{python}
numeros[-1] # √öltimo elemento
```

Assim como na indexa√ß√£o de strings, ao tentar acessar um √≠ndice inv√°lido de uma lista √© retornado um erro.

Ao √≠nves de simplesmente acessar um elemneto atrav√©s de seu √≠ndice, podemos obter uma fatia, que pode ser muito mais interessante.

```{python}
numeros[::2] # Do come√ßo ao fim, de 2 em 2 elementos
```

```{python}
numeros[::-2] # Do fim ao come√ßo, de 2 em 2 elementos
```

```{python}
numeros[:3]   # Tr√™s primeiros elementos
```

```{python}
numeros[3:]   # Elementos a partir do √≠ndice 3
```

```{python}
numeros[::-1] # Lista invertida
```

### Trabalhando com Listas

Imagine que se queira saber se um determinado elemento (objeto) est√° contido em determinada lista. Poderiamos ficar procurando elemento a elemento, vamos tentar essa abordagem. Verifique se o elemento `0.3146778807984779` est√° contido na lista abaixo:

```{python}
import random as rd

rd.seed(42)

va = [rd.random() for _ in range(100)]
va
```
Note que n√£o √© vi√°vel essa abordagem. Para est√° finalidade devemos usar o operador l√≥gico `in`. Veja o exemplo:

```{python}
0.3146778807984779 in va # 'elemento' est√° contido em 'lista'
```

Lembra do operador `not`? Podemos combin√°-lo com o `in` para verificar se um elemento 'n√£o est√°' contido em uma determina lista. Sendo o contr√°rio (nega√ß√£o) da afirma√ß√£o acima.

```{python}
0.3146778807984779 not in va # 'elemento' n√£o est√° contido em 'lista'
```

Veja um exemplo de como o `in` funciona em uma outra situa√ß√£o.

```{python}
lista_mista = ['duas palavras', 42, True, ['batman', 'robin'], -0.84, 'hip√≥fise']
42 in lista_mista
```

```{python}
'batman' in lista_mista
```

```{python}
'batman' in lista_mista[3] # Note que o elemento com √≠ndice 3 tamb√©m √© uma lista
```

Consegue me dizer quantos elementos t√™m na lista `va`? Fique tranquilo! N√£o precisa contar, pode ser usado a fun√ß√£o `len` do Python para responder essa pergunta.

```{python}
len(va)
```

```{python}
len(lista_mista[3])
```

### Adicionar e Remover elementos de uma Lista

Podemos adicionar elementos de diversas formas:

```{python}
# Adiciona um √∫nico elemento ao final da lista
numeros.append(6)
numeros
```

```{python}
# Adiciona v√°rios elementos ao final da lista
numeros.extend([7, 8, 9])
numeros
```

```{python}
# Adiciona um elemento em uma posi√ß√£o espec√≠fica
numeros.insert(2, 15)  # Insere o n√∫mero 15 na posi√ß√£o 2 (3¬∫ elemento)
numeros
```

Podemos remover/excluir elementos de uma lista das seguintes formas:

```{python}
# Remove a primeira ocorr√™ncia de um valor espec√≠fico
numeros.remove(15)  # Remove o n√∫mero 15
numeros
```

```{python}
# Exclui o √∫ltimo elemento da lista
del numeros[-1]
numeros
```
E se, por exemplo, eu precisar come√ßar a lista do zero? Pode-se remover todos os elementos de uma lista, usando o m√©todo `clear()`:

```{python}
va.clear()
print("Lista de n√∫meros aleat√≥rios:")
print(va)

va = [rd.random() for _ in range(100)]
print("Lista de n√∫meros aleat√≥rios:")
print(va)
```

### Modificando elementos

Como as listas s√£o mut√°veis, podemos alterar seus valores diretamente:

```{python}
print(f"Antes da modifica√ß√£o: \n {frutas}")

# Alterando 'banana' por 'melancia'
frutas[1] = "melancia"

# Visualizando
print(f"Depois da modifica√ß√£o: \n {frutas}")
```

Outra forma de se fazer a modifica√ß√£o √©:

```{python}
# Obtendo a posi√ß√£o (√≠ndice) da fruta (string) 'melancia'
id = frutas.index("melancia")

# Alterando 'melancia' por 'banana'
frutas[id] = "banana"

# Visualizando
print(frutas)
```

### Ordena√ß√£o de Listas

Por v√°rios motivos, pode ser √∫til ter em m√£os uma lista ordenada. Como fazer isso? Veja os exemplos:

```{python}
desordenada = ['b', 'z', 'k', 'a', 'h']
print(f"Lista desordenada: \n {desordenada}")

# Ordenando
desordenada.sort()
print(f"Lista ordenada: \n {desordenada}")
```
Voltemos a lista `va`:

```{python}
# Modificando va um pouco
va_modified = [round(va[i] * 100) for i in range(len(va))]
print(va_modified)

# Ordenado de forma crescente
va_modified.sort()
print(va_modified)

# Ordenado de forma decrescente
va_modified.sort(reverse=True)
print(va_modified)
```

Al√©m do m√©todo `sort`, tem a fun√ß√£o nativa do Python. Fun√ß√£o `sorted()`: 

```{python}
# Ordenado de forma crescente novamente
va_modified = sorted(va_modified)
print(va_modified)
```

### C√≥pia de Listas

C√≥pia ou c√≥pias de listas se torna algo de grande valor quando se quer fazer alguma manipula√ß√£o, por√©m n√£o se quer alterar as informa√ß√µes originais. Para isso, deve-se usar o m√©todo `copy()`:

```{python}
# Criando listas
l1 = [[1, 2, 3], ["x", "y", "z"], [True, False]]
l2 = l1.copy() # l2 √© a c√≥pia de l1

# Visualizando
print(l1)
print(l2)

# Adicioando um elemento novo somente a l2
l2.append([1/4, 1/2, 3/4, 1])

# Visualizando
print(l1)
print(l2)
```

Agora, observe o que acontece se n√£o fizer uso do `copy()`:

```{python}
# Criando listas
l1 = [[1, 2, 3], ["x", "y", "z"], [True, False]]
l2 = l1 # l2 'igual' a l1

# Visualizando
print(l1)
print(l2)

# Adicioando um elemento novo somente a l2
l2.append([1/4, 1/2, 3/4, 1])

# Visualizando
print(l1)
print(l2)
```

### Operando Listas

Fazendo uso ao conhecimento adquirido de strings. Temos os operadores `+` e `*`, que funcionam de forma muito similar e obdecem as mesmas regras.

O operador `+` concatena (semelhante ao m√©todo `extend()`) listas:

```{python}
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
c
```

O operador `*` repete a lista dado um n√∫mero de vezes:

```{python}
a * 2
```

```{python}
d = c + a + b + 2 * c
d
```

O Python fornece v√°rias outras opera√ß√µes √∫teis para listas, calculadas com fun√ß√µes do m√≥dulo b√°sico do Python. Entretanto, tais fun√ß√µes s√≥ se aplicam a listas num√©ricas:

```{python}
print(f"Soma da lista 'd': {sum(d)}")
print(f"Maior valor da lista 'd': {max(d)}")
print(f"Menor valor da lista 'd': {min(d)}")
```
Agora, imagine que seja necess√°rio saber quantas vezes um determinado elemento se repete dentro de uma lista. Tal a√ß√£o pode ser feita pelo m√©todo `count()`:

```{python}
# Lembra dessa lista
print(va_modified)

# Quanta vezes o n√∫mero 100 aparece?
print(va_modified.count(100))
```

### Uso da Fun√ß√£o `range()` em Listas

Em Python, al√©m de fun√ß√µes como print(), len(), sum(), max() e min(), temos a fun√ß√£o range(), que tamb√©m faz parte do m√≥dulo b√°sico. Essa fun√ß√£o √© extremamente √∫til para criar sequ√™ncias num√©ricas, especialmente listas. Imagine que voc√™ precise criar uma lista com os n√∫meros de 1 a 200. Como fazer isso de forma eficiente?

Uma abordagem seria escrever todos os n√∫meros manualmente:

```         
lista_grande = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ..., 200]
```

No entanto, essa n√£o √© a forma mais pr√°tica. √â a√≠ que entra a fun√ß√£o `range()`. Com ela, podemos gerar essa lista de forma muito mais simples:

```{python}
list(range(1, 201))  # Note que o limite superior √© 201
```

O `range()` tamb√©m oferece flexibilidade para gerar sequ√™ncias com intervalos espec√≠ficos. Por exemplo, para obter os n√∫meros de 0 a 29, pulando de 5 em 5:

```{python}
list(range(0, 30, 5))
```

Al√©m disso, o `range()` tamb√©m oferece algumas coisas interessantes. Por exemplo, imprimir os n√∫meros espa√ßados de 5 em 5, entre 0 e 30:

```{python}
list(range(0, 30, 5))
```

A sintaxe geral do `range()` √©: `range(start, stop, step)`, onde:

- `start`: O valor inicial da sequ√™ncia (inclusivo).
- `stop`: O valor final da sequ√™ncia (exclusivo).
- `step`: O intervalo entre os valores.

Por que precisamos converter `range()` para `list`?

```{python}
print(range(200))
print(type(range(200)))
```

Isso acontece porque `range(`) retorna um objeto do tipo `range`, que representa uma sequ√™ncia num√©rica, mas n√£o √© uma lista em si. Para visualizar os n√∫meros, precisamos convert√™-lo explicitamente para uma lista:

```{python}
range_lista = list(range(200))
print(range_lista)
```

## Dicion√°rios

Dicion√°rios em Python s√£o estruturas de dados poderosas que armazenam informa√ß√µes no formato chave-valor. Diferentemente das listas, que s√£o indexadas por n√∫meros, os dicion√°rios usam chaves imut√°veis (strings, n√∫meros, tuplas, etc.) para acessar seus valores.

Um dicion√°rio √© uma cole√ß√£o de pares chave-valor, onde cada chave √© √∫nica e est√° associada a um valor: `{chave: valor}`.

- **Chaves √önicas:** Uma caracter√≠stica fundamental dos dicion√°rios √© que cada chave deve ser √∫nica. Tentar inserir chaves duplicadas resultar√° na substitui√ß√£o do valor anterior.

### Declara√ß√£o de Dicion√°rios

Em Python, dicion√°rios podem ser criados de diversas maneiras, oferecendo flexibilidade para diferentes situa√ß√µes.

1. **Cria√ß√£o Direta com Chaves e Valores:**

```{python}
# Dicion√°rio com informa√ß√µes de uma receita
receita = {
    "farinha": "2 x√≠caras",
    "ovos": 3,
    "leite condensado": "1 lata"
}

# Dicion√°rio com n√∫meros de telefone
telefones = {"ana": 123456, "yudi": 40028922, "julia": 4124492}
```

Neste exemplo, `"ana"` √© uma chave que est√° associada ao valor `123456`. Cada par chave-valor √© separado por v√≠rgula.

```{python}
print(receita)
print(telefones)
```

2. **Cria√ß√£o de um Dicion√°rio Vazio:**

Voc√™ pode criar um dicion√°rio vazio usando apenas chaves {}:

```{python}
contatos = {}
contatos
```

3. **Cria√ß√£o com a Fun√ß√£o dict():**

A fun√ß√£o `dict()` permite criar dicion√°rios de forma mais expl√≠cita, especialmente quando as chaves s√£o strings simples:

```{python}
pessoa = dict(nome="Carlos", idade=30, cidade="S√£o Paulo")
pessoa
```

4. **Com uma lista de listas:**

```{python}
# Definindo tr√™s listas diferentes
l1 = ["brigadeiro", "leite condesado, achocolatado"]
l2 = ["omelete", "ovos, azeite, condimentos a gosto"]
l3 = ["ovo frito", "ovo, √≥leo, condimentos a gosto"]

# Criando uma lista de listas
lr = [l1, l2, l3]

# Visualizando resultado
lr
```

```{python}
# Transformando lista de listas em um dicion√°rio
receitas = dict(lr)

# Visualizando o resultado
receitas
```

### Chaves

Podemos acessar os valores de um dicion√°rio atrav√©s de suas chaves:

```{python}
# Definindo um dicion√°rio para capitais de estados brasileiros
capitais = {"SP": "S√£o Paulo", "AC": "Rio Branco", "TO": "Palmas",
            "RJ": "Rio de Janeiro", "SE": "Aracaju", "MG": "Belo Horizonte"}

# Acessando o valor correspondente a chave "MG"
capitais["MG"]
```

Caso a chave n√£o exista, podemos evitar erros usando o m√©todo `get()`:

```{python}
capitais.get("PA")
```

```{python}
capitais.get("PA", "N√£o tem!")
```

Note que o m√©todo `get()` funciona de forma similar ao c√≥digo `dicion√°rio[chave]`, entretanto, caso a chave n√£o exista garantimos que o c√≥digo n√£o gere erro diferente do que aconteceria caso fosse usado `dicion√°rio[chave]`.

Repare, tamb√©m, que a chave `"PA"` n√£o foi adicionada ao dicion√°rio. 

```{python}
capitais
```
Agora, se o objetivo n√£o for saber o valor associado a determinada chave, mas sim saber se a chave existe, isso pode ser feito usando o m√©todo `keys` e o operador l√≥gico `in`:

```{python}
# Chaves do Dicion√°rio
print(capitais.keys())

# Verificando
print(f'A chave "PA" est√° no dicion√°rio capitais? {"PA" in capitais.keys()}')
```

Note que os valores de um dicion√°rio pode ser qualquer tipo de objeto. No entanto, foi usado, at√© ent√£o, para exemplos, apenas `strings`. Por√©m, pode-se colocar todo tipo de coisa dentro dos dicion√°rios, incluindo listas e at√© mesmo outros dicion√°rios:

```{python}
numeros = {"primos": [2, 3, 5], "pares": [0, 2, 4], "√≠mpares": [1, 3, 5]}
print(numeros)
```

```{python}
docente = {
  "Nome": "Prof Dr Vin√≠cius Duarte Lima", 
  "Forma√ß√£o": {"Gradua√ß√£o": "Eng El√©trica", "Mestrado": "Eng El√©trica", "Doutorado": "Eng El√©trica"},
  "Idade": 45,
}

print(docente)
```

Mesmo que os pares `chave: valor` estejam organizados na ordem que foram colocados, n√£o podemos acess√°-los por √≠ndices como far√≠amos em listas:

```         
[Input]  : numeros[2]
[Output] : KeyError: 2
```

Assim como os valores n√£o precisam ser do tipo string, o mesmo vale para as chaves:

```{python}
numeros_por_extenso = {2: "dois", 1: "um", 3: "tr√™s", 0: "zero"}
numeros_por_extenso[0]
```

```{python}
numeros_por_extenso[2]
```

> **Nota:** Listas e outros dicion√°rios n√£o podem ser usados como chaves por serem de tipos mut√°veis.

### Adicionando, Alterando e Removendo Elementos

Para exemplificar os comandos desta se√ß√£o, considere o dicion√°rio abaixo.

```{python}
# Informa√ß√µes de Cleiton
pessoa = {"nome": "Cleiton", "idade": 34, "fam√≠lia": {"m√£e": "Maria", "pai": "Enzo"}}

# Visualizando
pessoa
```

Para adicionar o item `"masculino"` a chave `"gen√™ro"` podemos usar os seguintes comandos:

```{python}
# Adicionando elemento
pessoa["gen√™ro"] = "rom√¢ntico"

# Visualizando
pessoa
```

De forma equivalente, temos:

```{python}
# Dicion√°rio de meses do ano
meses = {1: "Janeiro", 2: "Fevereiro", 3: "Mar√ßo"}

# Adicionando o m√™s de "Abril" na chave 4
meses[4] = "Setembro"

# Visualizando
meses
```
As vezes, podem haver inconsist√™ncias nos dados, logo, se torna necess√°rio corrigir tais inconsist√™ncias. Isso pode ser feito de forma muito simples, veja:

```{python}
# Executando altera√ß√µes
pessoa["gen√™ro"] = "masculino"
meses[4] = "Abril"

# Visualizando
print(pessoa)
print(meses)
```

Um d√∫vida que talvez possa surgir √© como fazer altera√ß√£o em listas que est√£o contidas em dicion√°rios. Na verdade, isso √© feito de forma bastante objetiva, veja:

```{python}
# Novo dicion√°rio
lixo = {"pl√°stico": ["garrafa", "copinho", "canudo"], 
        "papel": ["folha amassada", "guardanapo"], 
        "org√¢nico": ["batata", "resto do bandeco", "casca de banana"]}

# Visualizando
print(lixo)

# Obtendo lista de interesse para altera√ß√£o
lista_de_interesse = lixo["pl√°stico"]

# Verificando em qual posi√ß√£o est√° o elemneto que deve ser alterado
id = lista_de_interesse.index("garrafa")

# Fazendo a altera√ß√£o diretamente no dicion√°rio
lixo['pl√°stico'][id] = "sacola"

# Visualizando dicion√°rio alterado
lixo
```

Note que poderiamos ser mais direto, pois as listas em quest√£o t√™m comprimentos pequenos. Por√©m, tal c√≥digo j√° pode ser implementado para listas de grande comprimento.

Por√©m, ao lidarmos com dicion√°rios, talvez precisemos excluir algum elemento. Ser√£o apresentadas duas formas de fazer isso.

1. Usando o m√©todo `pop()`:
```{python}
pessoa.pop("fam√≠lia")
```
Repare que `dicion√°rio.pop(chave)` exclu√≠ o elemento e retorna os itens da chave exclu√≠da. Para visualizarmos o resultado basta chamar o dicion√°rio.
```{python}
pessoa
```

2. Usando o comando `del` do Python B√°sico:
```{python}
del meses[4]
```
Diferente do m√©todo `pop()`, o comando `del` n√£o retorna nada. Por√©m, para visualizar o resultado, precisamos chamar o objeto.
```{python}
meses
```
Para excluir todos os elementos de um dicion√°rio, temos o m√©todo `clear()`:

```{python}
# Apagando todos os elementos do dicion√°rio
lixo.clear()

# Visualizando
lixo
```

### Fun√ß√£o `list()` e Fun√ß√£o `len()` para Dicion√°rios

A fun√ß√£o `list()` converte um dicion√°rio em uma lista contendo apenas suas chaves:

```{python}
institutos_uspsc = {
    "IFSC": "Instituto de F√≠sica de S√£o Carlos",
    "ICMC": "Instituto de Ci√™ncias Matem√°ticas e de Computa√ß√£o",
    "EESC": "Escola de Engenharia de S√£o Carlos",
    "IAU": "Instituto de Arquitetura e Urbanismo",
    "IQSC": "Instituto de Qu√≠mica de S√£o Carlos"
}

# Convertendo dicion√°rio em lista de chaves
lista_chaves = list(institutos_uspsc)
print(lista_chaves)
```

A fun√ß√£o `len()` retorna o n√∫mero de itens em um objeto. Para dicion√°rios, ela conta o n√∫mero de pares chave-valor:

```{python}
# Contando itens no dicion√°rio
quantidade_institutos = len(institutos_uspsc)
print(quantidade_institutos)

# Equivalente a contar as chaves convertidas em lista
print(len(list(institutos_uspsc)))
```

### Outros comandos para dicion√°rios

Vejamos agora os m√©todos `items()` e `values()`. Considere o seguinte dicion√°rio:

```{python}
pessoa = {"nome": "Enzo", "RA": 242334, "curso": "fiscomp"}
```

1. `items()` - Retorna uma vis√£o dos pares chave-valor:
```{python}
pares = pessoa.items()
print(list(pares))
```

2. `values()` - Retorna uma vis√£o dos valores armazenados:

```{python}
valores = list(pessoa.values())
print(valores)
```

**Observa√ß√£o importante:** A fun√ß√£o `list()` aplicada diretamente a um dicion√°rio (`list(pessoa)`) retorna apenas as chaves, equivalente a `list(pessoa.keys())`.

Dicion√°rios em Python (vers√µes 3.7+) mant√™m a ordem de inser√ß√£o, mas a igualdade entre dicion√°rios considera apenas os pares chave-valor, n√£o a ordem:

```{python}
numerinhos = {"um": 1, "dois": 2, "tr√™s": 3}
numeritos = {"tr√™s": 3, "dois": 2, "um": 1}

print(numerinhos == numeritos)
print(numerinhos)  # Mostra na ordem de inser√ß√£o
print(numeritos)   # Mostra na ordem de inser√ß√£o diferente
```

Outro comando que pode ser usado para adicionar elementos em um dicion√°rio pode ser o m√©todo `update()`.

```{python}
# Lembra do dicion√°rios receitas?
print(receitas)

# Nova receita
outros_elementos = {"mingau": "massa, leite, a√ß√∫car"}

# Adicionando a nova receita
receitas.update(outros_elementos)

# Visualizando
print(receitas)
```

- **Resum√£o:**

1. Os m√©todos `items()` e `values()` (e `keys()`) retornam objetos de visualiza√ß√£o que refletem automaticamente as altera√ß√µes no dicion√°rio original;

2. A partir do Python 3.7, a ordem de inser√ß√£o √© preservada como caracter√≠stica da implementa√ß√£o, tornando-se parte da especifica√ß√£o na vers√£o 3.8;

3. Uso do m√©todo `update` para integraliza√ß√£o de dicion√°rios.

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::


```{r include=FALSE, echo=FALSE}
library(reticulate)
use_python("C:/Users/user/anaconda3/python.exe", required = TRUE)
```

```{=html}
<style>
  body{text-align: justify}
</style>
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::

# Controle de Fluxo & Fun√ß√µes em Python

---

## Introdu√ß√£o

Em programa√ß√£o, o **controle de fluxo** determina a ordem em que as instru√ß√µes s√£o executadas em um programa. Em Python, isso permite criar programas que tomam decis√µes e repetem a√ß√µes com base em condi√ß√µes espec√≠ficas, tornando seu c√≥digo mais din√¢mico e adapt√°vel.

**Nesta se√ß√£o, exploraremos as principais estruturas de controle de fluxo:**

- **Condicionais - `if`, `elif` e `else`:** Permitem executar blocos de c√≥digo diferentes dependendo se uma condi√ß√£o √© verdadeira ou falsa.
- **La√ßos - `for` e `while`:** Permitem repetir um bloco de c√≥digo v√°rias vezes, seja por um n√∫mero espec√≠fico de vezes ou enquanto uma condi√ß√£o for verdadeira.
- **Tratamento de exce√ß√µes - `try`, `except` e `finally`:** Permitem lidar com erros e situa√ß√µes inesperadas sem interromper o programa.
- **Palavras-chave - `break` e `continue`:** Permitem controlar o fluxo de execu√ß√£o dentro de la√ßos.

**Por que o controle de fluxo √© importante?** Imagine um programa que:

* Decide se um usu√°rio tem acesso a um sistema (`if`).
* Repete uma a√ß√£o at√© que um download seja conclu√≠do (`while`).
* Percorre uma lista de produtos para calcular descontos (`for`).
* Previne erros se um arquivo n√£o for encontrado (`try/except`).

Sem controle de fluxo, nossos programas seriam lineares e limitados. Com ele, ganhamos **flexibilidade** e **poder** para resolver problemas complexos.

Dominar o controle de fluxo √© essencial para qualquer pessoa que esteja aprendendo programa√ß√£o, pois ele est√° presente em praticamente todo c√≥digo real. Vamos come√ßar a explorar cada conceito com exemplos pr√°ticos e exerc√≠cios!

---

## Estruturas de Decis√£o

As estruturas de decis√£o em Python s√£o usadas para controlar o **fluxo do programa**, ou seja, para **decidir qual bloco de c√≥digo ser√° executado** dependendo de uma ou mais condi√ß√µes. Pense como um sem√°foro: dependendo da cor, uma a√ß√£o diferente deve ser tomada ‚Äî o mesmo acontece em um programa.

- Exemplo do mundo real:

```
Se estiver nublado:
    Levarei guarda-chuva
Sen√£o:
    N√£o levarei
```

> **Nota: Em Python, a indenta√ß√£o (recuo de quatro espa√ßos ou um *tab*) √© obrigat√≥ria para definir os blocos de c√≥digo. Isso significa que o que estiver indentado ser√° considerado parte da condi√ß√£o.**

---

### Estrutura `if` Simples

A estrutura mais b√°sica do controle de fluxo √© o `if`, que permite executar um bloco de c√≥digo apenas se uma condi√ß√£o for verdadeira.

```{python}
idade = 20
if idade >= 18:
    print("Voc√™ √© maior de idade.")
```

> Neste exemplo, como `idade` √© 20, que √© maior que 18, a mensagem ser√° exibida.

---

### Estrutura `if/else`

Se quisermos executar um c√≥digo para o caso em que a condi√ß√£o n√£o √© satisfeita, usamos o `else`.

```{python}
idade = 16
if idade >= 18:
    print("Voc√™ √© maior de idade.")
else:
    print("Voc√™ √© menor de idade.")
```

---

### Estrutura `if/elif/else`

Para avaliar m√∫ltiplas condi√ß√µes, usamos `elif` ("else if").

```{python}
nota = 8
if nota >= 9:
    conceito = "A"
elif nota >= 7:
    conceito = "B"
elif nota >= 5:
    conceito = "C"
else:
    conceito = "D"

print("Conceito:", conceito)
```

---

### Diferen√ßa entre `if/elif` e m√∫ltiplos `if` independentes {.unnumbered}

H√° uma difer√™n√ßa ao usar as condi√ß√µes `if/elif` e usar v√°rios `if` de forma consecutivas. √â importante entender como essa difer√™n√ßa funciona para que o seu programa n√£o atenda mais de uma condi√ß√£o quando na verdade "apenas uma" √© a verdadeira. Vamos h√° um exemplo claro e objetivo.

```{python}
if 1 == 1:
    print("Caiu no 1¬∫ if")
elif 1 >= 1:
    print("Caiu no elif")
else:
    print("Caiu no else")
```

Perceba que duas condi√ß√µes em teste s√£o verdadeiras. Por√©m, ao usarmos a estrutura `if/elif`, apenas *o bloco com a primeira condi√ß√£o verdadeira √© executado*. No exemplo, apenas o blobo seguinte a condi√ß√£o `if a == 1` foi executado.

Agora, veja o exemplo adaptado a estrutura de `if` consecutivos:

```{python}
if 1 == 1:
    print("Caiu no 1¬∫ if")
if 1 >= 1:
    print("Caiu no 2¬∫ if")
else:
    print("Caiu no else")
```

No bloco de c√≥digo acima n√£o h√° uma regra pr√© definida pelo Python. Ambos os blocos `if` ser√£o avaliados independentemente. Isso pode ser √∫til em algumas situa√ß√µes, mas exige aten√ß√£o!

---

### Outros Exemplos de Condicionais

- **1¬∫ Exemplo - Condicionais Aninhadas:** √ötil quando queremos verificar uma condi√ß√£o dada que outra j√° foi satisfeita. Ou seja, uma estrutura condicional pode estar dentro de outra.

```{python}
# Definindo uma vari√°vel num√©rica
value = 2.35

# 1¬™ condi√ß√£o (externa)
if value <= 1:
  print("O valor √© menor ou igual a 1")
  
  # 1¬™ condi√ß√£o (interna) dada que 1¬™ condi√ß√£o (externa) foi satisfeita
  if value < 0.5:
    print("E √© menor que 0,5")
    
  # 2¬™ condi√ß√£o (interna) dada que 1¬™ condi√ß√£o (externa) foi satisfeita
  elif value == 0.5:
    print("O valor √© igual a 0,5")
    
  # 3¬™ condi√ß√£o (interna) dada que 1¬™ condi√ß√£o (externa) foi satisfeita
  else:
    print("O valor √© maior que 0,5")
    
# 2¬™ condi√ß√£o
elif value <= 2:
  print("O valor √© menor ou igual a 2")
  
  # 1¬™ condi√ß√£o (interna) dada que 2¬™ condi√ß√£o (externa) foi satisfeita
  if value < 1.5:
    print("E √© menor que 1,5")
    
  # 2¬™ condi√ß√£o (interna) dada que 2¬™ condi√ß√£o (externa) foi satisfeita
  elif value == 1.5:
    print("O valor √© igual a 1,5")
    
  # 3¬™ condi√ß√£o (interna) dada que 2¬™ condi√ß√£o (externa) foi satisfeita
  else:
    print("O valor √© maior que 1,5")
    
# 3¬™ condi√ß√£o
else:
  print("Sabe-se apenas que o valor √© maior que 2")
  
  # 1¬™ condi√ß√£o (interna) dada que 3¬™ condi√ß√£o (externa) foi satisfeita
  if value <= 2.5:
    print("Podendo variar entre (2; 2,5]")
    
  # 2¬™ condi√ß√£o (interna) dada que 3¬™ condi√ß√£o (externa) foi satisfeita
  elif value <= 3:
    print("Podendo variar entre (2,5; 3]")
    
  # 3¬™ condi√ß√£o (interna) dada que 3¬™ condi√ß√£o (externa) foi satisfeita
  else:
    print("O valor √© maior que 3")
```

- **2¬∫ Exemplo - Classifica√ß√£o de Valores:** J√° pararam para pensar como o conceito √© dado pelo sistema da Universidade Federal do Par√°? A classifica√ß√£o ocorre da seguinte maneira:

```{python}
import random as rd

rd.seed(123456789)
review = [10 * rd.random() for _ in range(5)]
mean = sum(review) / len(review)
print(f"M√©dia das Avalia√ß√µes: {round(mean, 2)}")

# Em qual conceito est√° m√©dia estaria?
if (mean >= 0) and (mean < 5):
  print("O conceito do aluno foi INSUFICIENTE")
elif (mean >= 5) and (mean < 7):
  print("O conceito do aluno foi REGULAR")
elif (mean >= 7) and (mean < 9):
  print("O conceito do aluno foi BOM")
elif (mean >= 9) and (mean <= 10):
  print("O conceito do aluno foi EXCELENTE")
else:
  print("M√©dia de Avalia√ß√µes Inv√°lida")
```

- **2¬∫ Exemplo - Classifica√ß√£o de Valores:** J√° pararam para pensar como o conceito √© dado pelo sistema da Universidade Federal do Par√°? Mas tamb√©m pode ser feita de forma mais direta:

```{python}
print(f"M√©dia das Avalia√ß√µes: {round(mean, 2)}")

# Em qual conceito est√° m√©dia estaria?
if 0 <= mean < 5:
  print("O conceito do aluno foi INSUFICIENTE")
elif 5 <= mean < 7:
  print("O conceito do aluno foi REGULAR")
elif 7 <= mean < 9:
  print("O conceito do aluno foi BOM")
elif 9 <= mean < 10:
  print("O conceito do aluno foi EXCELENTE")
else:
  print("M√©dia de Avalia√ß√µes Inv√°lida")
```

- **3¬∫ Exemplo - Condi√ß√£o com Express√£o Tern√°ria:** Forma reduzida do `if/else,` muito √∫ltil para atribui√ß√µes simples. Exemplo com `string`:

```{python}
# Dados do usu√°rio
age = 19
CNH = True

# Verifica√ß√£o com Express√£o Tern√°ria
result = "Est√° apto a dirigir!" if age >= 18 and CNH != False else "N√£o est√° apto a dirigir!"

# Visualizar
print(result)
```

- **3¬∫ Exemplo - Condi√ß√£o com Express√£o Tern√°ria:** Forma reduzida do `if/else,` muito √∫ltil para atribui√ß√µes simples. Exemplo com `number`:

```{python}
# Definindo n√∫meros
x, y = 4, 5

# Verifica√ß√£o com Express√£o Tern√°ria
maior_valor = x if x > y else y

# Visualizar
print(maior_valor)
```

---

### Considera√ß√µes e Boas Pr√°ticas

- Use `elif` quando apenas uma entre v√°rias condi√ß√µes pode ser verdadeira;
- Evite aninhamentos profundos de `if`;
- Use opera√ß√µes compostas como `7 <= mean < 9` para mais clareza;
- Sempre comente blocos de c√≥digo complexos;
- Lembre das @tbl-operLogic que apresentam os *operadores l√≥gicos* e @tbl-conecLogic que mostra os *conectores l√≥gicos*.

---

## Estruturas de Repeti√ß√£o

As estruturas de repeti√ß√£o s√£o usadas para executar um bloco de c√≥digo v√°rias vezes, de forma autom√°tica, at√© que uma condi√ß√£o seja satisfeita ou uma sequ√™ncia de elementos seja percorrida.

Em Python, temos duas principais formas de repeti√ß√£o:

- `for`: Ideal quando sabemos o n√∫mero de repeti√ß√µes ou estamos percorrendo uma estrutura (lista, string, dicion√°rio, etc);
- `while`: Ideal quando n√£o sabemos o n√∫mero exato de repeti√ß√µes e precisamos que o c√≥digo continue enquanto uma condi√ß√£o for verdadeira.

---

### Estrutura `for`

A estrutura `for` √© uma das formas mais comuns de repeti√ß√£o em Python. Ela √© ideal quando:

- Sabemos de antem√£o quantas vezes o c√≥digo deve ser repetido; ou
- Queremos percorrer os elementos de uma sequ√™ncia (como listas, strings, dicion√°rios, etc.).

Vamos come√ßar com o b√°sico: o objeto `range()`.

```{python}
# Lembra do objeto range()?
range(3)
```

O comando acima n√£o imprime os n√∫meros, ele apenas cria um objeto que representa uma sequ√™ncia de 0 at√© 2 (tr√™s elementos, come√ßando do zero). Para visualizar os elementos, podemos convert√™-lo em uma lista:

```{python}
list(range(3))
```

Agora vamos usar o `range()` dentro de um la√ßo `for`:

```{python}
for i in range(3):
    print(i)
```
> Aqui, o loop `for` vai executar o bloco de c√≥digo tr√™s vezes, e a vari√°vel `i` assume os valores 0, 1 e 2 a cada repeti√ß√£o.

Voc√™ tamb√©m pode fazer a mesma coisa passando uma lista explicitamente:

```{python}
print(f"Lista exemplo para itera√ß√£o: {list(range(3))}")
print("Iniciando contagem:")

for contador in list(range(3)):
  print(f"Passo {contador + 1}: Valor atual = {contador}")

print("Contagem conclu√≠da!")
```
> O resultado ser√° o mesmo. Nesse caso, voc√™ est√° iterando diretamente sobre os elementos de uma lista.

---

#### Iterando em Strings

Strings s√£o sequ√™ncias de caracteres, e podemos percorr√™-las com o `for`.

```{python}
texto = "Curso de Python para An√°lise de Dados."
for caractere in texto:
    print(caractere)
```
> A cada repeti√ß√£o, a vari√°vel `letra` recebe um caractere da string. Esse recurso √© √∫til para manipula√ß√µes de texto.

---

#### Interando em Listas

Suponha que voc√™ tenha uma lista com nomes de frutas, e deseja imprimir cada fruta em letras mai√∫sculas.

```{python}
# Lista de frutas
frutas = ["ma√ß√£", "banana", "laranja", "abacaxi", "uva"]

# Imprimindo cada fruta em caixa alta
for fruta in frutas:
    print(fruta.upper())
```
> O m√©todo `upper()` transforma a string para letras mai√∫sculas. A vari√°vel fruta assume o valor de cada elemento da lista a cada itera√ß√£o.

Vamos ver outro exemplo: elevar n√∫meros ao quadrado e ao cubo:

```{python}
# Criando a lista de n√∫meros de 0 a 5
numbers = list(range(6))

# Iterando sobre a lista
for number in numbers:
    print(f"N√∫mero: {number}")
    print(f"N√∫mero ao quadrado: {number ** 2}")
    print(f"N√∫mero ao cubo: {number ** 3}\n")
```
> `number` assume os valores de 0 a 5 e cada itera√ß√£o √© mensurado o seu quadrado e o seu cubo.

---

#### Iterando em Dicion√°rios

Dicion√°rios s√£o estruturas de dados compostas por pares `chave:valor`. Podemos iterar por eles usando o m√©todo `items()`, que retorna as chaves e valores simultaneamente:

```{python}
# Dicion√°rio com tradu√ß√µes da palavra "gato"
translations = {"Portugu√™s": "gato", "Ingl√™s": "cat", "Franc√™s": "chat"}

# Percorrendo as chaves e os valores
for idioma, palavra in translations.items():
    print(f"{idioma} -> {palavra}")
```
> A cada itera√ß√£o, `idioma` recebe a chave e `palavra` recebe o valor correspondente.

Voc√™ tamb√©m pode usar `zip()` para fazer a itera√ß√£o:

```{python}
# Outra forma de iterar: combinando as chaves e os valores com zip()
for idioma, palavra in zip(translations.keys(), translations.values()):
    print(f"{idioma} -> {palavra}")
```
> O `zip()` combina os elementos das duas listas (chaves e valores) em pares.

**Iterando com `enumerate()`:** √Äs vezes, al√©m de acessar o valor de uma lista ou dicion√°rio, tamb√©m queremos saber a posi√ß√£o (√≠ndice) do elemento. Para isso, usamos `enumerate()`.

Vamos aplicar isso a um dicion√°rio um pouco mais complexo:

```{python}
# Dicion√°rio com informa√ß√µes de pessoas
dados = {
    "Nome": ["Igor", "Allan", "Vict√≥ria", "Izabella", "Fernando"],
    "Idade": [39, 17, 98, 45, 27],
    "Animal de Estima√ß√£o": ["Gato", "Tigre", "Arara", "Javali", "Ratatouille"]
}

# Percorrendo os dados
for i, key in enumerate(dados.keys()):
    if i == 0:
        print("Informa√ß√µes Coletadas:")
    for id in dados[key]:
        if id == dados[key][0]:
            print(f"   {i + 1}. {key}:")
            print(f"      {id}")
        else:
            print(f"      {id}")
```
> Aqui temos dois n√≠veis de repeti√ß√£o. O primeiro la√ßo percorre cada "coluna" do dicion√°rio, enquanto o segundo imprime os dados. O `enumerate()` √© usado para acessar o √≠ndice `i` da chave atual, que nos ajuda a numerar facilitando a visualiza√ß√£o de chave a chave.

Esse tipo de estrutura √© √∫til para imprimir dados de maneira organizada, como se fosse uma tabela ou relat√≥rio.

---

#### Compreens√£o de Listas (List Comprehension)

Uma forma compacta e elegante de construir listas com base em la√ßos `for` √© a compreens√£o de listas.

A sintaxe b√°sica √©:

```python
[expressao for item in lista]
```

Isso pode ser lido como: *aplique a `expressao` a cada `item` da `lista`*.

Vejamos um exemplo simples.

```{python}
# Forma tradicional
quadrados = []
for num in range(1, 11):
    quadrados.append(num ** 2)

# Visualizar
print(quadrados)

# Forma com list comprehension
quadrados = [num ** 2 for num in range(1, 11)]

# Visualizar
print(quadrados)
```
> A cada itera√ß√£o √© calculado o quadrado do `num` que assume valores de 1 a 10.

---

##### Compreens√£o de Listas com Condi√ß√£o `if`

√â poss√≠vel aplicar condicionais em compreens√£o de listas. De forma geral, a seguinte sintaxe √© seguida:

```python
[expression for item in list if condition]
```
Logo, a linha de c√≥digo acima diz *aplique a `expression` para cada `item` da `list` dado que `condition` √© verdadeira*.

Vejamos alguns exemplos:

```{python}
# Forma tradiconal
pares = []
for num in range(1, 21):
  if num % 2 == 0:
    pares.append(num)

# Visualizar  
print(pares)

# Forma com list comprehension
pares = [num for num in range(1, 21) if num % 2 == 0]

# Visualizar  
print(pares)
```
> Apenas os n√∫meros pares ser√£o inclu√≠dos na lista.

Tamb√©m √© poss√≠vel combinar v√°rias condi√ß√µes:

```{python}
# Forma tradiconal
multiplos = []
for num in range(100):
  if num % 2 == 0 and num % 5 == 0:
    multiplos.append(num)

# Visualizar  
print(multiplos)

# Forma com list comprehension
multiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0]

# Visualizar  
print(multiplos)
```
> A lista conter√° n√∫meros m√∫ltiplos de 2 **e** de 5.

```{python}
# Forma tradiconal
multiplos = []
for num in range(100):
  if num % 2 == 0 and num % 5 == 0 and num % 6 == 0:
    multiplos.append(num)

# Visualizar  
print(multiplos)

# Forma com list comprehension
multiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0 and num % 6 == 0]

# Visualizar  
print(multiplos)
```
> A lista conter√° n√∫meros m√∫ltiplos de 2, 5 **e** 6.

```{python}
# Forma tradiconal
multiplos = []
for num in range(100):
  if num % 2 == 0 and num % 5 == 0 or num % 6 == 0:
    multiplos.append(num)

# Visualizar  
print(multiplos)

# Forma com list comprehension
multiplos = [num for num in range(100) if num % 2 == 0 and num % 5 == 0 or num % 6 == 0]

# Visualizar  
print(multiplos)
```

> A lista conter√° n√∫meros m√∫ltiplos de 2 **e** de 5 **ou** de 6.

---

##### Compreens√£o de Listas com `if`  e `else`

A estrutura muda levemente:

```python
[expression_if if condition else expression_else for item in list]
```
Em outras palavras: *execute `expression_if` caso `condition` seja verdadeira e `expression_else` caso contr√°rio para cada `item` da `list`*.

Vamos a um exemplo.

```{python}
# Forma tradiconal
sucess_number_div_5 = []
for number in range(26):
  if number % 5 == 0:
    sucess_number_div_5.append("sucess")
  else:
    sucess_number_div_5.append("failure")

# Visualizar  
print(sucess_number_div_5)

# Forma com list comprehension
sucess_number_div_5 = ["sucess" if number % 5 == 0 else "failure" for number in range(26)]

# Visualizar  
print(sucess_number_div_5)
```
> A express√£o acima retorna uma lista com as palavras `"sucess"` ou `"failure"` dependendo do valor de cada n√∫mero.

---

##### M√∫ltiplas Compreens√£o de Listas

Aqui √© exigida um pouco mais de aten√ß√£o. Considere a matriz $$\mathbf{x} = \begin{bmatrix} 1 & 2 & 3 & 4 \\ 5 & 6 & 7 & 8 \\ 9 & 10 & 11 & 12 \end{bmatrix}$$ e $$\mathbf{x^{\intercal}} = \begin{bmatrix} 1 & 5 & 9 \\ 2 & 6 & 10 \\ 3 & 7 & 11 \\ 4 & 8 & 12 \end{bmatrix}.$$ Como fazer isso usando compreens√£o de listas?

```{python}
matrix = [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12]
]

print(matrix)
```


Para facilitar o entendimento e melhorar a aprendizagem, vamos fazer usando estrutura `for` de forma simples.

```{python}
# Forma tradiconal
transposta = []
for column in range(len(matrix[0])):
  row = []
  
  for element in matrix:
    row.append(element[column])
    
  transposta.append(row)

# Visualizar  
print(transposta)
```

Entretanto, √© poss√≠vel otimizar o c√≥digo usando compreens√£o de listas.

```{python}
# Forma com list comprehension
transposta = [[element[column] for element in matrix] for column in range(len(matrix[0]))]

# Visualizar  
print(transposta)
```

---

### Estrutura `while`

A estrutura de repeti√ß√£o `while` √© usada quando **n√£o sabemos com anteced√™ncia quantas vezes o bloco de c√≥digo deve ser repetido**. A repeti√ß√£o acontece **enquanto uma condi√ß√£o l√≥gica for verdadeira**. Assim que essa condi√ß√£o se torna falsa, o la√ßo √© encerrado automaticamente.

A estrutura geral √©:

```python
while condi√ß√£o:
    # bloco de c√≥digo
```

Isso significa que o c√≥digo dentro do `while` ser√° executado repetidamente **enquanto** a condi√ß√£o especificada for verdadeira. Por isso, √© **muito importante** garantir que a condi√ß√£o eventualmente se torne falsa ‚Äî do contr√°rio, o programa pode entrar em um **loop infinito**.

---

#### Exemplos de Uso

##### Contador Simples

```{python}
contador = 1

while contador <= 5:
    print(f"Contador: {contador}")
    contador += 1
```

Esse √© o uso mais b√°sico de um `while`. A vari√°vel de controle √© atualizada em cada repeti√ß√£o at√© que a condi√ß√£o se torne falsa.

---

##### Apenas N√∫meros Pares

```{python}
n = 1

while n <= 10:
    if n % 2 == 0:
        print(f"{n} √© par")
    n += 1
```

Neste exemplo, o `if` dentro do `while` adiciona uma **condi√ß√£o extra**, filtrando apenas os n√∫meros pares entre 1 e 10.

---

##### Exemplo com `input()`

```python
number = int(input("Digite um n√∫mero positivo: "))

while number <= 0:
    print("O n√∫mero fornecido n√£o √© positivo. Tente novamente!")
    number = int(input("Digite um n√∫mero positivo: "))

print(f"Parab√™ns. O n√∫mero fornecido √© positivo!")
```

Esse exemplo usa `input()` para verificar se o valor digitado √© positivo ou n√£o.

---

##### Exemplo com string: invertendo uma palavra

```{python}
palavra = "Python"
reverso = ""
i = len(palavra) - 1

while i >= 0:
    reverso += palavra[i]
    i -= 1

print(f"A palavra '{palavra}' invertida √© '{reverso}'.")
```

Aqui usamos `while` para percorrer uma string de tr√°s para frente e gerar sua vers√£o invertida.

---

##### Exemplo com lista: somando n√∫meros at√© esvaziar a lista

```{python}
numeros = [10, 20, 30, 40, 50]
soma = 0

while numeros:
    valor = numeros.pop()  # Remove o √∫ltimo elemento
    soma += valor

print(f"Soma dos valores: {soma}")
```

Esse exemplo mostra como o `while` pode operar **enquanto uma lista tiver elementos** ‚Äî uma abordagem comum para **estrutura de pilha**.

---

##### Exemplo com m√∫ltiplas condi√ß√µes

```{python}
dados, i = [12, -3, 5, 0, -8, 19, -1, 0, 7], 0

positivos, negativos, zeros = 0, 0, 0

while i < len(dados):
    if dados[i] > 0:
        positivos += 1
    elif dados[i] < 0:
        negativos += 1
    else:
        zeros += 1
    i += 1

print(f"Positivos: {positivos}, Negativos: {negativos}, Zeros: {zeros}")
```

Esse exemplo simula uma **classifica√ß√£o de dados** usando `while` com m√∫ltiplas condi√ß√µes `if-elif-else`.

---

## Comandos-Chave

Em desenvolvimento Python, √† medida que a complexidade do c√≥digo aumenta, torna-se fundamental o dom√≠nio de mecanismos para o tratamento robusto de erros e o controle preciso da execu√ß√£o de estruturas de repeti√ß√£o. Esta se√ß√£o explora dois grupos essenciais de comandos que possibilitam um fluxo de execu√ß√£o mais refinado e resiliente.

- **Tratamento de Exce√ß√µes:** Python oferece um conjunto de constru√ß√µes para o tratamento de exce√ß√µes, permitindo o desenvolvimento de c√≥digo capaz de responder de forma controlada a eventos inesperados durante a execu√ß√£o. Ao utilizar blocos `try`, `except` e, opcionalmente, `finally`, √© poss√≠vel interceptar e manipular erros, evitando a interrup√ß√£o abrupta do programa e implementando estrat√©gias de recupera√ß√£o ou finaliza√ß√£o controlada de recursos.

- **Controle de Fluxo em Loops:** Adicionalmente √†s estruturas condicionais b√°sicas, Python disponibiliza palavras-chave espec√≠ficas para o controle do fluxo de execu√ß√£o dentro de la√ßos de repeti√ß√£o (`for` e `while`). Os comandos `break` e `continue` fornecem mecanismos para alterar o comportamento padr√£o dos loops:

  - `break`: Interrompe a execu√ß√£o do loop corrente e transfere o controle para a pr√≥xima instru√ß√£o ap√≥s o loop.
  - `continue`: Interrompe a itera√ß√£o corrente e passa para a pr√≥xima itera√ß√£o do loop.

O dom√≠nio destas ferramentas de tratamento de exce√ß√µes e controle de fluxo em loops √© crucial para a escrita de c√≥digo Python robusto, eficiente e capaz de lidar com cen√°rios complexos de execu√ß√£o. A correta aplica√ß√£o destes conceitos contribui significativamente para a qualidade e a manutenibilidade de projetos de software.

---

### Tratamento de Exce√ß√µes

Em Python, erros em tempo de execu√ß√£o s√£o inevit√°veis (e.g., entrada inv√°lida, divis√£o por zero, arquivo ausente). O **tratamento de exce√ß√µes**, via blocos `try/except`, permite que o programa **continue executando** ao inv√©s de interromper. Ao prever e capturar erros espec√≠ficos, o c√≥digo reage de forma controlada, garantindo maior robustez e estabilidade da aplica√ß√£o. Essencial para software confi√°vel.

Um exemplo da estrutura b√°sica √© apresentado no bloco de c√≥digo abaixo:

```python
try:
    # C√≥digo que pode gerar erros
    numero = int(input("Digite um n√∫mero: "))
    resultado = 10 / numero
    print("Resultado:", resultado)
except ZeroDivisionError:
    # Executado se ocorrer o erro espec√≠fico
    print("Erro: Divis√£o por zero!")
except Exception as e:
    # Captura qualquer outro erro
    print(f"Erro inesperado: {e}")
else:
    # Executado se NENHUM erro ocorrer
    print("Opera√ß√£o bem-sucedida!")
finally:
    # Sempre executado (com ou sem erros)
    print("Fim do bloco try-except")
```

```{python}
try:
    # C√≥digo que pode gerar erros
    numero = 0
    resultado = 10 / numero
    print("Resultado:", resultado)
except ZeroDivisionError:
    # Executado se ocorrer o erro espec√≠fico
    print("Erro: Divis√£o por zero!")
except Exception as e:
    # Captura qualquer outro erro
    print(f"Erro inesperado: {e}")
else:
    # Executado se NENHUM erro ocorrer
    print("Opera√ß√£o bem-sucedida!")
finally:
    # Sempre executado (com ou sem erros)
    print("Fim do bloco try-except")
```

- O bloco `try` encapsula o c√≥digo pass√≠vel de gerar erros em tempo de execu√ß√£o.
- O bloco `except` especifica o tratamento para tipos particulares de erros (exce√ß√µes) que possam ocorrer dentro do bloco `try`. M√∫ltiplos blocos `except` podem ser definidos para lidar com diferentes tipos de exce√ß√µes. A captura gen√©rica de qualquer exce√ß√£o pode ser realizada com `except Exception`.
- O bloco `finally` √© executado invariavelmente, independentemente da ocorr√™ncia ou n√£o de uma exce√ß√£o dentro do bloco `try`. Sua principal aplica√ß√£o reside na execu√ß√£o de rotinas de finaliza√ß√£o, como o fechamento de arquivos ou a libera√ß√£o de conex√µes.

---

### Palavras-Chave

Dentro de la√ßos de repeti√ß√£o `for` e `while` em Python, as palavras-chave `break` e `continue` oferecem mecanismos essenciais para o controle preciso do fluxo de execu√ß√£o. `break` interrompe imediatamente a execu√ß√£o do loop, transferindo o controle para a instru√ß√£o seguinte ao bloco do loop. `continue`, por sua vez, encerra a itera√ß√£o corrente e passa para a pr√≥xima itera√ß√£o do loop. A utiliza√ß√£o estrat√©gica dessas palavras-chave contribui para a organiza√ß√£o e a efici√™ncia do c√≥digo em cen√°rios onde a execu√ß√£o padr√£o do loop necessita ser alterada condicionalmente.

---

#### `break` {.unnumbered}

```{python}
# Encontra o primeiro n√∫mero divis√≠vel por 7
for num in range(1, 10):
    if num % 7 == 0:
        print(f"Encontrado: {num}")
        break
    print(num)
```

```python
while True:
    senha = input("Digite a senha (1234) para sair: ")
    if senha == "1234":
        print("Senha correta! Saindo...")
        break
    print("Senha incorreta!")
```

---

#### `continue` {.unnumbered}

```{python}
# N√£o ir√° imprimir o n√∫mero 7
for num in range(1, 10):
    if num == 7:
        continue
    print(num)
```

```{python}
produtos = ["camiseta", "caneca", None, "poster", "", "adesivo"]
for item in produtos:
    if not item:  # None ou string vazia
        continue
    print(f"Processando: {item.upper()}")
```

---

## Fun√ß√µes

Vamos relembrar o conceito de *fun√ß√£o* dada por @Guidorizzi:

> "*Uma fun√ß√£o $f$ √© uma rela√ß√£o entre dois conjuntos $A$ e $B$, representada pela tripla $(A, B, a \mapsto b)$, onde $A$ √© o conjunto de partida (dom√≠nio), $B$ √© o conjunto de chegada (contradom√≠nio) e $a \mapsto b$ √© a regra que associa a cada elemento $a \in A$ um √∫nico elemento $b \in B$.*"

Para fins t√©cnicos, as fun√ß√µes em Python seguem esse mesmo racioc√≠nio. Uma fun√ß√£o √© um bloco de c√≥digo que executa uma tarefa espec√≠fica e pode ser reutilizado v√°rias vezes ao longo do programa. Ao inv√©s de repetir o mesmo conjunto de comandos, colocamos esses comandos dentro de uma fun√ß√£o e chamamos essa fun√ß√£o sempre que precisarmos dela. Pense nela como uma "minif√°brica" que recebe certas entradas (opcionalmente), processa-as e produz uma sa√≠da (opcionalmente).

No universo da programa√ß√£o, a capacidade de organizar o c√≥digo de forma organizad, modular e reutiliz√°vel √© um pilar para a constru√ß√£o de sistemas eficientes e de f√°cil manuten√ß√£o. Em Python, esse pilar √© sustentado pelas fun√ß√µes. Nesta se√ß√£o, exploraremos desde os conceitos b√°sicos at√© aspectos mais avan√ßados, com aplica√ß√µes pr√°ticas.

Voc√™ pode pensar em uma fun√ß√£o como uma "m√°quina" que recebe certos dados (chamados par√¢metros ou argumentos), processa esses dados e, em muitos casos, devolve um resultado (valor de retorno).

A import√¢ncia das fun√ß√µes √© multifacetada, apresentando v√°rias vantagens de fazer seu uso. Elas s√£o fundamentais para:

- **Modularidade:** Fun√ß√µes permitem quebrar programas grandes e complexos em partes menores e mais gerenci√°veis. Isso facilita o desenvolvimento, a depura√ß√£o e a compreens√£o do c√≥digo.

- **Reusabilidade de C√≥digo (DRY - Don't Repeat Yourself):** Uma vez definida, uma fun√ß√£o pode ser chamada m√∫ltiplas vezes de diferentes partes do programa, eliminando a necessidade de reescrever o mesmo c√≥digo repetidamente.

- **Abstra√ß√£o:** Fun√ß√µes escondem os detalhes de implementa√ß√£o de uma tarefa complexa. Voc√™ precisa saber o que a fun√ß√£o faz (sua finalidade), mas n√£o necessariamente como ela faz.

- **Manuten√ß√£o:** Se uma altera√ß√£o for necess√°ria em uma l√≥gica espec√≠fica, basta modificar a fun√ß√£o correspondente. Isso √© muito mais eficiente do que procurar e alterar v√°rias ocorr√™ncias do mesmo c√≥digo espalhado pelo programa.

- **Legibilidade:** O uso de fun√ß√µes com nomes descritivos torna o c√≥digo mais f√°cil de ler e entender, pois cada fun√ß√£o representa uma etapa l√≥gica clara no fluxo do programa.

### Sintaxe B√°sica

Em Python, para definir uma fun√ß√£o √© utilizado a palavra chave `def`, seguida do nome da fun√ß√£o e par√™nteses para os poss√≠veis par√¢metros e `:`. Ao pressionar *enter* o bloco ser√° automaticamnete identado (*quatro espa√ß√µes ou um tab*) pelo editor. Todo c√≥digo identado faz parte da fun√ß√£o.

```python
def name_function():
  # seu c√≥digo ser√° disposto aqui
  # e o Python ir√° compreende-lo como parte da fun√ß√£o
```

- **Exemplos:**

```{python}
def greeting1():
  print("Ol√°. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!")


def greeting2(nome):
  print(f"Ol√°, {nome}. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!")
  

greeting1()

greeting2("Breno")
```

### Par√¢metros e Argumentos

Fun√ß√µes podem receber dados de entrada para realizar suas tarefas. Esses dados s√£o passados atrav√©s de **par√¢metros** na defini√ß√£o da fun√ß√£o e **argumentos** na chamada da fun√ß√£o.

### Tipos de Par√¢metros/Argumentos:

1.  **Argumentos Posicionais:** S√£o os argumentos passados na ordem em que os par√¢metros s√£o definidos.

```{python}
def saudar(nome, sobrenome):
  print(f"Ol√°, {nome} {sobrenome}!")

saudar("Maria", "Silva") # Sa√≠da: Ol√°, Maria Silva!
saudar("Silva", "Maria") # Sa√≠da: Ol√°, Silva Maria!
```

2.  **Argumentos de Palavra-chave (Keyword Arguments):** S√£o passados explicitamente associando o nome do par√¢metro ao seu valor. A ordem n√£o importa.

```{python}
def email(nome, dominio="icen.ufpa.br"):
    return f"{nome.lower()}@{dominio}"

print(email(nome="joao"))                            # Sa√≠da: joao@icen.ufpa.br
print(email(dominio="ufpa.br", nome="ANA")) # Sa√≠da: ana@ufpa.br
```

3.  **Par√¢metros com Valores Padr√£o (Default Parameters):** Permitem definir um valor padr√£o para um par√¢metro. Se o argumento n√£o for fornecido na chamada da fun√ß√£o, o valor padr√£o √© utilizado.

```{python}
def calcular_potencia(base, expoente=2): # expoente tem valor padr√£o 2
    return base ** expoente

print(calcular_potencia(3))    # Sa√≠da: 9 (3^2)
print(calcular_potencia(2, 4)) # Sa√≠da: 16 (2^4)
```

**Cuidado:** Par√¢metros com valores padr√£o devem ser definidos ap√≥s os par√¢metros sem valores padr√£o.

4.  **Argumentos Arbitr√°rios (`*args` e `**kwargs`):** Permitem que uma fun√ß√£o aceite um n√∫mero vari√°vel de argumentos.

* `*args` (non-keyword arguments): Coleta um n√∫mero vari√°vel de argumentos posicionais em uma tupla.

```{python}
def soma_tudo(*numeros):
    total = 0
    for num in numeros:
        total += num
    return total

print(soma_tudo(1, 2, 3))        # Sa√≠da: 6
print(soma_tudo(10, 20, 30, 40)) # Sa√≠da: 100
```

* `**kwargs` (keyword arguments): Coleta um n√∫mero vari√°vel de argumentos de palavra-chave em um dicion√°rio.

```{python}
def exibir_perfil(**info):
  for chave, valor in info.items():
      print(f"{chave.replace("_", " ").title()}: {valor}")

exibir_perfil(nome="Carlos", idade=30, cidade="S√£o Paulo")
# Sa√≠da:
# Nome: Carlos
# Idade: 30
# Cidade: S√£o Paulo

exibir_perfil(nome_cliente="Carlos", idade_cliente=30, cidade_cliente="S√£o Paulo")
# Sa√≠da:
# Nome Cliente: Carlos
# Idade Cliente: 30
# Cidade Cliente: S√£o Paulo
```

### Retorno de Valores

Vimos que √© poss√≠vel imprimir valores na tela atrav√©s de fun√ß√µes. Entretanto e se precisarmos dos valores que s√£o calculados por determinada fun√ß√£o? De acordo com o que apreendemos basta atribuir a sa√≠da do programa a uma vari√°vel.

```{python}
# Atribui√ß√£o
grr = greeting2("Emilly Rose")
```

Tamb√©m de acordo com o que apreendemos, basta chamar a vari√°vel `grr` em qualquer parte do c√≥digo que ela mostrar√° a frase: `Ol√°, Emilly Rose. Sej√° bem-vindo ao Curso de Python para An√°lise de Dados!`.

```{python}
# Chamando vari√°vel
grr
```

Note que a sa√≠da do c√≥digo acima, n√£o resultou em nada. Ou ainda, pode ter resultado, por√©m, o resutado foi vazio (`None`).

```{python}
# Verifica√ß√£o
grr == None
```

Note que, por consequ√™ncia, valores definidos dentro de uma fun√ß√£o n√£o s√£o exportados para fora dela. Isto √©, algo definido no `local` de um fun√ß√£o n√£o ser√° definido no ambiente `global`.

```{python}
def minha_funcao():
      arr = 10  # Vari√°vel local
      print(arr)

minha_funcao()

try:
  print(arr)  # Erro! 'arr' s√≥ existe dentro da fun√ß√£o.

except NameError:
  print("Vari√°vel 'arr' n√£o definida!")
```

Isso ocorre porque a estrutura que est√° sendo utilizada pela fun√ß√£o `greeting2` n√£o foi feita para retornar valores, mas sim, para apenas os imprimir na tela.

- **Boas Pr√°ticas de Escopo:**

    1. *Priorize o Escopo Local:* √â uma boa pr√°tica projetar fun√ß√µes para serem o mais independentes poss√≠vel, evitando depender de vari√°veis globais. Isso melhora a modularidade e reduz efeitos colaterais indesejados.
    2. *Evite o Uso de `global`:* A palavra-chave `global` permite modificar uma vari√°vel global dentro de uma fun√ß√£o. Seu uso deve ser evitado ao m√°ximo, pois pode levar a um c√≥digo confuso e dif√≠cil de depurar. Se uma fun√ß√£o precisa alterar dados globais, √© prefer√≠vel que ela retorne os novos valores para que o c√≥digo chamador possa atualizar a vari√°vel global explicitamente.
    3. *Passagem de Argumentos:* Sempre que uma fun√ß√£o precisar de dados externos, passe-os como argumentos, em vez de depender de vari√°veis globais.

Para que a fun√ß√£o realmente retorne o valor que foi obtido/calculado por ela, basta utilizar um comando interno do Python chamado `return`. Vamos a exemplos:

1. Soma de dois termos:

```{python}
def my_function_sum1(a, b):
  summ = a + b
  
  return summ
  
def my_function_sum2(a, b):
  return a + b


a = my_function_sum1(1/2, 1/2)
b = my_function_sum2(1/2, 1/2)

print(a == b)
```

2. Soma de $n$ termos:

```{python}
def my_function_sum(*numbers):
  summ = 0
  for num in numbers:
    if type(num) == list:
      for n in num:
        if (type(n) != int) or (type(n) != float):
          continue
        
        summ += n
    else:
        summ += num
    
  return summ
  
my_function_sum([1, 2, "a", 3], 5, 10, 20, 32)
```

Note que, se eu quiser o resultados desta soma para us√°-lo em outra hora, basta atribuir isso a uma vari√°vel.

```{python}
# Guardando soma
summ = my_function_sum([1, 2, "a", 3], 5, 10, 20, 32)

# Visualizando
print(summ)

# Verificando
print(summ == None) # A sa√≠da deve ser: False
```

### Fun√ß√µes An√¥nimas - `lambda functions`

Fun√ß√µes lambda s√£o pequenas fun√ß√µes an√¥nimas (sem nome) que s√£o definidas usando a palavra-chave `lambda`. Elas s√£o restritas a uma √∫nica express√£o e s√£o frequentemente usadas para tarefas curtas e simples onde uma fun√ß√£o completa seria excessiva.

- **Sintaxe:** `lambda argumentos: express√£o`

```{python}
# Definindo fun√ß√£o an√¥nima
square = lambda x: x ** 2

# Fazendo uso da fun√ß√£o
print(square(2))

# Definindo fun√ß√£o an√¥nima
linear = lambda x, y: 2 * x + y

# Fazendo uso da fun√ß√£o
print(linear(2, 3))

# Definindo fun√ß√£o an√¥nima
tt = lambda x: x * 2 + x

# Fazendo uso da fun√ß√£o
print(tt([1, 2, 3]))
```

Essa maniera de se definir uma fun√ß√£o √© comumente usada em conjunto das fun√ß√µes `sorted()`, `filter()` e `map()`.

```{python}
list_of_numbers = [2.5, 1, 5, 9, 0.1, 2, 8, 3, 12]

# Exemplo de uso com sorted()
print(sorted(list_of_numbers, key = lambda x: 1 / x ** 2))

# Exemplo de uso com filter()
print(list(filter(lambda x: x % 2 == 0, list_of_numbers)))

# Exemplo de um com map()
print(list(map(lambda x: x * 2, list_of_numbers)))
```

:::: progress
:::: {.progress-bar style="width: 100%;"}
::::
::::